import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from PIL import Image, ImageTk
import requests
from io import BytesIO
import traceback
import re
from tkinter.filedialog import asksaveasfilename
from tkinter.filedialog import askopenfilename
from tkinter.filedialog import askdirectory
import json
import datetime
import os
from tkinter import Toplevel








class GTAptWindow:
    def __init__(self):
        # Cria√ß√£o da p√°gina root
        self.root = tk.Tk()
        self.root.title("GTApt - Gerador de Texto BBCode")
        self.root.geometry("800x600")
        
        self.root.bind("<Control-f>", self.abrir_janela_busca)
        self.root.bind("<Control-l>", self.abrir_janela_busca)
        self.configurar_atalhos_busca(self.root)
        # Cria a barra de menu
        self.criar_barra_menu()
        
        self.caminho_base_dados = tk.StringVar(value=self.caminho_default())
        self.base_dados = {}  # Inicializa a vari√°vel self.base_dados aqui
        self.carregar_preferencias()
        
        self.frame_base_dados = ttk.Frame(self.root)
        self.frame_base_dados.grid(row=1, column=0, sticky="nsew")
        self.resultados = []  # Inicializa como lista vazia
        self.resultado_atual = -1  # Nenhum resultado selecionado inicialmente
        
    
        self.root.protocol("WM_DELETE_WINDOW", self.salvar_antes_de_sair)


        self.categoria_expandidas = {}  # Dicion√°rio para armazenar categorias expandidas
        self.opcoes_filtro = {}  
        self.filtros_por_entrada = {}
        self.filtros_vars = {}


        # Outras configura√ß√µes da interface
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)
        self.criar_abas()
        self.criar_abas_notebook()
            
    def configurar_diretorio_base_dados(self):
        # Garante que o diret√≥rio e o arquivo base_dados.json estejam configurados corretamente
        caminho = self.caminho_base_dados.get()
        if not os.path.exists(os.path.dirname(caminho)):
            os.makedirs(os.path.dirname(caminho))  # Cria o diret√≥rio, se necess√°rio

    
    def criar_barra_menu(self):
        menu_bar = tk.Menu(self.root)
        menu_base_dados = tk.Menu(menu_bar, tearoff=0)
        menu_base_dados.add_command(label="Abrir Base de Dados", command=self.abrir_base_dados)
        menu_bar.add_cascade(label="Base de Dados", menu=menu_base_dados)
        
        
        menu_mais = tk.Menu(menu_bar, tearoff=0)
        menu_mais.add_command(label="Prefer√™ncias", command=self.abrir_preferencias)
        menu_base_dados.add_command(label="Salvar Base de Dados", command=self.salvar_base_dados)
        menu_bar.add_cascade(label="Mais", menu=menu_mais)
        menu_mais.add_command(label="Buscar", command=self.abrir_janela_busca)


        self.root.config(menu=menu_bar)
    
    def abrir_preferencias(self):
        # Certifique-se de que a janela de prefer√™ncias √© uma vari√°vel de inst√¢ncia
        self.janela_pref = tk.Toplevel(self.root)
        self.janela_pref.title("Prefer√™ncias")
        self.janela_pref.geometry("500x150")

        def selecionar_pasta():
            pasta = askdirectory()  # Fun√ß√£o askdirectory chamada corretamente
            if pasta:
                self.caminho_base_dados.set(f"{pasta}/base_dados.json")
            self.janela_pref.lift()  # Garantir que a janela de prefer√™ncias continue no topo

        # Label e caixa de texto para o caminho
        ttk.Label(self.janela_pref, text="Diret√≥rio da Base de Dados:").pack(pady=10, anchor="w", padx=10)
        entrada_caminho = ttk.Entry(self.janela_pref, textvariable=self.caminho_base_dados, width=50)
        entrada_caminho.pack(padx=10, fill="x")

        # Bot√£o para selecionar a pasta
        botao_selecionar = ttk.Button(self.janela_pref, text="Selecionar Pasta", command=selecionar_pasta)
        botao_selecionar.pack(pady=10, padx=10, anchor="e")

        # Fun√ß√£o para salvar as prefer√™ncias
        def salvar_preferencias():
            try:
                print("Valores antes de salvar:", {k: v.get() for k, v in self.filtros_vars.items()})  # Debug
                self.salvar_preferencias()  # Salvar as prefer√™ncias
                print("Prefer√™ncias salvas com sucesso.")
                self.janela_pref.destroy()  # Fechar a janela de prefer√™ncias ap√≥s salvar
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao salvar as prefer√™ncias: {e}")


        ttk.Button(self.janela_pref, text="Salvar", command=salvar_preferencias).pack(pady=10, anchor="e", padx=10)

    def obter_caminho_preferencias(self):
        """Obt√©m o caminho para o arquivo de prefer√™ncias (mesmo local que o execut√°vel)."""
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), "preferencias.json")  
    
    def carregar_preferencias(self):
        """Carrega as prefer√™ncias salvas e restaura os filtros."""
        print("\n--- CARREGANDO PREFER√äNCIAS ---")
        
        try:
            with open(self.obter_caminho_preferencias(), "r", encoding="utf-8") as arquivo:
                preferencias = json.load(arquivo)

            self.opcoes_filtro = preferencias.get("opcoes_filtro", {})
            self.filtros_por_entrada = preferencias.get("filtros_por_entrada", {})
            print(f"üìÇ Prefer√™ncias carregadas corretamente? {self.filtros_por_entrada}")


            print("Filtros carregados com sucesso!")
        except FileNotFoundError:
            print("‚ùå Arquivo de prefer√™ncias n√£o encontrado. Usando valores padr√£o.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar prefer√™ncias: {e}")
            
        print("Prefer√™ncias carregadas:", self.filtros_por_entrada)



    def salvar_preferencias(self):
        """Salva as prefer√™ncias no arquivo JSON."""
        caminho_preferencias = self.obter_caminho_preferencias()

        preferencias = {
            "opcoes_filtro": self.opcoes_filtro,
            "filtros_por_entrada": self.filtros_por_entrada
        }

        try:
            with open(caminho_preferencias, "w", encoding="utf-8") as arquivo:
                json.dump(preferencias, arquivo, indent=4, ensure_ascii=False)
            print("‚úÖ Prefer√™ncias salvas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar prefer√™ncias: {e}")

    
    def caminho_default(self):
        # Caminho padr√£o para o arquivo base_dados.json em "Documentos\GTApt Gestor BBcode"
        documentos = os.path.expanduser("~\\Documents")
        caminho_base = os.path.join(documentos, "GTApt Gestor BBcode")
        if not os.path.exists(caminho_base):
            os.makedirs(caminho_base)  # Cria o diret√≥rio se n√£o existir
        return os.path.join(caminho_base, "base_dados.json")
    
    def ajustar_altura_texto(self, widget):
        widget.update_idletasks()
        num_linhas = int(widget.index('end-1c').split('.')[0])  # Contar linhas no TextBox
        largura_maxima = max(len(linha) for linha in widget.get("1.0", "end-1c").split("\n"))  # Calcular largura
        widget.configure(height=num_linhas, width=largura_maxima)

    def atualizar_base_dados(caminho_base_dados):
        """Atualiza a base de dados para incluir a coluna 'Texto Combinado (PT + EN)'."""

        if not os.path.exists(caminho_base_dados):
            messagebox.showerror("Erro", "Arquivo da base de dados n√£o encontrado!")
            return

        try:
            # Carregar a base de dados existente
            with open(caminho_base_dados, "r", encoding="utf-8") as arquivo:
                base_dados = json.load(arquivo)

            base_dados_atualizado = {}

            for categoria, conteudos in base_dados.items():
                novos_conteudos = []
                for item in conteudos:
                    if len(item) == 2:  # Se s√≥ tem PT e EN, falta o campo PT (EN)
                        pt, en = item
                        pt_en = f"{pt} ({en})"
                        novos_conteudos.append([pt, en, pt_en])  # Adiciona a nova estrutura
                    else:
                        novos_conteudos.append(item)  # Mant√©m a estrutura correta

                base_dados_atualizado[categoria] = novos_conteudos

            # Salvar a base de dados atualizada
            with open(caminho_base_dados, "w", encoding="utf-8") as arquivo:
                json.dump(base_dados_atualizado, arquivo, indent=4, ensure_ascii=False)

            messagebox.showinfo("Sucesso", "Base de dados atualizada com sucesso!")

        except Exception as e:
            messagebox.showerror("Erro", f"Falha ao atualizar a base de dados: {e}")
        
    def abrir_base_dados(self):
        """ Abre a janela da base de dados com suporte √† rolagem din√¢mica, evitando recarregamento desnecess√°rio."""
        if hasattr(self, 'janela_bd') and self.janela_bd.winfo_exists():
            self.janela_bd.lift()
            return
        
        self.janela_bd = tk.Toplevel(self.root)
        self.janela_bd.title("Base de Dados")
        self.janela_bd.geometry("800x600")
        self.configurar_atalhos_busca(self.janela_bd)
        
        self.janela_bd.bind_all("<MouseWheel>", lambda e: self.canvas_bd.yview_scroll(-1 * (e.delta // 120), "units"))

        self.frame_resultados = ttk.Frame(self.janela_bd)
        self.frame_resultados.grid(row=1, column=0, sticky="nsew")
        self.frame_resultados.grid_remove()

        self.janela_bd.grid_rowconfigure(1, weight=1)
        self.janela_bd.grid_columnconfigure(0, weight=1)
        self.frame_resultados.grid_rowconfigure(0, weight=1)
        self.frame_resultados.grid_columnconfigure(0, weight=1)
        self.janela_bd.transient(self.root)
        self.janela_bd.focus_set()

        frame_pesquisa = ttk.Frame(self.janela_bd)
        frame_pesquisa.grid(row=0, column=0, sticky="ew")

        caixa_texto = ttk.Entry(frame_pesquisa)
        caixa_texto.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        caixa_texto.bind("<KeyRelease>", lambda e: self.realizar_pesquisa(caixa_texto.get()))
        caixa_texto.bind("<Button-3>", lambda e, widget=caixa_texto: self.criar_menu_contexto(e, widget))
        caixa_texto.focus_set()

        botao_pesquisar = ttk.Button(frame_pesquisa, text="Pesquisar")
        botao_pesquisar.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        frame_pesquisa.columnconfigure(2, weight=1)

        botao_criar_categoria = ttk.Button(frame_pesquisa, text="Criar Categoria", command=self.criar_nova_categoria)
        botao_criar_categoria.grid(row=0, column=3, padx=5, pady=5, sticky="e")

        frame_corpo_bd = ttk.Frame(self.janela_bd)
        frame_corpo_bd.grid(row=1, column=0, sticky="nsew")

        self.canvas_bd = tk.Canvas(frame_corpo_bd)
        scrollbar_bd = ttk.Scrollbar(frame_corpo_bd, orient="vertical", command=self.canvas_bd.yview)
        scrollable_frame_bd = ttk.Frame(self.canvas_bd)

        scrollable_frame_bd.bind(
            "<Configure>",
            lambda e: self.canvas_bd.configure(scrollregion=self.canvas_bd.bbox("all"))
        )

        self.canvas_bd.create_window((0, 0), window=scrollable_frame_bd, anchor="nw")
        self.canvas_bd.configure(yscrollcommand=scrollbar_bd.set)

        self.canvas_bd.grid(row=0, column=0, sticky="nsew")
        scrollbar_bd.grid(row=0, column=1, sticky="ns")

        frame_corpo_bd.grid_rowconfigure(0, weight=1)
        frame_corpo_bd.grid_columnconfigure(0, weight=1)

        self.frame_base_dados = scrollable_frame_bd

        def rolar_com_mouse(event):
            self.canvas_bd.yview_scroll(-1 * (event.delta // 120), "units")

        self.canvas_bd.bind("<MouseWheel>", rolar_com_mouse)

        if not self.base_dados:
            try:
                with open(self.caminho_base_dados.get(), "r", encoding="utf-8") as arquivo:
                    self.base_dados = json.load(arquivo)
            except FileNotFoundError:
                self.base_dados = {}
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao carregar a base de dados: {e}")

        self.recriar_interface_categorias()
        self.janela_bd.protocol("WM_DELETE_WINDOW", self.fechar_base_dados)

    def fechar_base_dados(self):
        """Fecha a janela e remove eventos para evitar erros."""
        if hasattr(self, "canvas_bd"):
            self.canvas_bd.unbind("<MouseWheel>")  # ‚úÖ Remove a rolagem ao fechar
        self.janela_bd.destroy()
        self.janela_bd.unbind_all("<MouseWheel>")


        
    def validar_valores_categoria(self, novos_valores, valores_existentes):
        usados_pt = set()
        usados_en = set()
        repetidos_pt = set()
        repetidos_en = set()
        repetidos_iguais = set()
        duplicados = []
        valores_unicos = []

        for pt, en, pt_en in novos_valores:  # ‚úÖ Agora aceita 3 valores corretamente
            if pt == en:
                repetidos_iguais.add(pt)  # Guarda valores iguais
            elif pt in usados_pt:
                repetidos_pt.add(pt)
            elif en in usados_en:
                repetidos_en.add(en)
            elif (pt, en, pt_en) in valores_existentes:
                duplicados.append((pt, en, pt_en))
            else:
                valores_unicos.append((pt, en, pt_en))
                usados_pt.add(pt)
                usados_en.add(en)

        avisos = {}
        if repetidos_iguais:
            avisos["iguais"] = f"Os seguintes conte√∫dos s√£o iguais em PT e EN e foram ignorados:\n\n{', '.join(repetidos_iguais)}"
        if repetidos_pt:
            avisos["repetidos_pt"] = f"As seguintes entradas em PT est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_pt)}"
        if repetidos_en:
            avisos["repetidos_en"] = f"As seguintes entradas em EN est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_en)}"
        if duplicados:
            duplicados_str = "\n".join([f"{pt} | {en} | {pt_en}" for pt, en, pt_en in duplicados])
            avisos["duplicados"] = f"Os seguintes pares j√° existem na categoria e foram ignorados:\n\n{duplicados_str}"

        # Exibir alertas se houver avisos
        if avisos:
            mensagem = "\n\n".join(avisos.values())
            messagebox.showwarning("Aviso de Valida√ß√£o", mensagem)

        return {"valores_unicos": valores_unicos, "avisos": avisos}





    def criar_nova_categoria_carregada(self, categoria, valores):
        # Certifica que a categoria existe na base de dados
        if categoria not in self.base_dados:
            self.base_dados[categoria] = valores
            self.salvar_base_dados()  # Salva automaticamente

        # Reutiliza o processo existente
        self.criar_nova_categoria(categoria, valores)




    def formato_texto(self, texto_pt, texto_en):
        """Formato padr√£o para exibi√ß√£o de textos."""
        return f"{texto_pt} | {texto_en} | {texto_pt} ({texto_en})"
    
    def criar_nova_categoria(self, categoria=None, valores=None):
        if categoria and valores:  # Caso chamado automaticamente com dados carregados
            if categoria not in self.base_dados:
                self.base_dados[categoria] = valores

            # Atualiza a interface com a nova categoria
            self.recriar_interface_categorias()
            self.salvar_base_dados()  # Salva automaticamente

            return

        # Fluxo manual para criar nova categoria (janela interativa)
        janela_criar = tk.Toplevel(self.root)
        janela_criar.title("Criar Nova Categoria")
        janela_criar.geometry("600x400")

        # Configura√ß√£o da janela
        janela_criar.grid_rowconfigure(0, weight=1)
        janela_criar.grid_columnconfigure(0, weight=1)

        # Frame principal com barra de rolagem
        frame_principal = ttk.Frame(janela_criar)
        frame_principal.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        ttk.Label(frame_principal, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        entrada_categoria = ttk.Entry(frame_principal)
        entrada_categoria.grid(row=0, column=1, columnspan=2, sticky="ew", padx=5, pady=5)

        ttk.Label(frame_principal, text="Textos em PT:").grid(row=1, column=0, sticky="nw", padx=5, pady=5)
        texto_pt = tk.Text(frame_principal, height=10, width=30)
        texto_pt.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        ttk.Label(frame_principal, text="Textos em EN:").grid(row=1, column=1, sticky="nw", padx=5, pady=5)
        texto_en = tk.Text(frame_principal, height=10, width=30)
        texto_en.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

        # Fun√ß√£o para salvar a categoria
        def salvar_categoria():
            nome_categoria = entrada_categoria.get().strip()
            if not nome_categoria:
                messagebox.showerror("Erro", "O nome da categoria n√£o pode estar vazio.")
                return

            # Processar textos PT e EN
            textos_pt = texto_pt.get("1.0", "end-1c").strip().splitlines()
            textos_en = texto_en.get("1.0", "end-1c").strip().splitlines()

            if len(textos_pt) != len(textos_en):
                messagebox.showerror("Erro", "O n√∫mero de linhas em PT e EN deve ser igual.")
                return

            # Criar lista formatada com PT, EN e PT (EN)
            novos_valores = {(pt, en, f"{pt} ({en})") for pt, en in zip(textos_pt, textos_en)}

            valores_existentes = set(map(tuple, self.base_dados.get(nome_categoria, [])))

            # Realiza a valida√ß√£o dos valores antes de salvar
            resultado_validacao = self.validar_valores_categoria(novos_valores, valores_existentes)
            valores_unicos = resultado_validacao["valores_unicos"]

            if not valores_unicos:
                messagebox.showinfo("Nenhum Conte√∫do V√°lido", "Todos os valores foram ignorados por serem inv√°lidos ou repetidos.")
                return

            # Caso a categoria j√° exista
            if nome_categoria in self.base_dados:
                resposta = messagebox.askyesno(
                    "Categoria Existente",
                    f"A categoria '{nome_categoria}' j√° existe. Deseja adicionar os novos valores √† categoria existente?"
                )
                if resposta:  # Adicionar aos valores existentes
                    self.base_dados[nome_categoria] = list(valores_existentes.union(valores_unicos))
                else:  # Substituir os valores existentes
                    self.base_dados[nome_categoria] = list(valores_unicos)
            else:
                # Caso seja uma nova categoria
                self.base_dados[nome_categoria] = list(valores_unicos)

            # Atualizar a interface
            self.recriar_interface_categorias()
            self.salvar_base_dados()

            janela_criar.destroy()

        # Bot√£o de salvar
        ttk.Button(frame_principal, text="Salvar", command=salvar_categoria).grid(row=3, column=1, pady=10, sticky="e")





    # Fun√ß√£o auxiliar para fixar o comando de editar
    def _criar_funcao_editar(self, categoria):
        return lambda: self.editar_categoria(categoria)

    # Fun√ß√£o auxiliar para fixar o comando de apagar
    def _criar_funcao_apagar(self, categoria):
        return lambda: self.apagar_categoria(categoria)


    def atualizar_lista_categoria(self):
        # Limpar o frame atual sem destruir os frames existentes
        for widget in self.frame_base_dados.winfo_children():
            if isinstance(widget, ttk.Button):
                widget.destroy()

        # Criar bot√µes e frames para cada categoria
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )

        for index, categoria in enumerate(categorias_ordenadas):
            # Criar bot√£o para expandir/colapsar a categoria
            botao_categoria = ttk.Button(
                self.frame_base_dados,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                width=20
            )
            botao_categoria.grid(row=index * 2, column=0, sticky="w", padx=5, pady=5)

        # Criar frame associado √† categoria (inicialmente oculto)
        frame_categoria = ttk.Frame(self.frame_base_dados, relief="flat", borderwidth=0)
        setattr(self, f"frame_{categoria}", frame_categoria)  # Registra o frame no objeto
        self.criar_conteudo_frame(frame_categoria, categoria)
        frame_categoria.grid(row=index * 2 + 1, column=0, sticky="ew", padx=10, pady=5)
        frame_categoria.grid_remove()  # Inicia colapsado


        # Bot√£o para editar a categoria
        botao_editar = ttk.Button(
            self.frame_base_dados,
            text="‚úè",
            command=lambda c=categoria: self.editar_categoria(c)  # Vincula a categoria correta
        )
        botao_editar.grid(row=index * 2, column=1, padx=5, pady=5, sticky="w")

        # Bot√£o para apagar a categoria
        botao_apagar = ttk.Button(
            self.frame_base_dados,
            text="‚ùå",
            command=lambda c=categoria: self.apagar_categoria(c)  # Vincula a categoria correta
        )
        botao_apagar.grid(row=index * 2, column=2, padx=5, pady=5, sticky="w")



            
    def toggle_categoria_frame(self, categoria, forcar_rolagem=False):
        frame_atual = getattr(self, f"frame_{categoria}", None)
        if frame_atual:
            if self.categoria_expandidas.get(categoria, False):
                frame_atual.grid_remove()
                self.categoria_expandidas[categoria] = False
            else:
                frame_atual.grid()
                self.canvas_bd.update_idletasks()
                offset = self.frame_base_dados.winfo_y() / self.canvas_bd.bbox("all")[3]
                if forcar_rolagem:
                    self.canvas_bd.update_idletasks()
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y() + self.frame_base_dados.winfo_height()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura - 10) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(max(0, posicao_final))
                    self.canvas_bd.update_idletasks()
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y() + self.frame_base_dados.winfo_height()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(max(0, posicao_final))
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(posicao_final)
                self.categoria_expandidas[categoria] = True










    def criar_conteudo_frame(self, frame, categoria, conteudos=None):
        """Cria o frame com os conte√∫dos da categoria em colunas. Pode receber conte√∫dos filtrados."""
        conteudos = conteudos or self.base_dados[categoria]  # Usar conte√∫dos filtrados se fornecidos

        # Ordena os textos pelo texto PT
        textos_ordenados = sorted(self.base_dados[categoria], key=lambda x: x[0])  # Ordena pelo texto PT

        # Limpa o frame
        for widget in frame.winfo_children():
            widget.destroy()

        # Preenche a tabela no frame
        self.preencher_conteudo_tabela(frame, conteudos)




        
        
    def validar_valores_categoria(self, novos_valores, valores_existentes):
        usados_pt = set()
        usados_en = set()
        repetidos_pt = set()
        repetidos_en = set()
        repetidos_iguais = set()  # Para valores iguais em PT e EN
        duplicados = []
        valores_unicos = []

        for pt, en, pt_en in novos_valores:
            if pt == en:
                repetidos_iguais.add(pt)  # Guarda os valores iguais
            elif pt in usados_pt:
                repetidos_pt.add(pt)
            elif en in usados_en:
                repetidos_en.add(en)
            elif (pt, en) in valores_existentes:
                duplicados.append((pt, en))
            else:
                valores_unicos.append((pt, en))
                usados_pt.add(pt)
                usados_en.add(en)

        avisos = {}
        if repetidos_iguais:
            avisos["iguais"] = f"Os seguintes conte√∫dos s√£o iguais em PT e EN e foram ignorados:\n\n{', '.join(repetidos_iguais)}"
        if repetidos_pt:
            avisos["repetidos_pt"] = f"As seguintes entradas em PT est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_pt)}"
        if repetidos_en:
            avisos["repetidos_en"] = f"As seguintes entradas em EN est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_en)}"
        if duplicados:
            duplicados_str = "\n".join([f"{pt} | {en}" for pt, en in duplicados])
            avisos["duplicados"] = f"Os seguintes pares j√° existem na categoria e foram ignorados:\n\n{duplicados_str}"

        # Exibir alertas se houver avisos
        if avisos:
            mensagem = "\n\n".join(avisos.values())
            messagebox.showwarning("Aviso de Valida√ß√£o", mensagem)

        return {"valores_unicos": valores_unicos, "avisos": avisos}



        
    def apagar_categoria(self, categoria):
        
        if categoria not in self.base_dados:
            tk.messagebox.showerror("Erro", "Categoria n√£o encontrada para apagar.")
            return

        resposta = tk.messagebox.askyesno(
            "Confirmar Exclus√£o",
            f"Tem certeza de que deseja apagar a categoria '{categoria}'?"
        )
        if resposta:
            # Remover o frame associado √† categoria, se existir
            frame_nome = f"frame_{categoria}"
            if hasattr(self, frame_nome):
                frame = getattr(self, frame_nome)
                frame.destroy()
                delattr(self, frame_nome)

            # Remover a categoria da base de dados
            del self.base_dados[categoria]

            # Recriar a interface inteira (para evitar inconsist√™ncias)
            self.recriar_interface_categorias()
            self.salvar_base_dados()  # Salva automaticamente

            
            
    def recriar_interface_categorias(self):
        # Limpar todos os widgets do frame base
        for widget in self.frame_base_dados.winfo_children():
            widget.destroy()

        # Ordenar categorias
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )
        # Recriar as categorias ordenadas
        for index, categoria in enumerate(categorias_ordenadas):
            # Bot√£o para expandir/colapsar
            botao_categoria = ttk.Button(
                self.frame_base_dados,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                width=20
            )
            botao_categoria.grid(row=index * 2, column=0, sticky="w", padx=5, pady=5)

            # Bot√£o para editar a categoria
            botao_editar = ttk.Button(
                self.frame_base_dados,
                text="‚úè",
                command=lambda c=categoria: self.editar_categoria(c)
            )
            botao_editar.grid(row=index * 2, column=1, padx=5, pady=5, sticky="w")

            # Bot√£o para apagar a categoria
            botao_apagar = ttk.Button(
                self.frame_base_dados,
                text="‚ùå",
                command=lambda c=categoria: self.apagar_categoria(c)
            )
            botao_apagar.grid(row=index * 2, column=2, padx=5, pady=5, sticky="w")

            # Criar o frame associado √† categoria
            frame_categoria = ttk.Frame(self.frame_base_dados, relief="flat", borderwidth=0)
            setattr(self, f"frame_{categoria}", frame_categoria)

            # Adicionar o conte√∫do ao frame com ordena√ß√£o
            self.preencher_conteudo_categoria(frame_categoria, categoria)

            # Configurar o frame
            frame_categoria.grid(row=index * 2 + 1, column=0, columnspan=3, sticky="ew", padx=10, pady=5)
            frame_categoria.grid_remove()  # Esconde o frame inicialmente




    def preencher_conteudo_categoria(self, frame_categoria, categoria):
        """Preenche o frame com os dados da categoria, ordenados por PT, usando colunas com separadores verticais e permitindo a sele√ß√£o do texto com o cursor, al√©m de adicionar menu de contexto para copiar."""
        
        # Limpar o frame antes de preencher
        for widget in frame_categoria.winfo_children():
            widget.destroy()

        # Ordenar pelo texto PT
        conteudo_ordenado = sorted(
            self.base_dados[categoria], 
            key=lambda x: self.ordena_alfanumerico(x[0])
        )

        # Definir a cor de fundo padr√£o
        bg_color = "#F0F0F0"

        # Calcular a largura das colunas dinamicamente
        max_pt_len = max(len(pt) for pt, en, pt_en in conteudo_ordenado)
        max_en_len = max(len(en) for pt, en, pt_en in conteudo_ordenado)
        max_pt_en_len = max(len(pt_en) for pt, en, pt_en in conteudo_ordenado)

        # Adicionar os valores como labels nas colunas
        for index, (pt, en, pt_en) in enumerate(conteudo_ordenado):
            # Coluna 1 (PT)
            pt_text = tk.Text(frame_categoria, height=1, width=max_pt_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            pt_text.grid(row=index, column=0, sticky="w", padx=5, pady=2)
            pt_text.insert("1.0", pt)
            pt_text.config(state="disabled")
            pt_text.bind("<Button-3>", lambda e, text_widget=pt_text: self.criar_menu_contexto(e, text_widget))

            separator1 = ttk.Separator(frame_categoria, orient="vertical")
            separator1.grid(row=index, column=1, sticky="ns", padx=5, pady=2)

            # Coluna 2 (EN)
            en_text = tk.Text(frame_categoria, height=1, width=max_en_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            en_text.grid(row=index, column=2, sticky="w", padx=5, pady=2)
            en_text.insert("1.0", en)
            en_text.config(state="disabled")
            en_text.bind("<Button-3>", lambda e, text_widget=en_text: self.criar_menu_contexto(e, text_widget))

            separator2 = ttk.Separator(frame_categoria, orient="vertical")
            separator2.grid(row=index, column=3, sticky="ns", padx=5, pady=2)

            # Coluna 3 (PT + EN)
            pt_en_text = tk.Text(frame_categoria, height=1, width=max_pt_en_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            pt_en_text.grid(row=index, column=4, sticky="w", padx=5, pady=2)
            pt_en_text.insert("1.0", pt_en)
            pt_en_text.config(state="disabled")
            pt_en_text.bind("<Button-3>", lambda e, text_widget=pt_en_text: self.criar_menu_contexto(e, text_widget))

        # Configura√ß√£o din√¢mica de layout
        frame_categoria.grid_columnconfigure(0, weight=1)
        frame_categoria.grid_columnconfigure(1, weight=0)  # Separator 1
        frame_categoria.grid_columnconfigure(2, weight=1)
        frame_categoria.grid_columnconfigure(3, weight=0)  # Separator 2
        frame_categoria.grid_columnconfigure(4, weight=1)
        frame_categoria.grid_rowconfigure(0, weight=1)

        
        






    def editar_categoria(self, categoria):
        """Abre uma janela para editar os valores da categoria."""
        janela_editar = tk.Toplevel(self.root)
        janela_editar.title(f"Editar Categoria: {categoria}")
        janela_editar.geometry("650x450")

        # Frame principal com rolagem
        frame_principal = ttk.Frame(janela_editar)
        frame_principal.pack(fill="both", expand=True, padx=10, pady=10)

        # Canvas para rolagem
        canvas = tk.Canvas(frame_principal)
        scrollbar_y = ttk.Scrollbar(frame_principal, orient="vertical", command=canvas.yview)
        scrollbar_x = ttk.Scrollbar(frame_principal, orient="horizontal", command=canvas.xview)
        scrollable_frame = ttk.Frame(canvas)
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar_y.set, xscrollcommand=scrollbar_x.set)

        # Adicionar os scrollbars
        scrollbar_y.pack(side="right", fill="y")
        scrollbar_x.pack(side="bottom", fill="x")
        canvas.pack(side="left", fill="both", expand=True)

        # Entrada de Nome da Categoria
        ttk.Label(scrollable_frame, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        entrada_categoria = ttk.Entry(scrollable_frame, width=40)
        entrada_categoria.grid(row=0, column=1, columnspan=2, sticky="ew", padx=5, pady=5)
        entrada_categoria.insert(0, categoria)

        # Scroll horizontal para Entry
        self.adicionar_scroll_horizontal(entrada_categoria)


        # Campos de Texto para PT e EN
        ttk.Label(scrollable_frame, text="Textos em PT:").grid(row=1, column=0, sticky="nw", padx=5, pady=5)
        texto_pt = tk.Text(scrollable_frame, height=10, width=40, wrap="none")
        texto_pt.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        ttk.Label(scrollable_frame, text="Textos em EN:").grid(row=1, column=1, sticky="nw", padx=5, pady=5)
        texto_en = tk.Text(scrollable_frame, height=10, width=40, wrap="none")
        texto_en.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

        # Scroll horizontal para os Text
        self.adicionar_scroll_horizontal(texto_pt)
        self.adicionar_scroll_horizontal(texto_en)

        # Preencher os valores da categoria nas caixas de texto
        for pt, en, _ in self.base_dados.get(categoria, []):
            texto_pt.insert("end", f"{pt}\n")
            texto_en.insert("end", f"{en}\n")   

        # Configura√ß√£o do grid para expandir corretamente
        scrollable_frame.grid_columnconfigure(0, weight=1)
        scrollable_frame.grid_columnconfigure(1, weight=1)


        def guardar_alteracoes():
            nova_categoria = entrada_categoria.get().strip()
            if not nova_categoria:
                tk.messagebox.showerror("Erro", "O nome da categoria n√£o pode estar vazio.")
                return

            textos_pt = texto_pt.get("1.0", "end-1c").strip().splitlines()
            textos_en = texto_en.get("1.0", "end-1c").strip().splitlines()

            if len(textos_pt) != len(textos_en):
                tk.messagebox.showerror("Erro", "O n√∫mero de linhas em PT e EN deve ser igual.")
                return

            valores_existentes = set(map(tuple, self.base_dados.get(nova_categoria, [])))
            novos_valores = set(zip(textos_pt, textos_en))

            # üîπ Valida os termos antes de salvar
            resultado_validacao = self.validar_valores_categoria(novos_valores, valores_existentes)
            valores_unicos = resultado_validacao["valores_unicos"]

            if not valores_unicos:
                tk.messagebox.showinfo("Nenhum Conte√∫do V√°lido", "Todos os valores foram ignorados por serem inv√°lidos ou repetidos.")
                return

            # ‚úÖ Atualizar a base de dados com os valores filtrados
            self.base_dados[nova_categoria] = list(valores_existentes.union(valores_unicos))

            # ‚úÖ Renomeia a categoria caso tenha sido alterada
            if nova_categoria != categoria:
                del self.base_dados[categoria]

            # ‚úÖ Atualizar a interface
            self.recriar_interface_categorias()
            self.salvar_base_dados()
            janela_editar.destroy()

        # Adicionar o bot√£o "Salvar"
        frame_botao = ttk.Frame(janela_editar)
        frame_botao.pack(side="bottom", fill="x", padx=10, pady=10)

        # Bot√£o dentro do frame fixo no fundo da janela
        ttk.Button(frame_botao, text="Guardar Altera√ß√µes", command=guardar_alteracoes).pack(pady=5)


        frame_principal.grid_rowconfigure(0, weight=1)
        frame_principal.grid_columnconfigure(0, weight=1)


    def get_categoria_row(self, categoria):
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )

        index = categorias_ordenadas.index(categoria)
        return index * 2
    


    def salvar_base_dados(self):
        """Salva a base de dados garantindo que todos os itens contenham (PT, EN, PT (EN))."""
        caminho = self.caminho_base_dados.get()
        
        try:
            # Verifica se o arquivo existe antes de carregar
            if os.path.exists(caminho):
                with open(caminho, "r", encoding="utf-8") as arquivo:
                    conteudo_atual = json.load(arquivo)
            else:
                conteudo_atual = {}

            # Atualiza garantindo que a estrutura de cada item seja (PT, EN, PT (EN))
            base_dados_corrigido = {}
            
            for categoria, conteudo in self.base_dados.items():
                novos_itens = []
                for item in conteudo:
                    if len(item) == 2:  # Caso faltem os 3 valores, gera automaticamente
                        pt, en = item
                        pt_en = f"{pt} ({en})"
                        novos_itens.append([pt, en, pt_en])
                    else:
                        novos_itens.append(item)  # Mant√©m a estrutura se j√° estiver correta
                
                base_dados_corrigido[categoria] = novos_itens

            # Se o conte√∫do j√° for igual, n√£o precisa reescrever
            if conteudo_atual == base_dados_corrigido:
                return

            # Salva a base de dados corrigida
            with open(caminho, "w", encoding="utf-8") as arquivo:
                json.dump(base_dados_corrigido, arquivo, indent=4, ensure_ascii=False)
            
            print("‚úÖ Base de dados salva com sucesso!")

        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar a base de dados: {e}")




            

    def salvar_antes_de_sair(self):
        self.salvar_base_dados()
        self.root.destroy()
        
        
    def atualizar_categoria_interface(self, categoria):
        # Atualiza a lista de categorias para refletir as altera√ß√µes feitas
        self.atualizar_lista_categoria()
        # Expande a categoria editada para mostrar as altera√ß√µes
        self.toggle_categoria_frame(categoria)
        

    def atualizar_conteudo_categoria(self, categoria):
        """Atualiza o conte√∫do da categoria e ajusta a altura automaticamente."""
        frame_nome = f"frame_{categoria}"
        if hasattr(self, frame_nome):
            frame_categoria = getattr(self, frame_nome)
            
            for widget in frame_categoria.winfo_children():
                widget.destroy()
            
            self.criar_conteudo_frame(frame_categoria, categoria)


    def ordena_alfanumerico(self, texto):
        """Ordena alfanumericamente separando texto e n√∫meros."""
        # Divide o texto em partes num√©ricas e n√£o num√©ricas
        return [
            int(parte) if parte.isdigit() else parte.lower()
            for parte in re.split(r'(\d+)', texto)
        ]
    
    



    def realizar_pesquisa(self, termo_pesquisa, modo="pesquisa"):
        """Realiza a pesquisa nos dados da base e exibe os resultados."""
        print(f"üîç Realizando pesquisa: '{termo_pesquisa}'")

        # Limpar widgets existentes antes de popular novos resultados
        for widget in self.frame_resultados.winfo_children():
            widget.destroy()

        # Certifique-se de que o termo de pesquisa n√£o est√° vazio
        if not termo_pesquisa.strip():
            print("‚ö†Ô∏è Termo de pesquisa vazio. Abortando.")
            return

        resultados = {}  # Inicializa a vari√°vel resultados

        # Buscar em todas as categorias da base de dados
        for categoria, conteudos in self.base_dados.items():
            conteudos_filtrados = [
                item for item in conteudos 
                if termo_pesquisa.lower() in item[0].lower() or termo_pesquisa.lower() in item[1].lower()
            ]
            if conteudos_filtrados:
                resultados[categoria] = conteudos_filtrados

        if not resultados:
            print("‚ö†Ô∏è Nenhum resultado encontrado.")
            return

        # Criar widgets no frame_resultados
        for index, (categoria, conteudos) in enumerate(resultados.items()):
            print(f"Adicionando widgets para categoria: {categoria}, conte√∫dos: {conteudos}")

            # Frame para agrupar bot√µes e conte√∫do
            frame_categoria_completo = ttk.Frame(self.frame_resultados, relief="flat", borderwidth=0)
            frame_categoria_completo.grid(row=index, column=0, columnspan=3, sticky="ew", padx=5)

            # Bot√£o para expandir/colapsar a categoria
            botao_categoria = ttk.Button(
                frame_categoria_completo,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                style="TButton"
            )
            botao_categoria.grid(row=0, column=0, sticky="w", padx=5)

            # Separador vertical ap√≥s o bot√£o de categoria
            separator1 = ttk.Separator(frame_categoria_completo, orient="vertical")
            separator1.grid(row=0, column=1, sticky="ns", padx=5, pady=2)

            # Bot√£o para editar a categoria
            botao_editar = ttk.Button(
                frame_categoria_completo,
                text="‚úè",
                command=lambda c=categoria: self.editar_categoria(c),
                style="TButton"
            )
            botao_editar.grid(row=0, column=2, padx=(5, 2), sticky="w")

            # Separador vertical ap√≥s o bot√£o de editar
            separator2 = ttk.Separator(frame_categoria_completo, orient="vertical")
            separator2.grid(row=0, column=3, sticky="ns", padx=5, pady=2)

            # Bot√£o para apagar a categoria
            botao_apagar = ttk.Button(
                frame_categoria_completo,
                text="‚ùå",
                command=lambda c=categoria: self.apagar_categoria(c),
                style="TButton"
            )
            botao_apagar.grid(row=0, column=4, padx=(2, 5), sticky="w")

            # Frame para os conte√∫dos filtrados
            frame_categoria = ttk.Frame(frame_categoria_completo, relief="flat", borderwidth=0)
            frame_categoria.grid(row=1, column=0, columnspan=5, sticky="ew", padx=10)

            # Adiciona os valores nas colunas
            for content_index, (texto_pt, texto_en) in enumerate(conteudos):
                # Label para o texto PT
                pt_label = tk.Label(frame_categoria, text=texto_pt, anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                pt_label.grid(row=content_index, column=0, sticky="w", padx=5, pady=2)

                # Separador vertical ap√≥s a coluna PT
                separator3 = ttk.Separator(frame_categoria, orient="vertical")
                separator3.grid(row=content_index, column=1, sticky="ns", padx=5, pady=2)

                # Label para o texto EN
                en_label = tk.Label(frame_categoria, text=texto_en, anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                en_label.grid(row=content_index, column=2, sticky="w", padx=5, pady=2)

                # Separador vertical ap√≥s a coluna EN
                separator4 = ttk.Separator(frame_categoria, orient="vertical")
                separator4.grid(row=content_index, column=3, sticky="ns", padx=5, pady=2)

                # Label para o texto PT (EN)
                pt_en_label = tk.Label(frame_categoria, text=f"{texto_pt} ({texto_en})", anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                pt_en_label.grid(row=content_index, column=4, sticky="w", padx=5, pady=2)

            # Configura√ß√£o din√¢mica de layout
            frame_categoria.grid_columnconfigure(0, weight=1)
            frame_categoria.grid_columnconfigure(1, weight=0)  # Separator 3 (n√£o redimension√°vel)
            frame_categoria.grid_columnconfigure(2, weight=1)
            frame_categoria.grid_columnconfigure(3, weight=0)  # Separator 4 (n√£o redimension√°vel)
            frame_categoria.grid_columnconfigure(4, weight=1)
            frame_categoria.grid_rowconfigure(0, weight=1)

        # Configura√ß√£o para o frame_resultados
        self.frame_resultados.grid_columnconfigure(0, weight=1)  # Ajusta o frame principal para preencher horizontalmente
        self.frame_resultados.grid_rowconfigure("all", weight=0)  # Certifique-se de que os frames n√£o cres√ßam verticalmente

        # Mostrar o frame de resultados sobre o frame_corpo_bd
        self.frame_resultados.grid()
        self.frame_resultados.lift()
        print("Frame atual: Resultados")








    def alternar_frames(self, mostrar_resultados):
        if mostrar_resultados:
            self.frame_base_dados.grid_remove()  # Oculta o frame principal
            self.frame_resultados.grid()        # Mostra o frame de resultados
            print("Frame atual: Resultados")    # Adicionado aqui

        else:
            self.frame_resultados.grid_remove()  # Oculta o frame de resultados
            self.frame_base_dados.grid()        # Mostra o frame principal
            print("Frame atual: Base de Dados")  # Adicionado aqui
            
            
    def _copiar_texto(self, texto):
        """Permite copiar o texto ao selecion√°-lo."""
        self.root.clipboard_clear()
        self.root.clipboard_append(texto)
        self.root.update()  # Atualiza o clipboard

    def preencher_conteudo_tabela(self, frame, valores):
        """Preenche uma tabela selecion√°vel com os valores formatados em 3 colunas."""
        # Limpa o frame
        for widget in frame.winfo_children():
            widget.destroy()

        # Cria uma tabela (frame interno com grid layout)
        for index, (pt, en) in enumerate(valores):
            # Texto em PT
            label_pt = tk.Label(frame, text=pt, anchor="w", font=("Arial", 10), padx=5)
            label_pt.grid(row=index, column=0, sticky="w")
            label_pt.bind("<Button-1>", lambda e, texto=pt: self._copiar_texto(texto))

            # Separador vertical
            separator1 = ttk.Separator(frame, orient="vertical")
            separator1.grid(row=index, column=1, sticky="ns")

            # Texto em EN
            label_en = tk.Label(frame, text=en, anchor="w", font=("Arial", 10), padx=5)
            label_en.grid(row=index, column=2, sticky="w")
            label_en.bind("<Button-1>", lambda e, texto=en: self._copiar_texto(texto))

            # Separador vertical
            separator2 = ttk.Separator(frame, orient="vertical")
            separator2.grid(row=index, column=3, sticky="ns")

            # Texto em PT (EN)
            label_pt_en = tk.Label(frame, text=f"{pt} ({en})", anchor="w", font=("Arial", 10), padx=5)
            label_pt_en.grid(row=index, column=4, sticky="w")
            label_pt_en.bind("<Button-1>", lambda e, texto=f"{pt} ({en})": self._copiar_texto(texto))

        # Configura√ß√£o din√¢mica de layout
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_columnconfigure(2, weight=1)
        frame.grid_columnconfigure(4, weight=1)

    def copiar_texto(self, text_widget):
            """Fun√ß√£o para copiar o texto selecionado para a √°rea de transfer√™ncia."""
            try:
                selected_text = text_widget.get("sel.first", "sel.last")
                text_widget.master.clipboard_clear()
                text_widget.master.clipboard_append(selected_text)
            except tk.TclError:
                pass  # Nenhum texto selecionado, ignora
    
    def colar_texto(self, entry_widget):
        """Fun√ß√£o para colar o conte√∫do da √°rea de transfer√™ncia na caixa de entrada."""
        clipboard_text = entry_widget.master.clipboard_get()  # Acessa o clipboard atrav√©s da janela principal
        entry_widget.insert(tk.END, clipboard_text)

    
    
    def criar_menu_contexto(self, event, text_widget):
        """Cria o menu de contexto para as op√ß√µes dispon√≠veis, como 'Copiar' e 'Colar'."""
        menu = tk.Menu(text_widget.master, tearoff=0)

        # Adiciona a op√ß√£o de 'Copiar' se o widget for um 'Text' ou 'Entry'
        if isinstance(text_widget, (tk.Text, ttk.Entry)):
            menu.add_command(label="Copiar", command=lambda: self.copiar_texto(text_widget))  # Usando o m√©todo da classe

        # Adiciona a op√ß√£o de 'Colar' se o widget for um 'Entry'
        if isinstance(text_widget, (tk.Text, ttk.Entry)):
            menu.add_command(label="Colar", command=lambda: self.colar_texto(text_widget))  # Usando o m√©todo da classe para colar
        
        menu.post(event.x_root, event.y_root)



    def abrir_janela_busca(self, event=None):
        """Abre uma janela para o usu√°rio buscar texto na aplica√ß√£o."""
        print("Janela de busca acionada")
        janela_foco = self.root if not hasattr(self, 'janela_bd') or not self.janela_bd.winfo_exists() else self.janela_bd
        self.janela_busca = tk.Toplevel(janela_foco)
        self.janela_busca.title("Buscar")
        self.janela_busca.geometry("300x180")

        # Inicializar resultados e resultado atual
        self.resultados = []
        self.resultado_atual = -1

        # Fun√ß√£o para limpar destaques
        def limpar_destaques():
            if hasattr(self, 'resultados'):
                for widget, inicio, final in self.resultados:
                    if isinstance(widget, tk.Text):
                        widget.tag_remove("highlight", "1.0", "end")
                        widget.tag_remove("focus_highlight", "1.0", "end")
                    elif isinstance(widget, (tk.Label, ttk.Label)):
                        widget.config(background="SystemButtonFace")  # Cor padr√£o
                    elif isinstance(widget, ttk.Treeview):
                        widget.tag_configure("highlight", background="")
                        for item in widget.get_children():
                            widget.item(item, tags=())  # Remove tags

        # Fun√ß√£o para fechar a janela de busca
        def fechar_janela_busca():
            limpar_destaques()
            self.janela_busca.destroy()

        self.janela_busca.protocol("WM_DELETE_WINDOW", fechar_janela_busca)

        # Fun√ß√£o para realizar a pesquisa em tempo real
        def realizar_pesquisa(event=None):
            # Ignora KeyRelease do Enter
            if event and event.keysym == "Return":
                return

            termo = entrada_busca.get().strip().lower()  # Obter termo de busca
            limpar_destaques()  # Remove destaques anteriores

            if not termo:
                self.resultados = []
                self.resultado_atual = -1
                self.label_resultado.config(text="Insira um termo de busca")
                return

            # Buscar resultados
            self.resultados = self.coletar_resultados(termo, janela_foco)
            self.resultado_atual = 0 if self.resultados else -1

            if self.resultados:
                self.focar_resultado()
                self.label_resultado.config(text=f"1 / {len(self.resultados)}")
            else:
                self.label_resultado.config(text="Nenhum resultado encontrado.")

        # Fun√ß√£o para focar no pr√≥ximo resultado
        def proximo_resultado(event=None):
            if self.resultados:
                self.resultado_atual = (self.resultado_atual + 1) % len(self.resultados)
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

        # Fun√ß√£o para focar no resultado anterior
        def resultado_anterior(event=None):
            if self.resultados:
                self.resultado_atual = (self.resultado_atual - 1) % len(self.resultados)
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

        # Campo de entrada para busca
        entrada_busca = ttk.Entry(self.janela_busca)
        entrada_busca.pack(pady=10, padx=10)
        entrada_busca.focus_set()  # Define o foco inicial na caixa de entrada
        entrada_busca.bind("<KeyRelease>", realizar_pesquisa)  # Atualiza a busca dinamicamente
        entrada_busca.bind("<Return>", lambda event: proximo_resultado())  # Avan√ßa para o pr√≥ximo resultado ao pressionar Enter

        # Label para mostrar n√∫mero de resultados
        self.label_resultado = ttk.Label(self.janela_busca, text="Insira um termo de busca", anchor="center")
        self.label_resultado.pack(pady=5)

        # Frame para bot√µes de navega√ß√£o
        frame_botoes = ttk.Frame(self.janela_busca)
        frame_botoes.pack(pady=5)

        ttk.Button(frame_botoes, text="Anterior", command=resultado_anterior).grid(row=0, column=0, padx=5)
        ttk.Button(frame_botoes, text="Pr√≥ximo", command=proximo_resultado).grid(row=0, column=1, padx=5)

        

    def configurar_atalhos_busca(self, janela):
        """Configura os atalhos de busca para a janela especificada."""
        janela.bind("<Control-f>", self.abrir_janela_busca)
        janela.bind("<Control-l>", self.abrir_janela_busca)
        
        
    def coletar_resultados(self, termo, janela):
        """Coleta todos os resultados encontrados nos widgets de texto, labels e tabelas."""
        resultados = []
        termo = termo.lower().strip()

        def buscar_widgets(widget):
            if isinstance(widget, tk.Text):
                pos = "1.0"
                while True:
                    pos = widget.search(termo, pos, nocase=True, stopindex="end")
                    if not pos:
                        break
                    final = f"{pos}+{len(termo)}c"
                    resultados.append((widget, pos, final))
                    pos = final

            elif isinstance(widget, (tk.Label, ttk.Label)):
                texto = widget.cget("text").lower()
                if termo in texto:
                    resultados.append((widget, None, None))

            elif isinstance(widget, ttk.Treeview):
                for child in widget.get_children():
                    values = widget.item(child, "values")
                    for value in values:
                        if termo in str(value).lower():
                            resultados.append((widget, child, None))

            for child in widget.winfo_children():
                buscar_widgets(child)

        buscar_widgets(janela)
        return resultados




    
    def proximo_resultado(self, event=None):
        """Avan√ßa para o pr√≥ximo resultado ao pressionar 'Enter'."""
        if self.resultados:
            if event and event.type == "2":  # KeyPress
                if hasattr(self, "enter_pressed") and self.enter_pressed:
                    return
                self.enter_pressed = True
                self.resultado_atual = (self.resultado_atual + 1) % len(self.resultados)  # Navega√ß√£o circular
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

            elif event and event.type == "3":  # KeyRelease
                self.enter_pressed = False




    def buscar_texto(self, termo, janela):
        """Realiza a busca do texto em todos os widgets de texto, labels e tabelas na janela especificada."""
        termo = termo.lower().strip()  # Garante que a busca seja insens√≠vel a mai√∫sculas/min√∫sculas

        def buscar_widgets(widget):
            # Expande frames colapsados antes de buscar
            self.expandir_frames_ocultos(widget)

            # Busca em widgets do tipo Text
            if isinstance(widget, tk.Text):
                widget.tag_remove("highlight", "1.0", "end")  # Remove destaques antigos
                pos = "1.0"
                while True:
                    pos = widget.search(termo, pos, nocase=True, stopindex="end")
                    if not pos:
                        break
                    final = f"{pos}+{len(termo)}c"
                    widget.tag_add("highlight", pos, final)
                    widget.tag_config("highlight", background="yellow", foreground="black")
                    pos = final

            # Busca em widgets do tipo Label
            elif isinstance(widget, (tk.Label, ttk.Label)):
                texto = widget.cget("text").lower()
                if termo in texto:
                    widget.config(background="yellow")
                else:
                    widget.config(background="SystemButtonFace")  # Remove destaque se n√£o corresponder

            # Busca em tabelas do tipo Treeview
            elif isinstance(widget, ttk.Treeview):
                for child in widget.get_children():
                    values = widget.item(child, "values")  # Obt√©m os valores das c√©lulas da linha
                    for value in values:
                        if termo in str(value).lower():
                            widget.tag_configure("highlight", background="yellow")
                            widget.item(child, tags=("highlight",))
                        else:
                            widget.item(child, tags=())  # Remove tags se n√£o corresponder

            # Busca recursiva nos widgets filhos
            for child in widget.winfo_children():
                buscar_widgets(child)

        buscar_widgets(janela)


    def expandir_frames_ocultos(self, widget):
        """Expande frames colapsados para permitir a busca nos widgets internos."""
        parent = widget.master
        while parent is not None and parent is not self.root:
            if hasattr(parent, "is_collapsed") and parent.is_collapsed:
                parent.expand()  # Expande o frame, se estiver colapsado
            parent = parent.master
            
            
            
            
    def focar_resultado(self):
        """Foca no resultado atual, expande frames colapsados e ajusta a rolagem no Canvas."""
        print("M√©todo focar_resultado chamado.")

        # Verificar se h√° resultados para focar
        if not self.resultados or self.resultado_atual == -1:
            print("Nenhum resultado para focar ou resultado atual inv√°lido.")
            return

        print(f"Resultados encontrados: {len(self.resultados)}, Resultado atual: {self.resultado_atual}")

        # Remover destaque de resultados anteriores
        for widget, inicio, final in self.resultados:
            if isinstance(widget, tk.Text):
                widget.tag_remove("focus_highlight", "1.0", "end")
            elif isinstance(widget, (tk.Label, ttk.Label)):
                widget.config(background="SystemButtonFace")

        # Destacar o resultado atual
        widget, inicio, final = self.resultados[self.resultado_atual]
        print(f"Focando no widget: {widget}, In√≠cio: {inicio}, Final: {final}")

        if isinstance(widget, tk.Text):
            widget.tag_add("focus_highlight", inicio, final)
            widget.tag_config("focus_highlight", background="orange", foreground="black")
            widget.see(inicio)  # Garante que o texto esteja vis√≠vel
        elif isinstance(widget, (tk.Label, ttk.Label)):
            widget.config(background="orange")

        # Expandir frames colapsados, se necess√°rio
        parent = widget.master
        while parent is not None and parent is not self.root:
            if hasattr(parent, "grid_remove") and not parent.winfo_viewable():
                print(f"Expandindo frame colapsado: {parent}")
                parent.grid()  # Expande o frame
            parent = parent.master

        # Ajustar rolagem no Canvas para centralizar o widget
        canvas = None
        parent = widget.master
        while parent is not None:
            if isinstance(parent, tk.Canvas):  # Localiza o Canvas pai
                canvas = parent
                break
            parent = parent.master

        if canvas:
            canvas.update_idletasks()  # Garante que o layout do Canvas est√° atualizado

            # Recalcular dimens√µes do Canvas e widget dinamicamente
            canvas_height = canvas.winfo_height()
            canvas_total_height = canvas.bbox("all")[3]
            widget_y_in_canvas = canvas.canvasy(widget.winfo_rooty() - canvas.winfo_rooty())
            widget_height = widget.winfo_height()

            # Calcular bordas do widget
            widget_top = widget_y_in_canvas
            widget_bottom = widget_y_in_canvas + widget_height
            canvas_top = canvas.canvasy(0)
            canvas_bottom = canvas_top + canvas_height

            print(f"Canvas Altura: {canvas_height}, Canvas Total Altura: {canvas_total_height}")
            print(f"Widget Topo: {widget_top}, Widget Fundo: {widget_bottom}, Canvas Topo: {canvas_top}, Canvas Fundo: {canvas_bottom}")

            # Verificar visibilidade real do widget
            if widget_top < canvas_top or widget_bottom > canvas_bottom:
                # Centralizar o widget no Canvas
                widget_center = widget_top + (widget_height / 2)
                scroll_position = max(0, min(1, (widget_center - (canvas_height / 2)) / canvas_total_height))
                print(f"Scroll Position Calculada: {scroll_position}")
                canvas.yview_moveto(scroll_position)
            else:
                print("Widget est√° completamente vis√≠vel no Canvas, rolagem n√£o necess√°ria.")
        else:
            print("Nenhum Canvas encontrado para ajustar a rolagem.")

        # Sincronizar mudan√ßas no layout
        self.root.update_idletasks()  # Garante que o layout geral est√° est√°vel


    def selecionar_coluna_arrastando(self, event):
        """ Seleciona todas as linhas da coluna ao arrastar o rato """
        item_selecionado = self.tree.identify_row(event.y)  # Obt√©m a linha onde foi clicado
        coluna_selecionada = self.tree.identify_column(event.x)  # Obt√©m a coluna onde foi clicado

        if not item_selecionado or not coluna_selecionada:
            return

        # Obt√©m o √≠ndice num√©rico da coluna (ex: #1, #2 -> 1, 2)
        coluna_index = int(coluna_selecionada.replace("#", "")) - 1

        # Seleciona todas as c√©lulas da mesma coluna
        for item in self.tree.get_children():
            valores = self.tree.item(item, "values")
            if valores:
                self.tree.selection_add(item)  # Adiciona a linha √† sele√ß√£o

    def configurar_selecao_arrastavel(self):
        """ Configura o evento de clique e arrasto na tabela """
        self.tree.bind("<B1-Motion>", self.selecionar_coluna_arrastando)








































    def criar_abas(self):
        """ Cria as abas principais do notebook """
        self.notebook = ttk.Notebook(self.root)
        self.notebook.grid(row=0, column=0, sticky="nsew")

        # Criar abas
        self.aba_evento_semanal = ttk.Frame(self.notebook)
        self.aba_missoes = ttk.Frame(self.notebook)
        self.aba_eventos_modo_livre = ttk.Frame(self.notebook)

        # Configura√ß√£o das abas
        self.aba_evento_semanal.grid_columnconfigure(0, weight=1)
        self.aba_evento_semanal.grid_rowconfigure(0, weight=0)  # Linha para a imagem no topo
        self.aba_evento_semanal.grid_rowconfigure(1, weight=1)  # Linhas de caixas de texto ocupam o espa√ßo restante
        self.aba_evento_semanal.grid_rowconfigure(2, weight=0)  # Fixa o bot√£o no final
        
    def criar_abas_notebook(self):
        """ Cria e adiciona as abas ao notebook """
        self.notebook.add(self.aba_evento_semanal, text="Evento Semanal")
        self.notebook.add(self.aba_missoes, text="Miss√µes")
        self.notebook.add(self.aba_eventos_modo_livre, text="Eventos Modo Livre")
        self.carregar_imagem_topo()  # Chama a fun√ß√£o para carregar a imagem no topo


        # Configura√ß√µes de "Dispon√≠vel Brevemente" nas outras abas
        self.label_missoes = ttk.Label(self.aba_missoes, text="Dispon√≠vel Brevemente", font=("TkDefaultFont", 10, "bold"))
        self.label_missoes.grid(row=0, column=0, pady=20, padx=20, sticky="n")
        self.label_eventos = ttk.Label(self.aba_eventos_modo_livre, text="Dispon√≠vel Brevemente", font=("TkDefaultFont", 10, "bold"))
        self.label_eventos.grid(row=0, column=0, pady=20, padx=20, sticky="n")

    def configurar_scroll(self):
        """Configura√ß√£o da rolagem na aba de eventos semanais."""

        # Criar o Canvas e a barra de rolagem
        self.tela = tk.Canvas(self.aba_evento_semanal)
        self.barra_deslocamento = ttk.Scrollbar(self.aba_evento_semanal, orient="vertical", command=self.tela.yview)

        # Criar o frame dentro do Canvas (N√ÉO ser√° expandido infinitamente)
        self.frame_deslocavel = ttk.Frame(self.tela)

        # Criar um frame real dentro do frame_deslocavel que conter√° os widgets
        self.frame_conteudo = ttk.Frame(self.frame_deslocavel)
        self.frame_conteudo.grid(row=0, column=0, sticky="nsew")  # Mant√©m o layout fixo

        # Criar a janela no Canvas com um ID fixo
        self.window_id = self.tela.create_window((0, 0), window=self.frame_deslocavel, anchor="nw")

        # Configurar a barra de rolagem
        self.tela.configure(yscrollcommand=self.barra_deslocamento.set)

        self.tela.grid(row=1, column=0, sticky="nsew")
        self.barra_deslocamento.grid(row=1, column=1, sticky="ns")

        # Ajustar a largura do frame dentro do Canvas
        def _ajustar_largura(event=None):
            largura_canvas = self.tela.winfo_width()
            nova_largura = max(largura_canvas, 300)  # Define uma largura m√≠nima
            self.tela.itemconfig(self.window_id, width=nova_largura)

        self.tela.bind("<Configure>", _ajustar_largura)

        # Atualiza a √°rea de rolagem e impede scroll infinito
        def atualizar_scroll():
            self.tela.update_idletasks()  # Garante que o layout foi atualizado
            bbox = self.tela.bbox("all")

            if bbox:
                self.tela.configure(scrollregion=bbox)  # Atualiza a regi√£o de rolagem

        # Chamar a fun√ß√£o sempre que a tela for redimensionada
        self.root.bind("<Configure>", lambda e: atualizar_scroll())


        # Ajusta a rolagem do mouse corretamente no Windows (delta // 120)
        def _no_roda_rato(event):
            self.tela.yview_scroll(-1 * (event.delta // 120), "units")

        self.tela.bind("<Enter>", lambda e: self.tela.bind_all("<MouseWheel>", _no_roda_rato))
        self.tela.bind("<Leave>", lambda e: self.tela.unbind_all("<MouseWheel>"))



    def adicionar_scroll_horizontal(self, widget):
        """Adiciona uma scrollbar horizontal ao widget especificado."""
        frame = widget.master  # Obt√©m o frame pai do widget
        scrollbar_x = ttk.Scrollbar(frame, orient="horizontal", command=widget.xview)
        widget.configure(xscrollcommand=scrollbar_x.set)

        # Adiciona a scrollbar corretamente usando grid, se o widget for um Text
        if isinstance(widget, tk.Text):
            widget.configure(wrap="none")

        # Use grid() em vez de pack() para evitar conflitos
        scrollbar_x.grid(row=widget.grid_info()["row"] + 1, column=widget.grid_info()["column"], sticky="ew")






    def _no_roda_rato(self, event):
        """Fun√ß√£o para rolar a tela com o uso do mouse."""
        self.tela.yview_scroll(-1 * (event.delta // 120), "units")
        
    
    def adjust_height(self, event, widget):
        """Ajusta a altura da caixa de texto para se ajustar ao conte√∫do"""
        # Verifica se o widget √© uma caixa de texto (Text)
        if isinstance(widget, tk.Text):
            # Conta o n√∫mero de linhas na caixa de texto
            num_lines = int(widget.index('end-1c').split('.')[0])  # 'end-1c' para evitar o marcador de fim
            
            # Define uma altura m√≠nima e m√°xima para a caixa de texto
            min_height = 1
            max_height = 200  # Limite de linhas vis√≠veis (pode ser ajustado conforme necess√°rio)
            
            # Ajusta a altura baseada no n√∫mero de linhas
            new_height = min(max(min_height, num_lines), max_height)
            
            # Atualiza a altura da caixa de texto
            widget.config(height=new_height)
            
    def adicionar_linha(self, event):
        """Adiciona uma √∫nica linha ao pressionar Shift + Enter."""
        widget = event.widget
        if isinstance(widget, tk.Text):
            widget.insert("insert", "\n")  # Adiciona uma nova linha na posi√ß√£o do cursor
            return "break"  # Evita o comportamento padr√£o do evento

    
    def proximo_campo_sem_nova_linha(self, event):
        """Move o foco para o pr√≥ximo campo ao pressionar Enter sem adicionar nova linha"""
        current = event.widget
        if current in self.caixas_texto:
            next_index = self.caixas_texto.index(current) + 1
            if next_index < len(self.caixas_texto):
                self.caixas_texto[next_index].focus()
        return "break"
    
    def shift_return_handler(self, event):
        self.adicionar_linha(event)
        self.scroll_para_cursor(event)
        return "break"

    def proximo_campo(self, event):
        """Move para a pr√≥xima caixa quando Enter √© pressionado"""
        current = event.widget
        next_index = self.caixas_texto.index(current) + 1
        if next_index < len(self.caixas_texto):
            self.caixas_texto[next_index].focus_set()
        return "break"
    def carregar_imagem_topo(self):
        """ Carregar e exibir a imagem no topo da aba 'Evento Semanal' """
        url_imagem = "https://gdm-assets.b-cdn.net/images/ncavvykf/gfinityesports/e2b192e39a5c1e14362a5750d4271e0c630bc556-1200x630.jpg"
        
        # Baixar a imagem da URL
        resposta = requests.get(url_imagem)
        imagem = Image.open(BytesIO(resposta.content))
        imagem = imagem.resize((600, 200), Image.Resampling.LANCZOS)  # Redimensionar a imagem para ajustar na largura da janela

        # Converter para formato que o Tkinter consegue usar
        imagem_tk = ImageTk.PhotoImage(imagem)

        # Criar label para exibir a imagem
        self.imagem_label = tk.Label(self.aba_evento_semanal, image=imagem_tk)
        self.imagem_label.image = imagem_tk  # Manter uma refer√™ncia da imagem
        self.imagem_label.grid(row=0, column=0, columnspan=2, sticky="nsew")


    def criar_caixas_texto(self):
        """ Cria√ß√£o das caixas de texto din√¢micas dentro da aba de eventos semanais """
        self.caixas_texto = []  # Lista para armazenar as caixas de texto

        # Configurar o frame para expandir corretamente
        self.frame_deslocavel.grid_columnconfigure(0, weight=1)  # Permite que o conte√∫do expanda horizontalmente

        # Fun√ß√£o para ajustar largura das caixas de texto
        def _ajustar_largura_caixas(event=None):
            largura_frame = self.frame_deslocavel.winfo_width()
            for caixa in self.caixas_texto:
                caixa.configure(width=int(largura_frame / 10))  # Ajusta a largura conforme o frame

        # Atualiza a largura sempre que o frame mudar de tamanho
        self.frame_deslocavel.bind("<Configure>", _ajustar_largura_caixas)
        
        for entrada in self.caixas_texto:
            self.associar_botao_filtro(entrada)
            self.aplicar_filtros(None, entrada)  # Aplica os filtros ao iniciar










        #####################################################################################################################################################
        ##################################################### CRIA√áAO DA TEXTBOXES E CONTEUDO ###############################################################
        #####################################################################################################################################################
        
        #URL da imagem ou v√≠deo de Capa
        #Titulo
        label_url = ttk.Label(
            self.frame_deslocavel, 
            text="URL da imagem ou v√≠deo de Capa:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_url.grid(row=0, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_url = ttk.Label(
            self.frame_deslocavel, 
            text="Coloca o link da imagem ou v√≠deo que ir√° servir de capa para os eventos desta semana.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_url.grid(row=1, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto
        entrada_url = ttk.Entry(self.frame_deslocavel)
        entrada_url.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        
        entrada_url.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        entrada_url.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        entrada_url.bind('<Return>', self.proximo_campo_sem_nova_linha)  # Move para o pr√≥ximo campo ao pressionar Enter
        entrada_url.bind("<KeyRelease>", self.scroll_para_cursor)
        entrada_url.bind("<Tab>", self.proximo_campo_com_tab)  # Garante que Tab mova para o pr√≥ximo campo

        self.caixas_texto.append(entrada_url)  # Adiciona a entrada √† lista de caixas


        
        
        
        
        #Conte√∫do Novo###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_conteudo_novo = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Conte√∫do Novo",
            command=lambda: alternar_visibilidade(conteudo_novo_frame, botao_expandir_conteudo_novo)
        )
        botao_expandir_conteudo_novo.grid(row=100, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Conte√∫do Novo"
        conteudo_novo_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        conteudo_novo_frame.grid(row=101, column=0, sticky="ew", padx=10, pady=10)
        conteudo_novo_frame.grid_remove() 
        conteudo_novo_frame.bind("<Configure>", lambda e: conteudo_novo_frame.config(width=self.frame_deslocavel.winfo_width()))


        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de B√≥nus de Atividade."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Conte√∫do Novo")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Conte√∫do Novo")

        # Widgets dentro do conteudo_novo_frame
        # Label T√≠tulo
        label_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Conte√∫do Novo",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_conteudo_novo.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))
        
        
        # Titulo Conte√∫do Novo
        label_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Conte√∫do Novo:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_conteudo_novo.grid(row=4, column=0, sticky="w", padx=10, pady=(0, 5))
        
        # Descri√ß√£o Conteudo Novo
        descricao_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Introduz o conte√∫do novo na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_conteudo_novo.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Conte√∫do Novo
        self.entrada_conteudo_novo = tk.Text(conteudo_novo_frame, height=1, wrap=tk.WORD)
        self.entrada_conteudo_novo.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_conteudo_novo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_conteudo_novo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_conteudo_novo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_conteudo_novo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_conteudo_novo))
        self.caixas_texto.append(self.entrada_conteudo_novo)
        self.associar_botao_filtro(self.entrada_conteudo_novo)  # Passar o widget diretamente

        

        # Imagem do Conteudo Novo
        label_imagem_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Imagem do Conte√∫do Novo:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_conteudo_novo.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Mete o link da imagem do conte√∫do novo",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_conteudo_novo.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_conteudo_novo = tk.Text(conteudo_novo_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_conteudo_novo.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_conteudo_novo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_conteudo_novo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_conteudo_novo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_conteudo_novo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_conteudo_novo))
        self.caixas_texto.append(self.entrada_imagem_conteudo_novo)
        
        
        
        
        #Novos Veiculos Disponiveis###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_novos_veiculos = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Novos Veiculos Disponiveis",
            command=lambda: alternar_visibilidade(novos_veiculos_frame, botao_expandir_novos_veiculos)
        )
        botao_expandir_novos_veiculos.grid(row=102, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Conte√∫do Novo"
        novos_veiculos_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        novos_veiculos_frame.grid(row=103, column=0, sticky="ew", padx=10, pady=10)
        novos_veiculos_frame.grid_remove() 
        novos_veiculos_frame.bind("<Configure>", lambda e: novos_veiculos_frame.config(width=self.frame_deslocavel.winfo_width()))

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Novos Veiculos Disponiveis."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Novos Veiculos Disponiveis")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Novos Veiculos Disponiveis")

        # Widgets dentro do Novos Veiculos Disponiveis
        # Label T√≠tulo
        label_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Novos Veiculos Disponiveis",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_novos_veiculos.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))


        # Titulo Novos Veiculos Disponiveis
        label_descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Nome dos Novos Veiculos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_descricao_novos_veiculos.grid(row=1, column=0, sticky="w", padx=10, pady=(0, 5))    
        

        
        
        # Descri√ß√£o Novos Veiculos Disponiveis
        descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Introduz os Novos Veiculos Disponiveis na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_novos_veiculos.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Novos Veiculos Disponiveis
        self.entrada_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_novos_veiculos.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_novos_veiculos))

        self.caixas_texto.append(self.entrada_novos_veiculos)
        self.associar_botao_filtro(self.entrada_novos_veiculos)

        
        
        # condi√ßao de desbloqueio de compra dos Novos Veiculos Disponiveis
        label_desbloqueio_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Condi√ß√£o do Desbloqueio dos Novos Ve√≠culos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_desbloqueio_novos_veiculos.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_desbloqueio_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Escreve a condi√ß√£o necesss√°ria para desbloquear a compra dos Novos Ve√≠culos Disponiveis na linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_desbloqueio_novos_veiculos.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_desbloqueio_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_desbloqueio_novos_veiculos.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_desbloqueio_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_desbloqueio_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_desbloqueio_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_desbloqueio_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_desbloqueio_novos_veiculos))
        self.caixas_texto.append(self.entrada_desbloqueio_novos_veiculos)
        self.associar_botao_filtro(self.entrada_desbloqueio_novos_veiculos)

        
        
        # condi√ßao de desbloqueio de pre√ßo de f√°brica dos Novos Veiculos Disponiveis
        label_precofabrica_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Condi√ß√£o do Desbloqueio do Pre√ßo de F√°brica dos Novos Ve√≠culos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_precofabrica_novos_veiculos.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_precofabrica_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Escreve a condi√ß√£o necesss√°ria para desbloquear a o pre√ßo de f√°brica dos Novos Ve√≠culos Disponiveis na linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_precofabrica_novos_veiculos.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_precofabrica_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_precofabrica_novos_veiculos.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_precofabrica_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_precofabrica_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_precofabrica_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_precofabrica_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_precofabrica_novos_veiculos))
        self.caixas_texto.append(self.entrada_precofabrica_novos_veiculos)
        self.associar_botao_filtro(self.entrada_precofabrica_novos_veiculos)
        

        # Imagem do Novos Veiculos Disponiveis
        label_imagem_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Imagem dos Novos Veiculos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_novos_veiculos.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Mete o link da imagem dos Novos Veiculos Disponiveis na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_novos_veiculos.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_novos_veiculos.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_novos_veiculos))
        self.caixas_texto.append(self.entrada_imagem_novos_veiculos)
        
        
        
        
        #Pr√©mios de Login ###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_premios_login = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Pr√©mios de Login",
            command=lambda: alternar_visibilidade(premios_login_frame, botao_expandir_premios_login)
        )
        botao_expandir_premios_login.grid(row=104, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Pr√©mios de Login"
        premios_login_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        premios_login_frame.grid(row=105, column=0, sticky="ew", padx=10, pady=10)
        premios_login_frame.grid_remove() 

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Pr√©mios de Login."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Pr√©mios de Login")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Pr√©mios de Login")

        # Widgets dentro do Pr√©mios de Login
        # Label T√≠tulo
        label_premios_login = ttk.Label(
            premios_login_frame,
            text="Pr√©mios de Login",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_premios_login.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))


        # Titulo Pr√©mios de Login
        label_premios_login = ttk.Label(
            premios_login_frame,
            text="Pr√©mios de Login:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_premios_login.grid(row=1, column=0, sticky="w", pady=5, padx=10)    
    
        # Descri√ß√£o Pr√©mios de Login
        descricao_premios_login = ttk.Label(
            premios_login_frame,
            text="Introduz os Pr√©mios de Login na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_premios_login.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Pr√©mios de Login
        self.entrada_premios_login = tk.Text(premios_login_frame, height=1, wrap=tk.WORD)
        self.entrada_premios_login.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_premios_login.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_premios_login.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_premios_login.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_premios_login.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_premios_login))
        self.caixas_texto.append(self.entrada_premios_login)
        self.associar_botao_filtro(self.entrada_premios_login)
        
        # Imagem do Pr√©mios de Login
        label_imagem_premios_login = ttk.Label(
            premios_login_frame,
            text="Imagem dos Pr√©mios de Login:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_premios_login.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_premios_login = ttk.Label(
            premios_login_frame,
            text="Mete o link da imagem dos Pr√©mios de Login na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_premios_login.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_premios_login = tk.Text(premios_login_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_premios_login.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_premios_login.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_premios_login.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_premios_login.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_premios_login.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_premios_login))
        self.caixas_texto.append(self.entrada_imagem_premios_login)
        
        
        
        
        # Retorno de Conte√∫do ###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_ret_conteudo = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Retorno de Conte√∫do",
            command=lambda: alternar_visibilidade(ret_conteudo_frame, botao_expandir_ret_conteudo)
        )
        botao_expandir_ret_conteudo.grid(row=106, column=0, sticky="w", padx=10, pady=(20, 5))

        # Frame expans√≠vel (LabelFrame) para "Retorno de Conte√∫do"
        ret_conteudo_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        ret_conteudo_frame.grid(row=107, column=0, sticky="ew", padx=10, pady=10)
        ret_conteudo_frame.grid_remove()

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Retorno de Conte√∫do."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Retorno de Conte√∫do")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Retorno de Conte√∫do")

        # Widgets dentro do Retorno de Conte√∫do
        # Label T√≠tulo
        label_ret_conteudo = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Conte√∫do",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_ret_conteudo.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))

        # Retorno de Miss√µes
        label_ret_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_ret_missoes.grid(row=1, column=0, sticky="w", pady=5, padx=10)

        descricao_ret_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as Miss√µes que retornaram.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_ret_missoes.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_ret_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_ret_missoes.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_ret_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_ret_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_ret_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_ret_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_ret_missoes))
        self.caixas_texto.append(self.entrada_ret_missoes)
        self.associar_botao_filtro(self.entrada_ret_missoes)


        # Recompensa de Miss√µes
        label_recomp_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Recompensa de Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_recomp_missoes.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_recomp_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as recompensas para cada miss√£o na sua linha respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recomp_missoes.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_recomp_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_recomp_missoes.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recomp_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recomp_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recomp_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recomp_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recomp_missoes))
        self.caixas_texto.append(self.entrada_recomp_missoes)
        self.associar_botao_filtro(self.entrada_recomp_missoes)
        
        
        # Imagens das Miss√µes
        label_img_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Imagens das Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_img_missoes.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_img_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens para cada miss√£o respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_img_missoes.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_img_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_img_missoes.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_img_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_img_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_img_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_img_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_img_missoes))
        self.caixas_texto.append(self.entrada_img_missoes)

        # Retorno de Eventos de Modo Livre
        label_ret_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_ret_eventos.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_ret_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os Eventos de Modo Livre que retornaram.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_ret_eventos.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_ret_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_ret_eventos.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_ret_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_ret_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_ret_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_ret_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_ret_eventos))
        self.caixas_texto.append(self.entrada_ret_eventos)
        self.associar_botao_filtro(self.entrada_ret_eventos)
        
        
        # Recompensa de Eventos de Modo Livre
        label_recomp_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Recompensa de Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_recomp_eventos.grid(row=13, column=0, sticky="w", pady=5, padx=10)

        descricao_recomp_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as recompensas para cada Evento de Modo Livre na sua linha respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recomp_eventos.grid(row=14, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_recomp_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_recomp_eventos.grid(row=15, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recomp_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recomp_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recomp_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recomp_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recomp_eventos))
        self.caixas_texto.append(self.entrada_recomp_eventos)
        self.associar_botao_filtro(self.entrada_recomp_eventos)

        # Imagens dos Eventos de Modo Livre
        label_img_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Imagens dos Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_img_eventos.grid(row=16, column=0, sticky="w", pady=5, padx=10)

        descricao_img_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens para cada Evento de Modo Livre respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_img_eventos.grid(row=17, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_img_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_img_eventos.grid(row=18, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_img_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_img_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_img_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_img_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_img_eventos))
        self.caixas_texto.append(self.entrada_img_eventos)

        # Banner do Retorno de Conte√∫do
        label_banner = ttk.Label(
            ret_conteudo_frame,
            text="Banner do Retorno de Conte√∫do:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkblue"
        )
        label_banner.grid(row=19, column=0, sticky="w", pady=5, padx=10)

        descricao_banner = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens que fazem o banner. Podes meter todas seguidas separadas por uma v√≠rgula \",\" ou cada uma na sua linha.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_banner.grid(row=20, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_banner = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_banner.grid(row=21, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_banner.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_banner.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_banner.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_banner.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_banner))
        self.caixas_texto.append(self.entrada_banner)

        
        
        
    


        
        #"Desafio Semanal###################################################################
        label_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Desafio Semanal", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_desafio_semanal.grid(row=200, column=0, sticky="w", padx=10, pady=(20, 10))
        
        #Objectivo do Evento Semanal#######
        #Titulo
        label_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Objectivo do Evento Semanal:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_desafio_semanal.grid(row=201, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a descri√ß√£o do objectivo semanal.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_desafio_semanal.grid(row=202, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto
        self.entrada_desafio_semanal = ttk.Entry(self.frame_deslocavel)
        self.entrada_desafio_semanal.grid(row=203, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_desafio_semanal.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_desafio_semanal.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_desafio_semanal)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_desafio_semanal)

        
        #Recompensa Objectivo Semanal#######
        #Titulo
        label_recompensa_objectivo_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Recompensa:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_recompensa_objectivo_semanal.grid(row=204, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_recompensa_objectivo_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o valor da recompensa", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_recompensa_objectivo_semanal.grid(row=205, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto   

        self.entrada_recompensa_objectivo_semanal = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_recompensa_objectivo_semanal.insert(tk.END, "GTA$ 100.000")
        self.entrada_recompensa_objectivo_semanal.grid(row=206, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_objectivo_semanal.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event), event.widget.tag_add("sel", "1.0", "end-1c")))
        self.entrada_recompensa_objectivo_semanal.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_objectivo_semanal.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_objectivo_semanal.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_objectivo_semanal))
        self.entrada_recompensa_objectivo_semanal.bind("<Button-1>", self.scroll_para_cursor)  # Mouse click
        self.entrada_recompensa_objectivo_semanal.bind("<Up>", self.scroll_para_cursor)        # Up arrow
        self.entrada_recompensa_objectivo_semanal.bind("<Down>", self.scroll_para_cursor)      # Down arrow
        
        self.caixas_texto.append(self.entrada_recompensa_objectivo_semanal)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_recompensa_objectivo_semanal)



        #B√≥nus de Atividade###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar B√≥nus de Atividade",
            command=lambda: alternar_visibilidade(bonus_atividade_frame, botao_expandir)
        )
        botao_expandir.grid(row=300, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "B√≥nus de Atividade"
        bonus_atividade_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        bonus_atividade_frame.grid(row=301, column=0, sticky="ew", padx=10, pady=10)
        bonus_atividade_frame.grid_remove() 

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de B√≥nus de Atividade."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar B√≥nus de Atividade")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover B√≥nus de Atividade")

        # Widgets dentro do bonus_atividade_frame
        # Label T√≠tulo
        label_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="B√≥nus de Atividade",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_bonus_atividade.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))

        # Label Objectivo
        label_objetivo_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Objectivo do B√≥nus de Atividade:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_objetivo_bonus.grid(row=1, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Introduz a descri√ß√£o do objectivo semanal.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_bonus_atividade.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_bonus_atividade.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_bonus_atividade)
        self.associar_botao_filtro(self.entrada_bonus_atividade)
        
        # Label Recompensa
        label_recompensa_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Recompensa do Bonus:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_recompensa_bonus_atividade.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o Recompensa
        descricao_recompensa_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Introduz o valor da recompensa do b√≥nus de atividade",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recompensa_bonus_atividade.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Recompensa
        self.entrada_recompensa_bonus_atividade = tk.Text(bonus_atividade_frame, height=1, wrap=tk.WORD)
        self.entrada_recompensa_bonus_atividade.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recompensa_bonus_atividade.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_bonus_atividade.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_bonus_atividade.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_bonus_atividade))
        self.caixas_texto.append(self.entrada_recompensa_bonus_atividade)
        self.associar_botao_filtro(self.entrada_recompensa_bonus_atividade)

        # Timeframe
        label_timeframe_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Timeframe da Oferta:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_timeframe_bonus.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_timeframe_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Dentro de quanto tempo √© que ser√° entregue o b√≥nus?",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_timeframe_bonus_atividade.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_timeframe_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_timeframe_bonus_atividade.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_timeframe_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_timeframe_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_timeframe_bonus_atividade)

        # Imagem do B√≥nus de Atividade
        label_imagem_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Imagem do B√≥nus de Atividade:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_bonus.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_imagem_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Mete o link da imagem do b√≥nus de atividade",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_imagem_bonus.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_imagem_bonus_atividade.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_imagem_bonus_atividade)

        
        
        # Atividades de B√≥nus GTA$ e RP ###################################################################
        
        label_atividade_bonus_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Atividades de B√≥nus GTA$ e RP", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_atividade_bonus_gta_rp.grid(row=400, column=0, sticky="ew", padx=10, pady=(20, 10))              


        # Nome das Atividades #######
        # Titulo
        label_nome_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Nome das Atividades de B√≥nus GTA$ e RP:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_atividades_gta_rp.grid(row=401, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a descri√ß√£o do objectivo das atividades de b√≥nus GTA$ e RP.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_atividades_gta_rp.grid(row=402, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_atividades_gta_rp = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_nome_atividades_gta_rp.grid(row=403, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_atividades_gta_rp.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_nome_atividades_gta_rp.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_nome_atividades_gta_rp.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_nome_atividades_gta_rp.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_nome_atividades_gta_rp))
        
        self.caixas_texto.append(self.entrada_nome_atividades_gta_rp)
        self.associar_botao_filtro(self.entrada_nome_atividades_gta_rp)

        # Imagem das Atividades de B√≥nus GTA$ e RP #######


        # Titulo
        label_imagem_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem das Atividades de B√≥nus GTA$ e RP:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_atividades_gta_rp.grid(row=404, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Mete o url da imagem de cada atividade na linha correspondente", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_atividades_gta_rp.grid(row=405, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_atividades_gta_rp = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_imagem_atividades_gta_rp.grid(row=406, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_atividades_gta_rp.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_imagem_atividades_gta_rp.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_atividades_gta_rp.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_atividades_gta_rp.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_atividades_gta_rp))

        self.caixas_texto.append(self.entrada_imagem_atividades_gta_rp)





    # Descontos ###################################################################
        
        label_atividade_bonus_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Descontos", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_atividade_bonus_gta_rp.grid(row=500, column=0, sticky="ew", padx=10, pady=(20, 10))      


        # Imagem dos Descontos #######
        # Titulo
        label_imagem_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem dos Descontos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_descontos.grid(row=501, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto dos descontos, se houver alguma", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_descontos.grid(row=21, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_descontos = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_descontos.grid(row=502, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_descontos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_descontos.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_imagem_descontos)
        
        self.caixas_texto.append(self.entrada_nome_atividades_gta_rp)
        

        # Descontos
        # Titulo
        label_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Descontos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_descontos.grid(row=503, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Lista dos descontos", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_descontos.grid(row=504, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_descontos = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_descontos.grid(row=505, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_descontos.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_descontos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_descontos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_descontos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_descontos))

        self.caixas_texto.append(self.entrada_descontos)
        self.associar_botao_filtro(self.entrada_descontos)


        
        # Gun Van ###################################################################

        # T√≠tulo da Van de Arsenal
        label_gunvan = ttk.Label(
            self.frame_deslocavel, 
            text="Van de Arsenal (Gun Van)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_gunvan.grid(row=600, column=0, sticky="ew", padx=10, pady=(20, 10))

        # T√≠tulo
        label_lista_armas = ttk.Label(
            self.frame_deslocavel, 
            text="Lista de Armas:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_lista_armas.grid(row=601, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_gunvan = ttk.Label(
            self.frame_deslocavel, 
            text="Mete aqui a lista de armas da Gun Van", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_gunvan.grid(row=602, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_gunvan = tk.Text(self.frame_deslocavel, height=5, wrap=tk.WORD)
        self.entrada_gunvan.grid(row=603, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_gunvan.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_gunvan.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_gunvan.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_gunvan.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_gunvan))

        # Adiciona a entrada_gunvan na lista
        self.caixas_texto.append(self.entrada_gunvan)
        self.associar_botao_filtro(self.entrada_gunvan)

        # Bot√£o de formata√ß√£o (logo abaixo da descri√ß√£o)
        btn_formatar = ttk.Button(self.frame_deslocavel, text="Formatar", command=lambda: self.abrir_janela_formatar())
        btn_formatar.grid(row=602, column=1, padx=10, pady=5, sticky="w")


        # === Fun√ß√£o para abrir a Janela de Formata√ß√£o === #
        def abrir_janela_formatar(self):
            """Cria a janela de formata√ß√£o sem bloquear os outros widgets"""
            janela_formatar = Toplevel(self.frame_deslocavel)
            janela_formatar.title("Formatar Lista de Armas")
            janela_formatar.geometry("600x400")

            # Caixa de texto para inserir/modificar o texto original (EDIT√ÅVEL)
            ttk.Label(janela_formatar, text="Texto Original:").pack(anchor="w", padx=10, pady=(10, 0))
            entrada_original = tk.Text(janela_formatar, height=5, wrap="word")
            entrada_original.pack(padx=10, pady=5, fill="both", expand=True)
            entrada_original.insert("1.0", self.entrada_gunvan.get("1.0", tk.END).strip())

            # Caixa de sa√≠da para exibir o texto formatado (N√ÉO EDIT√ÅVEL)
            ttk.Label(janela_formatar, text="Texto Formatado:").pack(anchor="w", padx=10, pady=(10, 0))

            # Frame para conter a caixa de texto e a scrollbar horizontal
            frame_saida = ttk.Frame(janela_formatar)
            frame_saida.pack(fill="both", expand=True, padx=10, pady=5)

            # Caixa de texto formatada com barra de rolagem horizontal
            saida_formatada = tk.Text(frame_saida, height=10, wrap="none", state="disabled")
            saida_formatada.pack(side="left", fill="both", expand=True)

            # Adiciona a barra de rolagem horizontal
            scrollbar_x = ttk.Scrollbar(frame_saida, orient="horizontal", command=saida_formatada.xview)
            scrollbar_x.pack(side="bottom", fill="x")
            saida_formatada.configure(xscrollcommand=scrollbar_x.set)

            # === Fun√ß√£o para formatar o texto === #
            def formatar_texto():
                texto_original = entrada_original.get("1.0", tk.END).strip()

                if texto_original:
                    # Divide os itens pelo separador " | " (com espa√ßo antes e depois)
                    itens_formatados = [item.strip() for item in texto_original.split(" | ")]

                    # Junta os itens com uma quebra de linha
                    texto_formatado = "\n".join(itens_formatados)

                    saida_formatada.config(state="normal")
                    saida_formatada.delete("1.0", tk.END)
                    saida_formatada.insert(tk.END, texto_formatado)
                    saida_formatada.config(state="disabled")

                    # Ajusta a largura da caixa de texto dinamicamente
                    max_largura = max(len(linha) for linha in itens_formatados)  # Maior linha
                    saida_formatada.config(width=max_largura)

            # === Bot√£o "Formatar" === #
            btn_formatar = ttk.Button(janela_formatar, text="Formatar", command=formatar_texto)
            btn_formatar.pack(pady=5)

            # === Bot√£o "Copiar Texto" === #
            def copiar_texto():
                texto_formatado = saida_formatada.get("1.0", tk.END).strip()
                janela_formatar.clipboard_clear()
                janela_formatar.clipboard_append(texto_formatado)
                janela_formatar.update()

            btn_copiar = ttk.Button(janela_formatar, text="Copiar Texto", command=copiar_texto)
            btn_copiar.pack(pady=5)


        # Adiciona a fun√ß√£o √† classe
        self.abrir_janela_formatar = abrir_janela_formatar.__get__(self)

    
    
    # Roubos do Ferro-Velho (Salvage Yard Robberies) ###################################################################
        
        label_salvageyard = ttk.Label(
            self.frame_deslocavel, 
            text="Roubos do Ferro-Velho (Salvage Yard Robberies)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_salvageyard.grid(row=700, column=0, sticky="ew", padx=10, pady=(20, 10))      


        # Heist 1
        # Titulo golpe
        titulo_salvageyard_heist1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 1", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist1.grid(row=701, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist1= ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 1", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist1.grid(row=702, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        
        self.opcao_golpe1 = tk.StringVar()  # Vari√°vel de controle para o Golpe 1

        opcoes_golpe1 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]
        
        
        for idx, opcao in enumerate(opcoes_golpe1):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe1,
                value=opcao
            ).grid(row=703 + idx, column=0, padx=10, pady=2, sticky="w")
        
        
        
        # Nome do veiculo
        titulo_salvageyard_veiculo1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo1.grid(row=708, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 1", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo1.grid(row=709, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo1 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo1.grid(row=710, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo1.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo1.bind('<Return>', self.proximo_campo)
        
        self.caixas_texto.append(self.entrada_salvageyard_veiculo1)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo1)
        
        # Reclam√°vel?
        self.reclamavel_veiculo1 = tk.BooleanVar()  
        checkbutton_reclamavel = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo1,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel.grid(row=711, column=0, padx=10, pady=5, sticky="w")
        
        
        # Heist 2
        # Titulo golpe
        titulo_salvageyard_heist2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 2", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist2.grid(row=712, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist2 = ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 2", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist2.grid(row=713, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        self.opcao_golpe2 = tk.StringVar()  # Vari√°vel de controle para o Golpe 2

        opcoes_golpe2 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]

        for idx, opcao in enumerate(opcoes_golpe2):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe2,
                value=opcao
            ).grid(row=714 + idx, column=0, padx=10, pady=2, sticky="w")

        # Nome do veiculo
        titulo_salvageyard_veiculo2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo2.grid(row=719, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 2", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo2.grid(row=720, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo2 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo2.grid(row=721, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo2.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo2.bind('<Return>', self.proximo_campo)

        self.caixas_texto.append(self.entrada_salvageyard_veiculo2)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo2)

        # Reclam√°vel?
        self.reclamavel_veiculo2 = tk.BooleanVar()
        checkbutton_reclamavel2 = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo2,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel2.grid(row=722, column=0, padx=10, pady=5, sticky="w")


        # Heist 3
        # Titulo golpe
        titulo_salvageyard_heist3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 3", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist3.grid(row=723, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist3 = ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 3", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist3.grid(row=724, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        self.opcao_golpe3 = tk.StringVar()  # Vari√°vel de controle para o Golpe 3

        opcoes_golpe3 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]

        for idx, opcao in enumerate(opcoes_golpe3):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe3,
                value=opcao
            ).grid(row=725 + idx, column=0, padx=10, pady=2, sticky="w")

        # Nome do veiculo
        titulo_salvageyard_veiculo3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo3.grid(row=730, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 3", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo3.grid(row=731, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo3 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo3.grid(row=732, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo3.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo3.bind('<Return>', self.proximo_campo)

        self.caixas_texto.append(self.entrada_salvageyard_veiculo3)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo3)

        # Reclam√°vel?
        self.reclamavel_veiculo3 = tk.BooleanVar()
        checkbutton_reclamavel3 = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo3,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel3.grid(row=733, column=0, padx=10, pady=5, sticky="w")



    # Ve√≠culo do P√≥dio###################################################################
        label_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culo do P√≥dio", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_veiculo_podio.grid(row=800, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Ve√≠culo#######
        # T√≠tulo
        label_nome_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Ve√≠culo:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_veiculo_podio.grid(row=801, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do ve√≠culo exibido no p√≥dio.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_veiculo_podio.grid(row=802, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_veiculo_podio = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_veiculo_podio.grid(row=803, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_veiculo_podio.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_veiculo_podio.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_veiculo_podio)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_veiculo_podio)





        # Novo Desafio do Encontro de Carros (LS Car Meet) ###################################################################
        label_ls_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Novo Desafio do Encontro de Carros (LS Car Meet)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_ls_car_meet.grid(row=900, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Desafio #######
        # T√≠tulo
        label_nome_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Desafio:", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_nome_desafio_car_meet.grid(row=901, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do desafio do encontro de carros.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_desafio_car_meet.grid(row=902, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_desafio_car_meet = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_desafio_car_meet.grid(row=903, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_desafio_car_meet.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_nome_desafio_car_meet.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_nome_desafio_car_meet)
        self.associar_botao_filtro(self.entrada_nome_desafio_car_meet)


        # Por quantos dias? #######
        # T√≠tulo
        label_dias_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Por quantos dias?", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_dias_desafio_car_meet.grid(row=904, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_dias_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Por quantos dias seguidos deves manter o resultado?.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_dias_desafio_car_meet.grid(row=905, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_dias_desafio_car_meet = ttk.Entry(self.frame_deslocavel)
        self.entrada_dias_desafio_car_meet.grid(row=906, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_dias_desafio_car_meet.insert(tk.END, "3")
        self.entrada_dias_desafio_car_meet.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event), self.entrada_dias_desafio_car_meet.select_range(0, tk.END)))
        self.entrada_dias_desafio_car_meet.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_dias_desafio_car_meet)

        # Recompensa do Desafio #######
        # T√≠tulo
        label_recompensa_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Recompensa:", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_recompensa_desafio_car_meet.grid(row=907, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_recompensa_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a recompensa para completar o desafio do encontro de carros.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_recompensa_desafio_car_meet.grid(row=908, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_recompensa_desafio_car_meet = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_recompensa_desafio_car_meet.grid(row=909, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_desafio_car_meet.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_desafio_car_meet.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_desafio_car_meet.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_desafio_car_meet))
        self.entrada_recompensa_desafio_car_meet.bind("<Button-1>", self.scroll_para_cursor)
        self.entrada_recompensa_desafio_car_meet.bind("<Up>", self.scroll_para_cursor)
        self.entrada_recompensa_desafio_car_meet.bind("<Down>", self.scroll_para_cursor)

        self.caixas_texto.append(self.entrada_recompensa_desafio_car_meet)
        self.associar_botao_filtro(self.entrada_recompensa_desafio_car_meet)



    
    # Novo Desafio do Encontro de Carros (Test Rides) ###################################################################

        # T√≠tulo principal
        label_test_rides_title = ttk.Label(
            self.frame_deslocavel, 
            text="Test Rides", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_test_rides_title.grid(row=1000, column=0, sticky="w", padx=10, pady=(20, 10))



        # Test Rides ##########

        # T√≠tulo
        label_test_rides = ttk.Label(
            self.frame_deslocavel, 
            text="Test Rides:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_test_rides.grid(row=1001, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_test_rides = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome dos veiculos que estao para teste na sua linha especifica", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_test_rides.grid(row=1002, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        
        def limitar_linhas(event, widget):
            # Obter o conte√∫do atual da caixa de texto
            lines = widget.get(1.0, tk.END).splitlines()
            
            # Se houver mais de 3 linhas, cortar para 3
            if len(lines) > 3:
                widget.delete(f"4.0", tk.END)  # Excluir o conte√∫do ap√≥s a 3¬™ linha
            # Se houver menos de 3 linhas, adicionar uma linha em branco
            elif len(lines) < 3:
                widget.insert(tk.END, "\n")
                

        self.entrada_test_rides = tk.Text(self.frame_deslocavel, height=3, wrap=tk.WORD)  # Ajustado para 3 linhas de altura
        self.entrada_test_rides.grid(row=1003, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_test_rides.insert(tk.END, "\n" * 3)
        self.entrada_test_rides.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_test_rides.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_test_rides))
        self.entrada_test_rides.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_test_rides.bind("<Button-1>", self.scroll_para_cursor)
        self.entrada_test_rides.bind("<Up>", self.scroll_para_cursor)
        self.entrada_test_rides.bind("<Down>", self.scroll_para_cursor)

        self.caixas_texto.append(self.entrada_test_rides)
        self.associar_botao_filtro(self.entrada_test_rides)

    
    
    
    # Ve√≠culo de Teste Premium###################################################################

        # T√≠tulo principal
        label_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culo de Teste Premium", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_veiculo_teste_premium.grid(row=1004, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Ve√≠culo#######

        # T√≠tulo
        label_nome_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Ve√≠culo:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_veiculo_teste_premium.grid(row=1005, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do ve√≠culo de teste premium.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_veiculo_teste_premium.grid(row=1006, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_veiculo_teste_premium = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_veiculo_teste_premium.grid(row=1007, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_veiculo_teste_premium.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_veiculo_teste_premium.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_veiculo_teste_premium)  # Adiciona a entrada √† lista de caixas de texto
        self.associar_botao_filtro(self.entrada_nome_veiculo_teste_premium)



        # Luxury Autos ###################################################################

        # T√≠tulo principal
        label_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Luxury Autos", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_luxury_autos.grid(row=1100, column=0, sticky="ew", padx=10, pady=(20, 10))

        # Imagem Luxury Autos ###################################################################
        # T√≠tulo
        label_imagem_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem Luxury Autos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_luxury_autos.grid(row=1101, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto da Luxury Autos desta semana", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_luxury_autos.grid(row=1102, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_luxury_autos = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_luxury_autos.grid(row=1103, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_luxury_autos.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_imagem_luxury_autos.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_imagem_luxury_autos)  # Adiciona a entrada √† lista de caixas

        # Ve√≠culos Luxury Autos ###################################################################

        # T√≠tulo
        label_veiculos_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culos Luxury Autos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_veiculos_luxury_autos.grid(row=1104, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_veiculos_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz os ve√≠culos dispon√≠veis da Luxury Autos.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_veiculos_luxury_autos.grid(row=1105, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_veiculos_luxury_autos = tk.Text(self.frame_deslocavel, height=2, wrap=tk.WORD)
        self.entrada_veiculos_luxury_autos.grid(row=1106, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_veiculos_luxury_autos.bind("<FocusIn>", lambda event: self.scroll_para_cursor(event))
        self.entrada_veiculos_luxury_autos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_veiculos_luxury_autos.bind("<Return>", lambda event: self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.entrada_veiculos_luxury_autos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_veiculos_luxury_autos))

        self.caixas_texto.append(self.entrada_veiculos_luxury_autos)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_veiculos_luxury_autos)




    # Premium Deluxe Motorsport ###################################################################

        # T√≠tulo principal
        label_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Premium Deluxe Motorsport", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_premium_deluxe_motorsport.grid(row=1200, column=0, sticky="ew", padx=10, pady=(20, 10))

        # Imagem Premium Deluxe Motorsport ###################################################################

        # T√≠tulo
        label_imagem_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem Premium Deluxe Motorsport:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_premium_deluxe_motorsport.grid(row=1201, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto da Premium Deluxe Motorsport desta semana", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_premium_deluxe_motorsport.grid(row=1202, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_premium_deluxe_motorsport = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_premium_deluxe_motorsport.grid(row=1203, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_premium_deluxe_motorsport.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_imagem_premium_deluxe_motorsport.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_imagem_premium_deluxe_motorsport)  # Adiciona a entrada √† lista de caixas

        # Ve√≠culos Premium Deluxe Motorsport ###################################################################

        # T√≠tulo
        label_veiculos_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culos Premium Deluxe Motorsport:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_veiculos_premium_deluxe_motorsport.grid(row=1204, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_veiculos_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz os ve√≠culos dispon√≠veis da Premium Deluxe Motorsport.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_veiculos_premium_deluxe_motorsport.grid(row=1205, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_veiculos_premium_deluxe_motorsport = tk.Text(self.frame_deslocavel, height=5, wrap=tk.WORD)
        self.entrada_veiculos_premium_deluxe_motorsport.grid(row=1206, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<FocusIn>", lambda event: self.scroll_para_cursor(event))
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<Return>", lambda event: self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_veiculos_premium_deluxe_motorsport))

        self.caixas_texto.append(self.entrada_veiculos_premium_deluxe_motorsport)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_veiculos_premium_deluxe_motorsport)



        # Corrida Premium ###################################################################
        label_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Corrida Premium", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_corrida_premium.grid(row=1300, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome da Corrida Premium #######
        # T√≠tulo
        label_nome_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Nome da Corrida:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_corrida_premium.grid(row=1301, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome da corrida premium.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_corrida_premium.grid(row=1302, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_corrida_premium = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_corrida_premium.grid(row=1303, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_corrida_premium.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_corrida_premium.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_corrida_premium)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_corrida_premium)




        # Contra Rel√≥gio ###################################################################
        label_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio.grid(row=1400, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio #######
        # T√≠tulo
        label_nome_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio.grid(row=1401, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio.grid(row=1402, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio.grid(row=1403, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio)




        # Contra Rel√≥gio HSW ###################################################################
        label_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio HSW", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio_hsw.grid(row=1500, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio HSW #######
        # T√≠tulo
        label_nome_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio HSW:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio_hsw.grid(row=1501, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio HSW.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio_hsw.grid(row=1502, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio_hsw = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio_hsw.grid(row=1503, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio_hsw.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio_hsw.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio_hsw)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio_hsw)




        # Contra Rel√≥gio RC ###################################################################
        label_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio RC", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio_rc.grid(row=1600, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio RC #######
        # T√≠tulo
        label_nome_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio RC:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio_rc.grid(row=1601, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio RC.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio_rc.grid(row=1602, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio_rc = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio_rc.grid(row=1603, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio_rc.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio_rc.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio_rc)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio_rc)
        
        
        # Mais Info ###################################################################
        label_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mais Info", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_mais_info.grid(row=2000, column=0, sticky="w", padx=10, pady=(20, 10))

        # Descri√ß√£o da Mais Info #######
        # T√≠tulo
        label_descricao_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mais Info:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_descricao_mais_info.grid(row=2001, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_descricao_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mete o url da pagina de newswire desta semana em pt:", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_descricao_mais_info.grid(row=2002, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_descricao_mais_info = ttk.Entry(self.frame_deslocavel)
        self.entrada_descricao_mais_info.grid(row=2003, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_descricao_mais_info.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_descricao_mais_info.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_descricao_mais_info)  # Adiciona a entrada √† lista de caixas

        self.caixas_texto.append(self.entrada_descricao_mais_info)  # Adiciona a entrada √† lista de caixas





            
    def scroll_para_cursor(self, event):
        """Garante que o cursor ou a caixa de texto em foco esteja vis√≠vel."""
        widget = event.widget
        if isinstance(widget, tk.Text) or isinstance(widget, ttk.Entry):
            self.tela.update_idletasks()  # Atualiza a geometria do Canvas

            # Calcula a posi√ß√£o do widget em rela√ß√£o ao Canvas
            widget_y = widget.winfo_rooty() - self.tela.winfo_rooty()
            canvas_height = self.tela.winfo_height()

            # Verifica se o widget est√° acima ou abaixo da √°rea vis√≠vel do Canvas
            if widget_y < 0:  # Fora da parte superior
                self.tela.yview_scroll(int(widget_y // -10), "units")
            elif widget_y + widget.winfo_height() > canvas_height:  # Fora da parte inferior
                self.tela.yview_scroll(int((widget_y + widget.winfo_height() - canvas_height) // 10), "units")


    
            
    def proximo_campo_com_tab(self, event):
        """Move o foco para o pr√≥ximo campo ao pressionar Tab"""
        current = event.widget
        next_index = self.caixas_texto.index(current) + 1
        if next_index < len(self.caixas_texto):
            self.caixas_texto[next_index].focus_set()
        return "break"



            

    def _no_roda_rato(self, event):
        """ Fun√ß√£o para rolar a tela com o uso do rato """
        self.tela.yview_scroll(int(-1 * (event.delta / 120)), "units")
    
    #Botao Gerar BBCode
    def criar_botao_gerar(self):
        """Cria o bot√£o fixo Gerar BBCode"""
        self.frame_botao = ttk.Frame(self.aba_evento_semanal)
        self.frame_botao.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)  # Fixa o bot√£o no final e centraliza
        self.frame_botao.grid_columnconfigure(0, weight=1)  # Centraliza o bot√£o dentro do frame
        self.aba_evento_semanal.grid_rowconfigure(2, weight=0)  # Fixa o bot√£o no final
        
        
        self.botao_gerar = ttk.Button(
            self.frame_botao, 
            text="Gerar BBCode",
            command=self.mostrar_preview
        )
        self.botao_gerar.pack(pady=5)
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        ########################################################### BBCODE ##########################################################
        
    #Janela Preview
    def mostrar_preview(self):
        """Abre uma nova janela com o preview do BBCode"""
        global conteudo
        conteudo = ""
        
        ##########BBCODE DAS CAIXAS DE TEXTO############
        
        #######Categoria URL de imagem ou v√≠deo de capa
        url_imagem = self.caixas_texto[0].get()  # Como h√° apenas uma caixa de texto, pegamos o conte√∫do da primeira

        # Verifica se a URL n√£o est√° vazia antes de adicionar ao conteudo
        if url_imagem:  # S√≥ adiciona se a URL n√£o estiver vazia
            # Extens√µes de imagem conhecidas
            extensoes_imagem = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff"]
            
            # Verifica se o URL termina com uma das extens√µes de imagem
            if any(url_imagem.lower().endswith(ext) for ext in extensoes_imagem):
                # URL √© de uma imagem, adiciona o BBCode [img]
                conteudo += f"[img]{url_imagem}[/img]\n\n"
            else:
                # Apenas adiciona o URL com nova linha
                conteudo += f"{url_imagem}\n\n"
        
        
        
        
        ####### Categoria Nota:
        conteudo += "[b]NOTA:[/b] Este Evento t√™m inicio na quinta-feira √†s 9:45 horas da manh√£, e decorre at√© as 9:45 da manh√£ da [b]quinta-feira[/b] da semana seguinte (Hora de Portugal)\n\n\n\n"
        
        
        ########################### Categoria Conte√∫do Novo
        # Obter o valor da entrada de texto para o conte√∫do novo
        conteudo_novo = self.entrada_conteudo_novo.get("1.0", "end-1c").splitlines(keepends=False)
        imagens_conteudo_novo = self.entrada_imagem_conteudo_novo.get("1.0", "end-1c").splitlines(keepends=False)

        # Verificar se h√° conte√∫do ou imagens
        if conteudo_novo or imagens_conteudo_novo:
            categoria_conteudo_novo = "Conte√∫do Novo"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_conteudo_novo}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            
            # Come√ßar a tabela
            conteudo += "[list]\n"

            # Processar cada linha de conte√∫do e associar imagens
            for i, linha in enumerate(conteudo_novo):
                # Preservar linhas em branco (n√£o aplicar strip diretamente)
                texto_linha = linha if linha.strip() else ""
                imagem_associada = imagens_conteudo_novo[i] if i < len(imagens_conteudo_novo) and imagens_conteudo_novo[i].strip() else None

                # Adicionar a imagem, se houver
                if imagem_associada:
                    conteudo += f"[*] [img]{imagem_associada}[/img]\n"
                
                # Adicionar o texto do item (mesmo que seja vazio para linhas em branco)
                conteudo += f"[*] {texto_linha}\n"

            # Fechar a tabela
            conteudo += "[/list]\n"

            # Adicionar imagens n√£o associadas (fora da tabela)
            for i in range(len(conteudo_novo), len(imagens_conteudo_novo)):
                imagem_nao_associada = imagens_conteudo_novo[i]
                if imagem_nao_associada.strip():  # Garantir que a imagem n√£o √© uma linha vazia
                    conteudo += f"[img]{imagem_nao_associada}[/img]\n"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n"
            
        else:
            # Se n√£o houver conte√∫do nem imagens, n√£o adicionar nada
            pass



        
        
        
        
        #########  Categoria Novos ve√≠culos dispon√≠veis
        # Nome da categoria
        categoria_novos_veiculos = "Novos Ve√≠culos Dispon√≠veis"

        # Obter as entradas
        nome_veiculos = self.entrada_novos_veiculos.get("1.0", "end-1c")
        imagem_veiculos = self.entrada_imagem_novos_veiculos.get("1.0", "end-1c")
        desbloqueio_veiculos = self.entrada_desbloqueio_novos_veiculos.get("1.0", "end-1c")
        preco_fabrica_veiculos = self.entrada_precofabrica_novos_veiculos.get("1.0", "end-1c")

        # Dividir as entradas em linhas, sem remover espa√ßos ou linhas em branco
        nome_veiculos_linhas = nome_veiculos.splitlines()
        imagem_veiculos_linhas = imagem_veiculos.splitlines()
        desbloqueio_veiculos_linhas = desbloqueio_veiculos.splitlines()
        preco_fabrica_veiculos_linhas = preco_fabrica_veiculos.splitlines()

        # Verificar se todas as listas est√£o vazias
        if any(nome_veiculos_linhas) or any(imagem_veiculos_linhas) or any(desbloqueio_veiculos_linhas) or any(preco_fabrica_veiculos_linhas):
            # Garantir que todas as listas tenham o mesmo n√∫mero de linhas
            max_linhas = max(len(nome_veiculos_linhas), len(imagem_veiculos_linhas), len(desbloqueio_veiculos_linhas), len(preco_fabrica_veiculos_linhas))
            nome_veiculos_linhas += [""] * (max_linhas - len(nome_veiculos_linhas))
            imagem_veiculos_linhas += [""] * (max_linhas - len(imagem_veiculos_linhas))
            desbloqueio_veiculos_linhas += [""] * (max_linhas - len(desbloqueio_veiculos_linhas))
            preco_fabrica_veiculos_linhas += [""] * (max_linhas - len(preco_fabrica_veiculos_linhas))

            # Construir o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_novos_veiculos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            for i in range(max_linhas):
                # Retirar apenas espa√ßos √† volta das linhas (sem ignorar linhas vazias)
                nome_veiculo = nome_veiculos_linhas[i]
                imagem = imagem_veiculos_linhas[i]
                desbloqueio = desbloqueio_veiculos_linhas[i]
                preco_fabrica = preco_fabrica_veiculos_linhas[i]

                # Processar mesmo que a primeira linha seja vazia
                conteudo += "[list]"

                # Adicionar imagem se existir
                if imagem.strip():
                    conteudo += f"[img]{imagem.strip()}[/img]\n"

                if nome_veiculo.strip():  # Garantir que o nome do ve√≠culo aparece
                    conteudo += f"[*][b]{nome_veiculo.strip()}[/b]\n"

                conteudo += "[list]"
                if desbloqueio.strip():
                    conteudo += f"[*][b]Desbloqueio de Compra:[/b] {desbloqueio.strip()}\n"
                if preco_fabrica.strip():
                    conteudo += f"[*][b]Pre√ßo de F√°brica:[/b] {preco_fabrica.strip()}\n"
                conteudo += "[/list]"

                conteudo += "[/list]\n\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"
        
        
        
        #########  Pr√©mios de Login
        # Nome da categoria
        categoria_premios_login = "Pr√©mios de Login"

        # Obter as entradas
        entrada_premios_login = self.entrada_premios_login.get("1.0", "end-1c")
        entrada_imagem_premios_login = self.entrada_imagem_premios_login.get("1.0", "end-1c")

        # Dividir as entradas em linhas
        premios_login_linhas = entrada_premios_login.splitlines()
        imagens_premios_login_linhas = entrada_imagem_premios_login.splitlines()

        # Verificar se pelo menos uma das listas cont√©m valores n√£o vazios
        if any(premios_login_linhas) or any(imagens_premios_login_linhas):
            # Garantir que todas as listas tenham o mesmo n√∫mero de linhas
            max_linhas = max(len(premios_login_linhas), len(imagens_premios_login_linhas))
            premios_login_linhas += [""] * (max_linhas - len(premios_login_linhas))
            imagens_premios_login_linhas += [""] * (max_linhas - len(imagens_premios_login_linhas))

            # Construir o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_premios_login}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Vari√°vel de controle para fechar e abrir listas
            abriu_lista = False

            for i in range(max_linhas):
                premio = premios_login_linhas[i].strip()
                imagem = imagens_premios_login_linhas[i].strip()

                # Se houver uma imagem sem um item associado, coloca fora da lista
                if imagem and not premio:
                    conteudo += f"[img]{imagem}[/img]\n"
                
                # Se houver um item com imagem associada
                elif premio and imagem:
                    # Se n√£o h√° uma lista aberta, abre uma nova
                    if not abriu_lista:
                        conteudo += "[list]\n"
                        abriu_lista = True

                    # Adiciona a imagem e o item no mesmo item da lista
                    conteudo += f"[*][img]{imagem}[/img] \n{premio}\n"

                # Se houver um item sem imagem, adiciona normalmente
                elif premio:
                    # Se n√£o h√° uma lista aberta, abre uma nova
                    if not abriu_lista:
                        conteudo += "[list]\n"
                        abriu_lista = True

                    conteudo += f"[*]{premio}\n"

            # Fechar a √∫ltima lista se estiver aberta
            if abriu_lista:
                conteudo += "[/list]\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"

        
        
        
        #############  Categoria Retorno de Conte√∫do
        # Nome da categoria principal
        categoria_retorno_conteudo = "Retorno de Conte√∫do"

        # Obter as entradas para as subcategorias de miss√µes
        entrada_ret_missoes = self.entrada_ret_missoes.get("1.0", "end-1c")
        entrada_recomp_missoes = self.entrada_recomp_missoes.get("1.0", "end-1c")
        entrada_img_missoes = self.entrada_img_missoes.get("1.0", "end-1c")

        # Obter as entradas para as subcategorias de eventos de modo livre
        entrada_ret_eventos = self.entrada_ret_eventos.get("1.0", "end-1c")
        entrada_recomp_eventos = self.entrada_recomp_eventos.get("1.0", "end-1c")
        entrada_img_eventos = self.entrada_img_eventos.get("1.0", "end-1c")

        # Obter o banner
        entrada_banner = self.entrada_banner.get("1.0", "end-1c")

        # Dividir as entradas em linhas
        ret_missoes_linhas = entrada_ret_missoes.splitlines()
        recomp_missoes_linhas = entrada_recomp_missoes.splitlines()
        imagem_missoes_linhas = entrada_img_missoes.splitlines()

        ret_eventos_linhas = entrada_ret_eventos.splitlines()
        recomp_eventos_linhas = entrada_recomp_eventos.splitlines()
        imagem_eventos_linhas = entrada_img_eventos.splitlines()

        # Verificar se h√° qualquer conte√∫do para ser exibido
        tem_conteudo_missoes = any(ret_missoes_linhas) or any(recomp_missoes_linhas) or any(imagem_missoes_linhas)
        tem_conteudo_eventos = any(ret_eventos_linhas) or any(recomp_eventos_linhas) or any(imagem_eventos_linhas)
        tem_banner = bool(entrada_banner.strip())

        # Construir o conte√∫do principal apenas se houver algo a ser exibido
        if tem_conteudo_missoes or tem_conteudo_eventos or tem_banner:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_retorno_conteudo}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Adicionar banner, se existir
            if tem_banner:
                for linha_banner in entrada_banner.splitlines():
                    imagens = [img.strip() for img in linha_banner.split(",")]
                    conteudo += "".join(f"[img]{img}[/img]" for img in imagens) + "\n"
                conteudo += "\n"

            # Subcategoria: Retorno de Miss√µes
            if tem_conteudo_missoes:
                conteudo += f"[b][size=125][color=#0055a4]Retorno de Miss√µes:[/color][/size][/b]\n"
                conteudo += "[list]\n"
                max_linhas_missoes = max(len(ret_missoes_linhas), len(recomp_missoes_linhas), len(imagem_missoes_linhas))
                ret_missoes_linhas += [""] * (max_linhas_missoes - len(ret_missoes_linhas))
                recomp_missoes_linhas += [""] * (max_linhas_missoes - len(recomp_missoes_linhas))
                imagem_missoes_linhas += [""] * (max_linhas_missoes - len(imagem_missoes_linhas))

                for i in range(max_linhas_missoes):
                    retorno = ret_missoes_linhas[i]
                    recompensa = recomp_missoes_linhas[i]
                    imagens = imagem_missoes_linhas[i]

                    if retorno.strip() or recompensa.strip() or imagens.strip():
                        conteudo += "[*] "
                        if retorno.strip():
                            conteudo += retorno.strip() + " - "
                        if recompensa.strip():
                            conteudo += f"[b]{recompensa.strip()}[/b]"
                        conteudo += "\n"
                        if imagens.strip():
                            for img in imagens.split(","):
                                conteudo += f"[img]{img.strip()}[/img]"
                            conteudo += "\n"
                conteudo += "[/list]\n\n"

            # Subcategoria: Retorno de Eventos de Modo Livre
            if tem_conteudo_eventos:
                conteudo += f"[b][size=125][color=#0055a4]Retorno de Eventos de Modo Livre:[/color][/size][/b]\n"
                conteudo += "[list]\n"
                max_linhas_eventos = max(len(ret_eventos_linhas), len(recomp_eventos_linhas), len(imagem_eventos_linhas))
                ret_eventos_linhas += [""] * (max_linhas_eventos - len(ret_eventos_linhas))
                recomp_eventos_linhas += [""] * (max_linhas_eventos - len(recomp_eventos_linhas))
                imagem_eventos_linhas += [""] * (max_linhas_eventos - len(imagem_eventos_linhas))

                for i in range(max_linhas_eventos):
                    retorno = ret_eventos_linhas[i]
                    recompensa = recomp_eventos_linhas[i]
                    imagens = imagem_eventos_linhas[i]

                    if retorno.strip() or recompensa.strip() or imagens.strip():
                        conteudo += "[*] "
                        if retorno.strip():
                            conteudo += retorno.strip() + " - "
                        if recompensa.strip():
                            conteudo += f"[b]{recompensa.strip()}[/b]"
                        conteudo += "\n"
                        if imagens.strip():
                            for img in imagens.split(","):
                                conteudo += f"[img]{img.strip()}[/img]"
                            conteudo += "\n"
                conteudo += "[/list]\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"





        ####### Categoria Desafio Semanal
        categoria_nome = "Desafio Semanal"  # Vari√°vel para armazenar o nome da categoria
        desafio_objetivo = self.entrada_desafio_semanal.get().strip()
        recompensa = self.entrada_recompensa_objectivo_semanal.get("1.0", "end-1c").strip()

        # Ignorar o BBCode da categoria se ambos os campos estiverem vazios
        if not desafio_objetivo and not recompensa:
            pass  # Ignora a categoria inteira se ambos os campos estiverem vazios
        else:
            conteudo += f"""[b][size=150][color=#0073e6]{categoria_nome}:[/color][/size][/b]
[hr][/hr]
[list] [b]{desafio_objetivo}[/b]"""

            # Dividir a recompensa em linhas
            recompensa_linhas = recompensa.splitlines()

            if len(recompensa_linhas) == 1:
                # Caso tenha apenas 1 linha
                conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] [/list]"
            elif len(recompensa_linhas) == 2:
                # Caso tenha 2 linhas
                conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b] [/list]"
            else:
                # Caso tenha 3 ou mais linhas
                conteudo += " e recebe:\n[list]\n"
                for linha in recompensa_linhas:
                    conteudo += f"[*][b]{linha}[/b]\n"
                conteudo += "[/list]"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"

                




        ######## Categoria B√¥nus de Atividade
        categoria_bonus_nome = "B√¥nus de Evento"  # Nome da nova categoria

        # Verificar se os campos est√£o preenchidos
        bonus_objetivo = self.entrada_bonus_atividade.get().strip()
        bonus_recompensa = self.entrada_recompensa_bonus_atividade.get("1.0", "end-1c").strip()
        timeframe = self.entrada_timeframe_bonus_atividade.get().strip()
        imagem_bonus = self.entrada_imagem_bonus_atividade.get().strip()  # Obt√©m o link da imagem

        # Ignorar o BBCode da categoria se todos os campos estiverem vazios
        if not bonus_objetivo and not bonus_recompensa and not timeframe and not imagem_bonus:
            pass  # Ignora a categoria inteira se todos os campos estiverem vazios
        else:
            conteudo += f"""[b][size=150][color=#0073e6]{categoria_bonus_nome}:[/color][/size][/b]
        [hr][/hr]
        """

            # Adicionar o BBCode da imagem se o campo imagem_bonus n√£o estiver vazio
            if imagem_bonus:
                conteudo += f"[img]{imagem_bonus}[/img]\n\n"

            conteudo += f"[b]{bonus_objetivo}[/b]"

            # Dividir a recompensa do b√¥nus em linhas
            recompensa_linhas = bonus_recompensa.splitlines()

            if len(recompensa_linhas) == 1:
                # Caso tenha apenas 1 linha
                if timeframe:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] at√© [b]{timeframe}[/b]\n"
                else:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b]\n"
            elif len(recompensa_linhas) == 2:
                # Caso tenha 2 linhas
                if timeframe:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b] at√© [b]{timeframe}[/b]\n"
                else:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b]\n"
            else:
                # Caso tenha 3 ou mais linhas
                if timeframe:
                    conteudo += f" e recebe dentro de [b]{timeframe}[/b]:\n[list]"
                else:
                    conteudo += " e recebe:\n[list]"

                for linha in recompensa_linhas:
                    conteudo += f"[*][b]{linha}[/b]\n"
                conteudo += "[/list]\n"  # Fechar a lista para mais de 3 linhas

            # Garantir que sempre haja 3 linhas de espa√ßamento
            conteudo += "\n\n\n"



                
                
                
                
        #########  Categoria Atividades de B√≥nus GTA$ e RP
        categoria_bonus_gta_rp = "Atividades de B√≥nus GTA$ e RP"

        # Obter as entradas das caixas de texto
        nome_atividades = self.entrada_nome_atividades_gta_rp.get("1.0", "end-1c").strip()  # Caixa de texto para as atividades
        imagem_atividades = self.entrada_imagem_atividades_gta_rp.get("1.0", "end-1c").strip()  # Caixa de texto para a imagem

        # Separar as linhas de cada caixa de texto, ignorando linhas vazias
        nome_atividades_linhas = [linha.strip() for linha in nome_atividades.splitlines() if linha.strip()]
        imagem_atividades_linhas = [linha.strip() for linha in imagem_atividades.splitlines()]

        # Processar e organizar atividades com base em GTA$ e RP
        atividades_organizadas = []

        import re

        for linha in nome_atividades_linhas:
            # Substituir conectores para padronizar
            linha = re.sub(r'\b(and|e)\b', '&', linha, flags=re.IGNORECASE)
            linha = re.sub(r'\b(on|em)\b', 'em', linha, flags=re.IGNORECASE)

            # Extrair valores de GTA$ e RP
            gta_match = re.search(r'(\d+)x GTA\$', linha, flags=re.IGNORECASE)
            rp_match = re.search(r'(\d+)x RP', linha, flags=re.IGNORECASE)

            gta_valor = int(gta_match.group(1)) if gta_match else 0
            rp_valor = int(rp_match.group(1)) if rp_match else 0

            atividades_organizadas.append((gta_valor, rp_valor, linha))

        # Ordenar atividades pelo maior GTA$ e, em caso de empate, pelo maior RP
        atividades_organizadas.sort(key=lambda x: (-x[0], -x[1]))

        # Ignorar o BBCode da categoria se ambas as caixas estiverem vazias
        if atividades_organizadas or imagem_atividades_linhas:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_bonus_gta_rp}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += "[List]\n"

            # Processar atividades organizadas com suas imagens correspondentes
            max_linhas = max(len(atividades_organizadas), len(imagem_atividades_linhas))
            
            for i in range(max_linhas):
                conteudo += "[*]"
                
                # Pega a imagem correspondente ou mant√©m uma string vazia se n√£o houver imagem
                imagem = imagem_atividades_linhas[i] if i < len(imagem_atividades_linhas) else ""

                # Pega a atividade correspondente organizada
                atividade = atividades_organizadas[i][2] if i < len(atividades_organizadas) else ""

                # Se houver imagem, adicionar imagem antes da atividade
                if imagem:
                    conteudo += f"[img]{imagem}[/img] "
                
                # Adicionar a atividade
                if atividade:
                    conteudo += f"{atividade}\n"

            conteudo += "[/List]\n\n\n\n"

            
            
            
        
        ######### Categoria de Desconto

        categoria_descontos = "Descontos"

        # Obter as entradas de imagem e descontos
        imagem_descontos = self.entrada_imagem_descontos.get().strip()  # Caixa de texto para a imagem dos descontos
        descontos = self.entrada_descontos.get("1.0", "end-1c").strip()  # Caixa de texto para os descontos

        # Verificar se ao menos uma das entradas est√° preenchida
        if not imagem_descontos and not descontos:
            pass  # Ignora a categoria inteira se ambas as caixas estiverem vazias
        else:
            # Inicializar o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_descontos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Adicionar a imagem (se dispon√≠vel) antes dos descontos
            if imagem_descontos:
                conteudo += f"[img]{imagem_descontos}[/img]\n"

            # Processar os descontos
            if descontos:
                descontos_linhas = [linha.strip() for linha in descontos.splitlines() if linha.strip()]  # Ignorar linhas vazias

                # Inicializar o dicion√°rio de percentagens
                descontos_dict = {}
                formato_valido = True

                for linha in descontos_linhas:
                    # Remover conte√∫do dentro de par√™nteses e os pr√≥prios par√™nteses
                    linha_limpa = re.sub(r"\s*\(.*?\)", "", linha).strip()

                    # Ajustar para capturar h√≠fens alternativos e espa√ßos extras
                    match = re.match(r"^(.*?)\s*[-‚Äì]\s*(\d+)%\s*(off|de desconto)?$", linha_limpa, re.IGNORECASE)
                    if match:
                        nome, percentagem, _ = match.groups()
                        percentagem = int(percentagem)

                        # Adicionar ao dicion√°rio
                        if percentagem not in descontos_dict:
                            descontos_dict[percentagem] = []
                        descontos_dict[percentagem].append(nome.strip())
                    else:
                        formato_valido = False
                        break  # Interromper se algum item n√£o seguir o formato esperado

                if formato_valido:
                    # Ordenar as percentagens de maior para menor e gerar o conte√∫do
                    for percentagem in sorted(descontos_dict.keys(), reverse=True):
                        conteudo += f"[b]{percentagem}%[/b]\n[list]\n"
                        for item in descontos_dict[percentagem]:
                            conteudo += f"[*] {item}\n"
                        conteudo += "[/list]\n\n"
                else:
                    # Caso o formato n√£o seja o esperado, gerar uma lista simples
                    conteudo += "\n[list]\n"
                    for linha in descontos_linhas:
                        conteudo += f"[*] {linha}\n"
                    conteudo += "[/list]\n\n\n\n"




                    
                    
                    

        # Categoria GunVan
        categoria_gun_van = "Van de Arsenal (Gun Van)"

        # Obter o conte√∫do da caixa de texto da Gun Van
        gun_van_texto = self.entrada_gunvan.get("1.0", "end-1c").strip()

        # Verificar se a caixa de texto da Gun Van n√£o est√° vazia antes de adicionar o BBCode
        if gun_van_texto:  
            # Adicionar o t√≠tulo da categoria de Gun Van
            conteudo += "\n\n\n\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_gun_van}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"[img]https://rockstarintel.com/wp-content/uploads/2023/01/b6b37e2ae693cdff8f2feb234b44b76948b1529b-scaled.jpg[/img]\n"

            # üîπ Fun√ß√£o para ajustar os descontos e tradu√ß√µes corretamente (PT e EN)
            def ajustar_percentagem(texto):
                # Corrigir porcentagens em ingl√™s e portugu√™s
                texto = re.sub(r"(\d+)%\s*off", r"\1%", texto)  # "50% off" ‚Üí "50%"
                texto = re.sub(r"(\d+)%\s*de desconto", r"\1%", texto)  # "50% de desconto" ‚Üí "50%"
                
                # Ajustar GTA+ em ingl√™s e portugu√™s
                texto = re.sub(r"(\d+)%\s*for GTA\+ Members", r"\1% GTA+", texto)  # "50% for GTA+ Members" ‚Üí "50% GTA+"
                texto = re.sub(r"(\d+)%\s*para membros do GTA\+", r"\1% GTA+", texto)  # "50% para membros do GTA+" ‚Üí "50% GTA+"
                
                # Ajustar "free" para GTA+ em ambos idiomas
                texto = re.sub(r"free for GTA\+ Members", "Gratis GTA+", texto)  # "free for GTA+ Members" ‚Üí "Gratis GTA+"
                texto = re.sub(r"gr√°tis para membros do GTA\+", "Gratis GTA+", texto)  # "gr√°tis para membros do GTA+" ‚Üí "Gratis GTA+"
                
                # Ajustar a exclusividade do PS5 e Xbox Series X|S
                texto = re.sub(r"PS5 and Xbox Series X\|S only", "Exclusivo PS5 e Xbox Series X|S", texto)  # EN ‚Üí PT
                texto = re.sub(r"apenas para PS5 e Xbox Series X\|S", "Exclusivo PS5 e Xbox Series X|S", texto)  # PT ‚Üí PT formatado
                
                return texto

            # üîπ Separar os itens corretamente e formatar tudo antes de entrar no BBCode
            if " | " in gun_van_texto:
                gun_van_itens = gun_van_texto.split(" | ")  # Separar pelos " | " (com espa√ßo antes e depois)
            else:
                gun_van_itens = gun_van_texto.splitlines()  # Separar por linha caso n√£o tenha " | "

            # üîπ Aplicar a fun√ß√£o de ajustes a TODOS os itens ANTES de gerar o BBCode
            gun_van_itens = [ajustar_percentagem(item.strip()) for item in gun_van_itens if item.strip()]

            # üîπ Adicionar a lista formatada ao BBCode
            conteudo += "[List]\n"
            for item in gun_van_itens:
                conteudo += f"[*] {item}\n"
            conteudo += "[/List]\n\n"

        else:
            # Se a caixa estiver vazia, nada √© adicionado
            pass





            
            
            
            
        ######### Categoria Roubos do Ferro-Velho
        # Verificar se h√° pelo menos um ve√≠culo, um golpe ou uma sele√ß√£o de reclam√°vel para esta categoria
        def categoria_roubos_ferro_velho_valido():
            # Verificar se qualquer ve√≠culo foi preenchido ou qualquer golpe foi selecionado
            if not self.entrada_salvageyard_veiculo1.get() and not self.opcao_golpe1.get() and not self.reclamavel_veiculo1.get():
                if not self.entrada_salvageyard_veiculo2.get() and not self.opcao_golpe2.get() and not self.reclamavel_veiculo2.get():
                    if not self.entrada_salvageyard_veiculo3.get() and not self.opcao_golpe3.get() and not self.reclamavel_veiculo3.get():
                        return False  # N√£o h√° dados v√°lidos para a categoria
            return True  # Pelo menos um ve√≠culo ou golpe est√° preenchido

        # Verificar se a categoria tem algo para mostrar
        if categoria_roubos_ferro_velho_valido():
            # Adicionar o t√≠tulo da categoria de Roubos do Ferro-Velho
            categoria_roubos_ferro_velho = "Roubos do Ferro-Velho (Salvage Yard Robberies)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_roubos_ferro_velho}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Fun√ß√£o para verificar o estado do bot√£o de r√°dio e da caixa de sele√ß√£o
            def gerar_saida_roubo(veiculo_entrada, reclamavel_var, nome_golpe):
                # Inicializa a vari√°vel conteudo
                conteudo = ""

                # Lista de op√ß√µes de golpes correspondentes aos radiobuttons
                opcoes_golpe = {
                    "O Roubo do Duggan (The Duggan Robbery)": "O Roubo do Duggan (The Duggan Robbery)",
                    "O Roubo do Gangbanger (The Gangbanger Robbery)": "O Roubo do Gangbanger (The Gangbanger Robbery)",
                    "O Roubo do Cargueiro (The Cargo Ship Robbery)": "O Roubo do Cargueiro (The Cargo Ship Robbery)",
                    "O Roubo do Podio (The Podium Robbery)": "O Roubo do Podio (The Podium Robbery)",
                    "O Roubo do McTony (The McTony Robbery)": "O Roubo do McTony (The McTony Robbery)"
                }

                # Verificar se nada foi selecionado ou digitado
                if not veiculo_entrada.get() and not reclamavel_var.get() and nome_golpe not in opcoes_golpe:
                    return ""  # Retorna string vazia para ignorar a adi√ß√£o no conte√∫do

                # Se houver valores v√°lidos, come√ßa a montar o conte√∫do

                # Verificar se o bot√£o de r√°dio do golpe est√° selecionado
                if nome_golpe in opcoes_golpe:
                    conteudo += opcoes_golpe[nome_golpe]  # Apenas o nome do golpe

                # Adicionar o nome do ve√≠culo, se houver
                if veiculo_entrada.get():
                    conteudo += f" - {veiculo_entrada.get()}"

                # Verificar se √© "Reclam√°vel" e adicionar a informa√ß√£o
                if reclamavel_var.get():
                    conteudo += " [Reclam√°vel]"

                return conteudo


            # Para o Golpe 1
            saida_roubo_1 = gerar_saida_roubo(self.entrada_salvageyard_veiculo1, self.reclamavel_veiculo1, self.opcao_golpe1.get())
            if saida_roubo_1:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_1 + "\n"

            # Para o Golpe 2
            saida_roubo_2 = gerar_saida_roubo(self.entrada_salvageyard_veiculo2, self.reclamavel_veiculo2, self.opcao_golpe2.get())
            if saida_roubo_2:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_2 + "\n"

            # Para o Golpe 3
            saida_roubo_3 = gerar_saida_roubo(self.entrada_salvageyard_veiculo3, self.reclamavel_veiculo3, self.opcao_golpe3.get())
            if saida_roubo_3:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_3 + "\n\n\n\n"
                
                
                
                
        ######### Categoria Ve√≠culo do P√≥dio
        # Obter o valor da entrada de texto para o nome do ve√≠culo do p√≥dio
        nome_veiculo_podio = self.entrada_nome_veiculo_podio.get().strip()

        # Verificar se o campo de texto n√£o est√° vazio antes de gerar o c√≥digo
        if nome_veiculo_podio:  # Se houver algo na entrada
            # Adicionar o t√≠tulo da categoria de Ve√≠culo do P√≥dio
            categoria_veiculo_podio = "Ve√≠culo do P√≥dio (Podium Vehicle)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_veiculo_podio}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"{nome_veiculo_podio}"
            conteudo += "\n\n\n\n"
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ######### Novo Desafio do Encontro de Carros (LS Car Meet)
        # Obter os valores das entradas de texto
        nome_desafio_car_meet = self.entrada_nome_desafio_car_meet.get().strip()
        dias_desafio_car_meet = self.entrada_dias_desafio_car_meet.get().strip()
        recompensa_desafio_car_meet = self.entrada_recompensa_desafio_car_meet.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if nome_desafio_car_meet and dias_desafio_car_meet and recompensa_desafio_car_meet:
            # Adicionar o t√≠tulo da categoria Novo Desafio do Encontro de Carros
            categoria_car_meet = "Novo Desafio do Encontro de Carros (LS Car Meet)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_car_meet}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]"
            
            # Adicionar o conte√∫do do desafio com o formato solicitado
            conteudo += f"[b]{nome_desafio_car_meet}[/b] no Evento de Carros LS em S√©rie (LS Car Meet Series) por [b]{dias_desafio_car_meet}[/b] [b]dias seguidos[/b]\n"
            
            # Processar as recompensas
            linhas_recompensa = [linha.strip() for linha in recompensa_desafio_car_meet.splitlines() if linha.strip()]
            if len(linhas_recompensa) == 1:
                conteudo += f"[b]Pr√©mio:[/b] {linhas_recompensa[0]}"
            elif len(linhas_recompensa) == 2:
                conteudo += f"Pr√©mio: [b]{linhas_recompensa[0]}[/b] mais [b]{linhas_recompensa[1]}[/b]"
            else:
                conteudo += "[b]Pr√©mios:[/b]\n[list]\n"
                for linha in linhas_recompensa:
                    conteudo += f"[*] {linha}\n"
                conteudo += "[/list]"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ####### Categoria Test Rides
        categoria_test_rides = "Test Rides"  # Vari√°vel para armazenar o nome da categoria
        test_rides_texto = self.entrada_test_rides.get("1.0", "end-1c").strip()  # Obter o texto da entrada

        # Verificar se h√° conte√∫do na entrada
        if test_rides_texto:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_test_rides}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Dividir o texto em linhas e criar a lista
            test_rides_linhas = test_rides_texto.splitlines()
            conteudo += "[list]\n"
            for linha in test_rides_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Ignorar a categoria se n√£o houver conte√∫do
            pass
        
        
        
        
        ######### Ve√≠culo de Teste Premium:
        # Obter o valor da entrada de texto para o nome do ve√≠culo do p√≥dio
        nome_veiculo_test = self.entrada_nome_veiculo_teste_premium.get().strip()

        # Verificar se o campo de texto n√£o est√° vazio antes de gerar o c√≥digo
        if nome_veiculo_test:  # Se houver algo na entrada
            # Adicionar o t√≠tulo da categoria de Ve√≠culo do P√≥dio
            categoria_veiculo_test = "Ve√≠culo de Teste Premium"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_veiculo_test}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"{nome_veiculo_test}"
            conteudo += "\n\n\n\n"
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ######### Categoria Luxury Autos
        # Obter os valores das entradas de texto
        imagem_luxury_autos = self.entrada_imagem_luxury_autos.get().strip()
        veiculos_luxury_autos_texto = self.entrada_veiculos_luxury_autos.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if imagem_luxury_autos and veiculos_luxury_autos_texto:
            # Adicionar o t√≠tulo da categoria Luxury Autos
            categoria_luxury_autos = "Luxury Autos"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_luxury_autos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            
            # Adicionar a imagem diretamente com BBCode
            conteudo += f"[img]{imagem_luxury_autos}[/img]\n"

            # Dividir o texto em linhas e criar a lista de ve√≠culos
            veiculos_luxury_autos_linhas = veiculos_luxury_autos_texto.splitlines()
            conteudo += "[list]\n"
            for linha in veiculos_luxury_autos_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ######### Categoria Premium Deluxe Motorsport
        # Obter os valores das entradas de texto
        imagem_premium_deluxe_motorsport = self.entrada_imagem_premium_deluxe_motorsport.get().strip()
        veiculos_premium_deluxe_motorsport_texto = self.entrada_veiculos_premium_deluxe_motorsport.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if imagem_premium_deluxe_motorsport and veiculos_premium_deluxe_motorsport_texto:
            # Adicionar o t√≠tulo da categoria Premium Deluxe Motorsport
            categoria_premium_deluxe_motorsport = "Premium Deluxe Motorsport"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_premium_deluxe_motorsport}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"  # Adicionar uma linha de separa√ß√£o e nova linha
            
            # Adicionar a imagem diretamente com BBCode
            conteudo += f"[img]{imagem_premium_deluxe_motorsport}[/img]\n"

            # Dividir o texto em linhas e criar a lista de ve√≠culos
            veiculos_premium_deluxe_motorsport_linhas = veiculos_premium_deluxe_motorsport_texto.splitlines()
            conteudo += "[list]\n"
            for linha in veiculos_premium_deluxe_motorsport_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ######### Categoria Corrida Premium
        # Obter o valor da entrada de texto
        nome_corrida_premium = self.entrada_nome_corrida_premium.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_corrida_premium:
            # Adicionar o t√≠tulo da categoria Corrida Premium
            categoria_corrida_premium = "Corrida Premium"
            conteudo += "[hr][/hr]\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_corrida_premium}:[/color][/size][/b]\n"
            conteudo += f"{nome_corrida_premium}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio
        # Obter o valor da entrada de texto
        nome_contra_relogio = self.entrada_nome_contra_relogio.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio
            categoria_contra_relogio = "Contra Rel√≥gio"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio HSW
        # Obter o valor da entrada de texto
        nome_contra_relogio_hsw = self.entrada_nome_contra_relogio_hsw.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio_hsw:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio HSW
            categoria_contra_relogio_hsw = "Contra Rel√≥gio HSW"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio_hsw}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio_hsw}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio RC
        # Obter o valor da entrada de texto
        nome_contra_relogio_rc = self.entrada_nome_contra_relogio_rc.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio_rc:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio RC
            categoria_contra_relogio_rc = "Contra Rel√≥gio RC"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio_rc}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio_rc}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ####### Categoria GTA+:
        conteudo += """
[hr][/hr]
[img]https://media-rockstargames-com.akamaized.net/mfe6/prod/__common/img/7563ed0414306d18d4f8401effcab31a.svg[/img]

[list][b][u]Gr√°tis [/u][/b]
[list]
[*]Vapid Dominator GT
[*]Bon√© e a Jaqueta Varsity LS Panic (LS Panic Varsity Jacket and Cap)
[/list]
[/list]

[list][b][u]Novo Conteudo[/u][/b]
[list]
[*]Novas Pinturas Camale√£o (Chameleon Paints)
[*]Bon√© e a Jaqueta Varsity LS Panic (LS Panic Varsity Jacket and Cap)
[/list]
[/list]

[list][b][u]Bonus de Recompensas[/u][/b]
[list]
[*]Dossi√™s do FIB Priorit√°rios  (Priority FIB Files) - 2x GTA$ e RP
[/list]
[/list]

Acesso a garagem do [b]Vinewood Club para 100 veiculos,[/b] completa com [b]Oficina (Vehicle Workshop) e inclui  Melhorias do Hao‚Äôs Special Works (Hao‚Äôs Special Works Upgrades), Convers√µes do Benny (Benny's Conversions), Drift Tuning[/b], e mais.
[img]https://media-rockstargames-com.akamaized.net/tina-uploads/posts/4kk9o9a811o27k/04a1ba4148f83c7cc5e325197964e527dd620b20.jpg[/img]
"""




        ######### Categoria Mais Info
        # Obter o valor da entrada de texto
        descricao_mais_info = self.entrada_descricao_mais_info.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if descricao_mais_info:
            # Adicionar o t√≠tulo da categoria Mais Info
            categoria_mais_info = "Mais Info"
            conteudo += "\n\n\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_mais_info}:[/color][/size][/b]\n"
            conteudo += f"{descricao_mais_info}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        
        




        



        # Criar a janela de preview
        preview_window = tk.Toplevel(self.root)
        preview_window.title("Preview BBCode")
        preview_window.geometry("600x400")

        # √Årea de texto para o preview
        preview_text = tk.Text(preview_window, wrap=tk.WORD)
        preview_text.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)

        # Inserir o conte√∫do gerado na √°rea de texto
        preview_text.insert('1.0', conteudo)

        # Fun√ß√£o para selecionar todo o c√≥digo e copiar para a √°rea de transfer√™ncia
        def select_and_copy():
            preview_text.tag_add("sel", "1.0", "end")  # Seleciona todo o texto
            preview_text.clipboard_clear()  # Limpa a √°rea de transfer√™ncia
            preview_text.clipboard_append(preview_text.get('1.0', 'end-1c'))  # Adiciona o texto √† √°rea de transfer√™ncia
            preview_text.update()  # Atualiza a √°rea de texto para garantir que o conte√∫do foi copiado corretamente
            
        # Criar o bot√£o "Selecionar todo o c√≥digo"
        select_button = tk.Button(preview_window, text="Copiar o BBCode", command=select_and_copy)

        # Adicionar o bot√£o na segunda linha (alinhado ao centro, no fundo)
        select_button.grid(row=1, column=0, pady=10)

        # Configura√ß√£o para fazer o layout responsivo, permitindo que o texto ocupe o restante da janela
        preview_window.grid_rowconfigure(0, weight=1)  # O texto vai se expandir
        preview_window.grid_columnconfigure(0, weight=1)  # O texto vai se expandir
        
        
        


        def abrir_gerar_titulo():
            # C√°lculo das datas
            hoje = datetime.date.today()

            # Verificar se hoje √© quinta-feira
            if hoje.weekday() == 3:  # 3 representa a quinta-feira
                inicio_semana = hoje
            else:
                # Se n√£o for quinta-feira, vamos calcular a quinta-feira passada
                dias_ate_quinta = (hoje.weekday() - 3) % 7
                inicio_semana = hoje - datetime.timedelta(days=dias_ate_quinta)

            # A data final √© na pr√≥xima quarta-feira
            fim_semana = inicio_semana + datetime.timedelta(days=6)

            # Formato das datas
            data_inicio = inicio_semana.strftime("%d/%m")
            data_fim = fim_semana.strftime("%d/%m")

            # Criar a janela de gerar t√≠tulo
            gerar_titulo_window = tk.Toplevel(preview_window)
            gerar_titulo_window.title("Gerar T√≠tulo")
            gerar_titulo_window.geometry("500x300")

            # Frame para as op√ß√µes de atividades
            frame_atividades = ttk.LabelFrame(gerar_titulo_window, text="Atividades de B√¥nus GTA$ e RP")
            frame_atividades.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)

            opcao_selecionada = tk.StringVar(value="Outro")

            # Ler as atividades da caixa de texto self.entrada_nome_atividades_gta_rp
            atividades = self.entrada_nome_atividades_gta_rp.get("1.0", "end-1c").splitlines()  # L√™ as linhas da caixa de texto

            # Se houver atividades, criar os radiobuttons
            if atividades and atividades != ['']:
                for idx, atividade in enumerate(atividades):
                    ttk.Radiobutton(frame_atividades, text=atividade, variable=opcao_selecionada, value=atividade).pack(anchor="w")

                # Garantir que o primeiro radiobutton esteja selecionado por padr√£o
                opcao_selecionada.set(atividades[0])

                # Adicionar a op√ß√£o "Outro"
                ttk.Radiobutton(frame_atividades, text="Outro", variable=opcao_selecionada, value="Outro").pack(anchor="w")
                entrada_outro = ttk.Entry(frame_atividades)
                entrada_outro.pack(fill="x", padx=10, pady=5)

            else:
                # Caso n√£o haja atividades, mostrar apenas "Outro"
                ttk.Radiobutton(frame_atividades, text="Outro", variable=opcao_selecionada, value="Outro").pack(anchor="w")
                entrada_outro = ttk.Entry(frame_atividades)
                entrada_outro.pack(fill="x", padx=10, pady=5)

            # Fun√ß√£o para gerar o t√≠tulo
            def gerar_titulo():
                atividade = entrada_outro.get() if opcao_selecionada.get() == "Outro" else opcao_selecionada.get()
                titulo = f"GTA ONLINE - EVENTO SEMANAL - {atividade} | {data_inicio}-{data_fim}"

                # Exibir o t√≠tulo em uma caixa de texto edit√°vel
                titulo_text.delete("1.0", "end")  # Limpar conte√∫do existente
                titulo_text.insert("1.0", titulo)  # Inserir o t√≠tulo gerado

            # Caixa de texto para exibir e editar o t√≠tulo gerado
            titulo_text = tk.Text(gerar_titulo_window, height=3, wrap=tk.WORD)
            titulo_text.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

            # Bot√£o "Gerar T√≠tulo"
            gerar_button = ttk.Button(gerar_titulo_window, text="Gerar", command=gerar_titulo)
            gerar_button.grid(row=2, column=0, pady=10)

            # Configura√ß√£o para fazer o layout responsivo
            gerar_titulo_window.grid_rowconfigure(0, weight=1)  # O frame de atividades vai se expandir
            gerar_titulo_window.grid_rowconfigure(1, weight=1)  # A caixa de texto vai se expandir
            gerar_titulo_window.grid_rowconfigure(2, weight=0)  # O bot√£o de gerar t√≠tulo n√£o precisa expandir
            gerar_titulo_window.grid_columnconfigure(0, weight=1)  # A coluna vai se expandir

        # Bot√£o "Gerar T√≠tulo" na janela de preview (fora da fun√ß√£o)
        gerar_titulo_button = tk.Button(preview_window, text="Gerar T√≠tulo", command=abrir_gerar_titulo)
        gerar_titulo_button.grid(row=1, column=0, pady=10, padx=10, sticky="w")



    
    def associar_botao_filtro(self, entrada):
        """Vincula a entrada ao evento FocusOut, registra os filtros corretamente e adiciona bot√£o de filtro."""

        entrada_id = str(entrada)  # Usamos o identificador de string para evitar erros no JSON

        # ‚ö†Ô∏è Se a entrada ainda n√£o tem filtros atribu√≠dos, copia os filtros corretos
        if entrada_id not in self.filtros_por_entrada or not self.filtros_por_entrada[entrada_id]:
            self.filtros_por_entrada[entrada_id] = self.opcoes_filtro.copy()
        

        # Garante que o evento FocusOut chame aplicar_filtros corretamente
        entrada.bind("<FocusOut>", lambda event: self.aplicar_filtros(event, entrada))

        # Manter a l√≥gica original do bot√£o de filtro
        if not hasattr(self, "botoes_filtros"):  # Garante que a estrutura exista
            self.botoes_filtros = {}

        frame = entrada.master  # Obt√©m o frame onde a caixa de texto est√°
        info_grid = entrada.grid_info()  # Obt√©m as informa√ß√µes de posi√ß√£o da caixa

        if info_grid:  # Certifica que a entrada est√° posicionada no grid
            row = info_grid["row"]  # Pega a linha onde a entrada est√°

            # Criar e posicionar o bot√£o de filtro na mesma linha
            botao_filtro = ttk.Button(
                frame,
                text="üîç",
                width=5,
                command=lambda: self.abrir_filtros(entrada)
            )
            botao_filtro.grid(row=row, column=1, padx=5, pady=5, sticky="w")

            # Armazena o bot√£o de filtro para refer√™ncia futura
            self.botoes_filtros[entrada_id] = botao_filtro




    def abrir_filtros(self, entrada_associada):
        print("\n--- ABRINDO JANELA DE FILTROS ---")

        self.janela_filtros = tk.Toplevel(self.root)
        self.janela_filtros.title("Selecionar Filtros")
        self.janela_filtros.geometry("450x500")
        
        entrada_id = str(entrada_associada)
        filtros_entrada = self.filtros_por_entrada.get(entrada_id, self.opcoes_filtro.copy())

        print(f"Entrada associada: {entrada_associada}")
        print("Estado inicial dos filtros:", self.opcoes_filtro)
        print(f"Estado inicial dos filtros: {filtros_entrada}")

        self.janela_filtros.transient(self.root)
        self.janela_filtros.focus_set()

        frame_principal = ttk.Frame(self.janela_filtros, padding=10)
        frame_principal.grid(row=0, column=0, sticky="nsew")

        self.janela_filtros.columnconfigure(0, weight=1)
        self.janela_filtros.rowconfigure(1, weight=1)

        self.filtros_selecionados = {}
        self.opcoes_vars = {}

        self.select_all_var = tk.BooleanVar(value=True)
        self.master_option_var = tk.IntVar(value=2)

        frame_controle = ttk.Frame(frame_principal)
        frame_controle.grid(row=0, column=0, sticky="ew", pady=5)

        ttk.Checkbutton(frame_controle, text="Ativar/Desativar todas",
                        variable=self.select_all_var, command=self.toggle_select_all).grid(row=0, column=0, padx=2, sticky="w")

        ttk.Radiobutton(frame_controle, text="Remover Todos",
                        variable=self.master_option_var, value=1, command=self.toggle_master_remove).grid(row=0, column=1, padx=2, sticky="w")

        ttk.Radiobutton(frame_controle, text="Traduzir Todos",
                        variable=self.master_option_var, value=2, command=self.toggle_master_translate).grid(row=0, column=2, padx=2, sticky="w")

        frame_categorias = ttk.Frame(frame_principal)
        frame_categorias.grid(row=1, column=0, sticky="nsew", pady=5)

        frame_categorias.grid_columnconfigure(0, weight=1)
        frame_categorias.grid_columnconfigure(1, weight=1)
        frame_categorias.grid_columnconfigure(2, weight=1)

        caminho_base_dados = self.caminho_default()
        if os.path.exists(caminho_base_dados):
            with open(caminho_base_dados, 'r', encoding='utf-8') as f:
                self.base_dados = json.load(f)
        else:
            messagebox.showwarning("Erro", "Arquivo base_dados.json n√£o encontrado.")
            self.base_dados = {}

        categorias = list(self.base_dados.keys()) if self.base_dados else []

        print("Categorias carregadas:", categorias)

        for i, categoria in enumerate(categorias):
            var = tk.BooleanVar(value=True)
            opcao_var = tk.IntVar(value=self.opcoes_filtro.get(categoria, 2)) 

            print(f"  üîπ Categoria: {categoria} | Estado salvo: {self.opcoes_filtro.get(categoria, 2)}")

            frame_categoria = ttk.Frame(frame_categorias)
            frame_categoria.grid(row=i, column=0, sticky="w", pady=1)

            chk = ttk.Checkbutton(frame_categoria, variable=var)
            chk.grid(row=0, column=0, padx=2, sticky="w")

            label_categoria = ttk.Label(frame_categoria, text=categoria, font=("Arial", 10, "bold"))
            label_categoria.grid(row=0, column=1, padx=2, sticky="w")

            botao_abrir_categoria = ttk.Button(frame_categoria, text="üìÇ", width=3,
                                            command=lambda cat=categoria: self.abrir_base_dados_categoria(cat))
            botao_abrir_categoria.grid(row=0, column=2, padx=2, sticky="w")

            remover_radio = ttk.Radiobutton(frame_categorias, variable=opcao_var, text="Remover",
                                            value=1, command=self.update_master_status)
            remover_radio.grid(row=i, column=1, padx=2, sticky="w")

            traduzir_radio = ttk.Radiobutton(frame_categorias, variable=opcao_var, text="Traduzir",
                                            value=2, command=self.update_master_status)
            traduzir_radio.grid(row=i, column=2, padx=2, sticky="w")

            self.filtros_selecionados[categoria] = var
            self.opcoes_vars[categoria] = opcao_var

        frame_botao = ttk.Frame(frame_principal)
        frame_botao.grid(row=2, column=0, pady=10, sticky="sew")

        btn_guardar = ttk.Button(
            frame_botao, text="Aplicar Filtros",
            command=lambda: self.guardar_selecao_filtros(entrada_associada), width=20
        )
        btn_guardar.grid(row=0, column=0, pady=5)

        frame_botao.grid_columnconfigure(0, weight=1, uniform="equal")
        frame_botao.grid_rowconfigure(0, weight=1)

        self.janela_filtros.protocol("WM_DELETE_WINDOW", self.janela_filtros.destroy)
        print(f"Filtros antes de salvar para {entrada_id}: {self.filtros_por_entrada}")


    def guardar_selecao_filtros(self, entrada_associada):
        if not entrada_associada:
            messagebox.showerror("Erro", "Nenhuma caixa de texto associada!")
            return

        entrada_id = str(entrada_associada)
        
        if entrada_id not in self.filtros_por_entrada:
            self.filtros_por_entrada[entrada_id] = {}

        for categoria, var in self.filtros_selecionados.items():
            estado_checkbox = var.get()
            estado_radio = self.opcoes_vars[categoria].get()
            self.filtros_por_entrada[entrada_id][categoria] = estado_radio if estado_checkbox else 2  # Traduzir como padr√£o


        print(f"Filtros salvos para {entrada_id}: {self.filtros_por_entrada[entrada_id]}")  # Depura√ß√£o
        self.salvar_preferencias()
        self.janela_filtros.destroy()
        self.aplicar_filtros(None, entrada_associada)  # Aplica os filtros ap√≥s salvar


    def update_master_status(self):
        """Atualiza os estados dos bot√µes mestres com base nas sele√ß√µes atuais."""
        remover_todos = all(var.get() == 1 for var in self.opcoes_vars.values())
        traduzir_todos = all(var.get() == 2 for var in self.opcoes_vars.values())

        if remover_todos:
            self.master_option_var.set(1)
        elif traduzir_todos:
            self.master_option_var.set(2)
        else:
            self.master_option_var.set(0)  # Estado misto


    def toggle_master_remove(self):
        """Ativa 'Remover Todos', sem apagar sele√ß√µes individuais."""
        for cat, opcao_var in self.opcoes_vars.items():
            if opcao_var.get() == 2:  # Se estiver em "Traduzir", troca para "Remover"
                opcao_var.set(1)

    def toggle_master_translate(self):
        """Ativa 'Traduzir Todos', sem apagar sele√ß√µes individuais."""
        for cat, opcao_var in self.opcoes_vars.items():
            if opcao_var.get() == 1:  # Se estiver em "Remover", troca para "Traduzir"
                opcao_var.set(2)



    def toggle_select_all(self):
        """Seleciona ou desseleciona todas as categorias."""
        estado = self.select_all_var.get()
        for var in self.filtros_selecionados.values():
            var.set(estado)

    def on_category_click(self):
        """Callback para clique em uma categoria individual."""
        # Atualiza l√≥gica adicional conforme necess√°rio ao clicar numa categoria
        pass

    def obter_texto_label(self, parent, nome_label):
        """Obt√©m o texto de um Label dado seu identificador."""
        for widget in parent.winfo_children():
            if isinstance(widget, ttk.Label) and widget.winfo_name() == nome_label:
                return widget.cget("text")
        return "Sem T√≠tulo"  # Caso n√£o encontre o label correspondente

    def abrir_base_dados_categoria(self, categoria):
        """Abre a base de dados e rola at√© a categoria especificada."""
        print(f"Abrindo a base de dados para a categoria: {categoria}")  # Depura√ß√£o para garantir que estamos passando a categoria correta
        self.abrir_base_dados()  # Abre a base de dados

        # Esperar a GUI carregar antes de rolar
        self.root.after(500, lambda: self.rolar_para_categoria(categoria))
        
        """Abre a base de dados com a categoria especificada expandida."""
        if categoria not in self.base_dados:
            messagebox.showinfo("Aviso", f"A categoria '{categoria}' n√£o existe.")
            return
        # Exibir dados da categoria corretamente
        print(f"Expandindo a categoria: {categoria}")
    def rolar_para_categoria(self, categoria):
        """Rola para a categoria especificada e expande apenas ela."""
        
        # Fecha todas as categorias antes de abrir a correta
        for cat in list(self.categoria_expandidas.keys()):
            if self.categoria_expandidas.get(cat, False) and cat != categoria:
                self.toggle_categoria_frame(cat)  # Fecha categorias abertas

        # Expande apenas a categoria desejada, se existir
        if categoria in self.base_dados:
            if not self.categoria_expandidas.get(categoria, False):  # Garante que s√≥ expande se estiver fechada
                self.toggle_categoria_frame(categoria)  

            # Rola para a categoria correta no Canvas, se aplic√°vel
            frame_nome = f"frame_{categoria}"
            if hasattr(self, frame_nome):
                frame = getattr(self, frame_nome)
                self.root.after(100, lambda: self.canvas_bd.yview_moveto(frame.winfo_y() / self.canvas_bd.winfo_height()))
            
            print(f"Rolando para a categoria: {categoria}")
        else:
            print(f"Categoria {categoria} n√£o existe.")









    def aplicar_filtros(self, event, entrada):
        """Aplica os filtros quando o Entry ou Text perde o foco ou uma tecla √© liberada, evitando substitui√ß√µes repetidas."""
        print("\n--- APLICANDO FILTROS AO PERDER O FOCO OU TECLA SOLTA ---")

        entrada_id = str(entrada)
        if entrada_id not in self.filtros_por_entrada or not self.filtros_por_entrada[entrada_id]:
            print("‚ùå Nenhum filtro ativo para essa entrada!")
            return

        filtros = self.filtros_por_entrada[entrada_id]
        print(f"üìå Filtros aplicados: {filtros}")

        texto = entrada.get("1.0", "end-1c").strip() if isinstance(entrada, tk.Text) else entrada.get().strip()
        print(f"üîπ Texto original: {texto}")

        texto_alterado = False
        linhas = texto.split("\n")

        for i, linha in enumerate(linhas):
            termos_substituidos = set()  # Controla quais termos j√° foram substitu√≠dos

            for categoria, acao in filtros.items():
                conteudos = sorted(self.base_dados.get(categoria, []), key=lambda x: -len(x[0]))  # Ordena por tamanho maior primeiro

                for pt, en, pt_en in conteudos:
                    pt_pattern = re.escape(pt)
                    en_pattern = re.escape(en)

                    # **Se a linha j√° cont√©m pt_en, N√ÉO faz mais nada**
                    if pt_en in linha:
                        continue  

                    # **SUBSTITUIR APENAS PELO `pt_en` DA BASE DE DADOS**
                    if acao == 2:  # Traduzir
                    for pt, en, pt_en in conteudos:
                        if pt_en in linha:
                            continue  # J√° est√° traduzido

                        if re.search(rf"\b{pt_pattern}\b", linha, re.IGNORECASE) or re.search(rf"\b{en_pattern}\b", linha, re.IGNORECASE):
                            linha = re.sub(rf"\b{pt_pattern}\b", pt_en, linha, flags=re.IGNORECASE)
                            linha = re.sub(rf"\b{en_pattern}\b", pt_en, linha, flags=re.IGNORECASE)
                            texto_alterado = True

                            termos_substituidos.add(pt_en)  # Marca que este termo j√° foi substitu√≠do
                            break  # **Sai do loop para evitar tradu√ß√µes menores**

                    elif acao == 1:  # Remover
                        if re.search(rf"\b{pt_pattern}\b", linha, re.IGNORECASE) or re.search(rf"\b{en_pattern}\b", linha, re.IGNORECASE):
                            linha = re.sub(rf"\b{pt_pattern}\b", "", linha, flags=re.IGNORECASE)
                            linha = re.sub(rf"\b{en_pattern}\b", "", linha, flags=re.IGNORECASE)
                            texto_alterado = True
                            termos_substituidos.add(pt)
                            termos_substituidos.add(en)

                linhas[i] = linha  # Atualiza a linha com as modifica√ß√µes feitas

        # Limpeza final para evitar par√™nteses vazios
        texto_modificado = "\n".join(linhas).replace("() ", "").replace(" ()", "").replace("()", "")

        if texto_alterado:
            if isinstance(entrada, tk.Text):
                entrada.delete("1.0", "end")
                entrada.insert("1.0", texto_modificado)
            elif isinstance(entrada, tk.Entry):
                entrada.delete(0, "end")
                entrada.insert(0, texto_modificado)
            print(f"‚úÖ Texto modificado: {texto_modificado}")
        else:
            print("‚ö†Ô∏è Nenhuma altera√ß√£o necess√°ria.")










        
        
        
        
        
    def configurar_eventos(self, entrada):
        """Configura os eventos de FocusOut ou KeyRelease para os widgets apropriados."""
        if isinstance(entrada, tk.Entry):
            entrada.bind("<FocusOut>", lambda event: self.aplicar_filtros(event, entrada))
        elif isinstance(entrada, tk.Text):
            entrada.bind("<KeyRelease>", lambda event: self.aplicar_filtros(event, entrada))

    def aplicar_filtros(self, event, entrada):
        """Aplica os filtros quando o Entry ou Text perde o foco ou uma tecla √© liberada, sem duplica√ß√µes."""
        print("\n--- APLICANDO FILTROS AO PERDER O FOCO OU TECLA SOLTA ---")

        entrada_id = str(entrada)
        if entrada_id not in self.filtros_por_entrada or not self.filtros_por_entrada[entrada_id]:
            print("‚ùå Nenhum filtro ativo para essa entrada!")
            return

        filtros = self.filtros_por_entrada[entrada_id]
        print(f"üìå Filtros aplicados: {filtros}")

        texto = entrada.get("1.0", "end-1c").strip() if isinstance(entrada, tk.Text) else entrada.get().strip()
        print(f"üîπ Texto original: {texto}")

        texto_alterado = False
        linhas = texto.split("\n")

        for i, linha in enumerate(linhas):
            termos_modificados = set()  # Controla quais termos j√° foram alterados

            for categoria, acao in filtros.items():
                conteudos = sorted(self.base_dados.get(categoria, []), key=lambda x: len(x[0]), reverse=True)

                for pt, en, pt_en in conteudos:
                    pt_pattern = re.escape(pt)
                    en_pattern = re.escape(en)

                    # **SUBSTITUIR APENAS PELO VALOR `pt_en` DA BASE DE DADOS**
                    if acao == 2:  # Traduzir
                        # Se encontrar `pt`, substituir por `pt_en` da base de dados
                        if re.search(rf"\b{pt_pattern}\b", linha, re.IGNORECASE):
                            if pt_en not in linha:  # Evita duplica√ß√£o
                                linha = re.sub(rf"\b{pt_pattern}\b", pt_en, linha, flags=re.IGNORECASE)
                                texto_alterado = True
                                termos_modificados.add(pt)

                        # Se encontrar `en`, substituir por `pt_en` da base de dados
                        if re.search(rf"\b{en_pattern}\b", linha, re.IGNORECASE):
                            if pt_en not in linha:  # Evita duplica√ß√£o
                                linha = re.sub(rf"\b{en_pattern}\b", pt_en, linha, flags=re.IGNORECASE)
                                texto_alterado = True
                                termos_modificados.add(en)

                    elif acao == 1:  # Remover
                        if re.search(rf"\b{pt_pattern}\b", linha, re.IGNORECASE) or re.search(rf"\b{en_pattern}\b", linha, re.IGNORECASE):
                            linha = re.sub(rf"\b{pt_pattern}\b", "", linha, flags=re.IGNORECASE)
                            linha = re.sub(rf"\b{en_pattern}\b", "", linha, flags=re.IGNORECASE)
                            texto_alterado = True
                            termos_modificados.add(pt)
                            termos_modificados.add(en)

                linhas[i] = linha  # Atualiza a linha com as modifica√ß√µes feitas

        # Limpeza final para evitar par√™nteses vazios
        texto_modificado = "\n".join(linhas).replace("() ", "").replace(" ()", "").replace("()", "")

        if texto_alterado:
            if isinstance(entrada, tk.Text):
                entrada.delete("1.0", "end")
                entrada.insert("1.0", texto_modificado)
            elif isinstance(entrada, tk.Entry):
                entrada.delete(0, "end")
                entrada.insert(0, texto_modificado)
            print(f"‚úÖ Texto modificado: {texto_modificado}")
        else:
            print("‚ö†Ô∏è Nenhuma altera√ß√£o necess√°ria.")










        
    def aplicar_filtros_remocao(self, event=None):
        """Aplica os filtros selecionados ao perder o foco da caixa de texto."""
        if not hasattr(self, "filtros_selecionados"):
            return  # Nenhum filtro foi definido

        # Obter o texto atual da caixa de entrada
        texto = self.entrada_novos_veiculos.get("1.0", tk.END).strip()

        # Obter os filtros selecionados
        filtros_ativos = [cat for cat, var in self.filtros_selecionados.items() if var.get()]
        if not filtros_ativos:
            return  # Nenhum filtro ativo, sair

        removidos = []  # Armazenar o que foi removido
        for categoria in filtros_ativos:
            if categoria not in self.base_dados:
                continue  # Categoria inv√°lida, ignorar

            # Verificar os conte√∫dos dentro da categoria
            conteudos = [item[0].lower() for item in self.base_dados[categoria]]
            for conteudo in conteudos:
                ocorrencias = re.findall(rf"\b{re.escape(conteudo)}\b", texto, flags=re.IGNORECASE)
                if ocorrencias:
                    removidos.append((conteudo, len(ocorrencias)))
                    texto = re.sub(rf"\b{re.escape(conteudo)}\b", "", texto, flags=re.IGNORECASE)

        # Atualizar o conte√∫do do campo de texto
        self.entrada_novos_veiculos.delete("1.0", tk.END)
        self.entrada_novos_veiculos.insert("1.0", texto.strip())

        # Exibir mensagem de aviso
        if removidos:
            mensagem = "Os seguintes itens foram removidos com base nos filtros selecionados:\n"
            for conteudo, quantidade in removidos:
                mensagem += f"- {conteudo}: {quantidade} ocorr√™ncia(s)\n"

            # Mostrar a mensagem
            messagebox.showinfo("Filtros Aplicados", mensagem)

        





    

    

    
    
    




    
    
    
    
    def run(self):
        """Inicia a aplica√ß√£o"""
        self.configurar_scroll()
        self.criar_caixas_texto()
        self.criar_botao_gerar()  # Chama o m√©todo para criar o bot√£o
        self.root.mainloop()

if __name__ == "__main__":
    
    app = GTAptWindow()
    app.run()

¬´
