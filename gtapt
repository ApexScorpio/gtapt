import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
from PIL import Image, ImageTk
import requests
from io import BytesIO
import traceback
import re
from tkinter.filedialog import asksaveasfilename
from tkinter.filedialog import askopenfilename
from tkinter.filedialog import askdirectory
import json
import datetime
import os







class GTAptWindow:
    def __init__(self):
        # Cria√ß√£o da p√°gina root
        self.root = tk.Tk()
        self.root.title("GTApt - Gerador de Texto BBCode")
        self.root.geometry("800x600")
        
        self.root.bind("<Control-f>", self.abrir_janela_busca)
        self.root.bind("<Control-l>", self.abrir_janela_busca)
        self.configurar_atalhos_busca(self.root)
        # Cria a barra de menu
        self.criar_barra_menu()
        

        
        self.caminho_base_dados = tk.StringVar(value=self.caminho_default())
        self.base_dados = {}  # Inicializa a vari√°vel self.base_dados aqui
        self.carregar_preferencias()
        
        self.frame_base_dados = ttk.Frame(self.root)
        self.frame_base_dados.grid(row=1, column=0, sticky="nsew")
        self.resultados = []  # Inicializa como lista vazia
        self.resultado_atual = -1  # Nenhum resultado selecionado inicialmente
        
    
        self.root.protocol("WM_DELETE_WINDOW", self.salvar_antes_de_sair)


        self.categoria_expandidas = {}  # Dicion√°rio para armazenar categorias expandidas
        self.opcoes_filtro = {}  
        self.filtros_por_entrada = {}
        self.filtros_vars = {}
        self.caixas_texto = []
        

        # Outras configura√ß√µes da interface
        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=1)
        self.criar_abas()
        self.criar_abas_notebook()
        
        
        

            
    def configurar_diretorio_base_dados(self):
        # Garante que o diret√≥rio e o arquivo base_dados.json estejam configurados corretamente
        caminho = self.caminho_base_dados.get()
        if not os.path.exists(os.path.dirname(caminho)):
            os.makedirs(os.path.dirname(caminho))  # Cria o diret√≥rio, se necess√°rio

    
    def criar_barra_menu(self):
        menu_bar = tk.Menu(self.root)
        menu_base_dados = tk.Menu(menu_bar, tearoff=0)
        menu_base_dados.add_command(label="Abrir Base de Dados", command=self.abrir_base_dados)
        menu_bar.add_cascade(label="Base de Dados", menu=menu_base_dados)
        
        
        menu_mais = tk.Menu(menu_bar, tearoff=0)
        menu_mais.add_command(label="Prefer√™ncias", command=self.abrir_preferencias)
        menu_base_dados.add_command(label="Salvar Base de Dados", command=self.salvar_base_dados)
        menu_bar.add_cascade(label="Mais", menu=menu_mais)
        menu_mais.add_command(label="Buscar", command=self.abrir_janela_busca)


        self.root.config(menu=menu_bar)
    
    def abrir_preferencias(self):
        # Certifique-se de que a janela de prefer√™ncias √© uma vari√°vel de inst√¢ncia
        self.janela_pref = tk.Toplevel(self.root)
        self.janela_pref.title("Prefer√™ncias")
        self.janela_pref.geometry("500x150")

        def selecionar_pasta():
            pasta = askdirectory()  # Fun√ß√£o askdirectory chamada corretamente
            if pasta:
                self.caminho_base_dados.set(f"{pasta}/base_dados.json")
            self.janela_pref.lift()  # Garantir que a janela de prefer√™ncias continue no topo

        # Label e caixa de texto para o caminho
        ttk.Label(self.janela_pref, text="Diret√≥rio da Base de Dados:").pack(pady=10, anchor="w", padx=10)
        entrada_caminho = ttk.Entry(self.janela_pref, textvariable=self.caminho_base_dados, width=50)
        entrada_caminho.pack(padx=10, fill="x")

        # Bot√£o para selecionar a pasta
        botao_selecionar = ttk.Button(self.janela_pref, text="Selecionar Pasta", command=selecionar_pasta)
        botao_selecionar.pack(pady=10, padx=10, anchor="e")

        # Fun√ß√£o para salvar as prefer√™ncias
        def salvar_preferencias():
            try:
                print("Valores antes de salvar:", {k: v.get() for k, v in self.filtros_vars.items()})  # Debug
                self.salvar_preferencias()  # Salvar as prefer√™ncias
                print("Prefer√™ncias salvas com sucesso.")
                self.janela_pref.destroy()  # Fechar a janela de prefer√™ncias ap√≥s salvar
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao salvar as prefer√™ncias: {e}")


        ttk.Button(self.janela_pref, text="Salvar", command=salvar_preferencias).pack(pady=10, anchor="e", padx=10)

    def obter_caminho_preferencias(self):
        """Obt√©m o caminho para o arquivo de prefer√™ncias (mesmo local que o execut√°vel)."""
        return os.path.join(os.path.dirname(os.path.abspath(__file__)), "preferencias.json")  
    
    def carregar_preferencias(self):
        """Carrega as prefer√™ncias salvas e restaura os filtros."""
        print("\n--- CARREGANDO PREFER√äNCIAS ---")
        
        try:
            with open(self.obter_caminho_preferencias(), "r", encoding="utf-8") as arquivo:
                preferencias = json.load(arquivo)

            print(json.dumps(preferencias, indent=4, ensure_ascii=False))

            self.opcoes_filtro = preferencias.get("opcoes_filtro", {})

            for categoria, estado in self.opcoes_filtro.items():
                print(f"üîÑ Categoria: {categoria} | Estado Restaurado: {estado}")

        except FileNotFoundError:
            print("‚ùå Arquivo de prefer√™ncias n√£o encontrado. Usando valores padr√£o.")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao carregar prefer√™ncias: {e}")







    def salvar_preferencias(self):
        """Salva as prefer√™ncias no arquivo JSON."""
        caminho_preferencias = self.obter_caminho_preferencias()

        preferencias = {
            "opcoes_filtro": self.opcoes_filtro
        }

        print("\n--- SALVANDO PREFER√äNCIAS ---")
        print(json.dumps(preferencias, indent=4, ensure_ascii=False))

        try:
            with open(caminho_preferencias, "w", encoding="utf-8") as arquivo:
                json.dump(preferencias, arquivo, indent=4, ensure_ascii=False)
            print("‚úÖ Prefer√™ncias salvas com sucesso!")
        except Exception as e:
            messagebox.showerror("Erro", f"Erro ao salvar prefer√™ncias: {e}")


        print("‚úÖ Prefer√™ncias salvas com sucesso.")
    
    
    def caminho_default(self):
        # Caminho padr√£o para o arquivo base_dados.json em "Documentos\GTApt Gestor BBcode"
        documentos = os.path.expanduser("~\\Documents")
        caminho_base = os.path.join(documentos, "GTApt Gestor BBcode")
        if not os.path.exists(caminho_base):
            os.makedirs(caminho_base)  # Cria o diret√≥rio se n√£o existir
        return os.path.join(caminho_base, "base_dados.json")
    
    def ajustar_altura_texto(self, widget):
        widget.update_idletasks()
        num_linhas = int(widget.index('end-1c').split('.')[0])  # Contar linhas no TextBox
        largura_maxima = max(len(linha) for linha in widget.get("1.0", "end-1c").split("\n"))  # Calcular largura
        widget.configure(height=num_linhas, width=largura_maxima)

    
    def abrir_base_dados(self):
        """ Abre a janela da base de dados com suporte √† rolagem din√¢mica, evitando recarregamento desnecess√°rio."""
        if hasattr(self, 'janela_bd') and self.janela_bd.winfo_exists():
            self.janela_bd.lift()
            return
        
        self.janela_bd = tk.Toplevel(self.root)
        self.janela_bd.title("Base de Dados")
        self.janela_bd.geometry("800x600")
        self.configurar_atalhos_busca(self.janela_bd)
        
        self.janela_bd.bind_all("<MouseWheel>", lambda e: self.canvas_bd.yview_scroll(-1 * (e.delta // 120), "units"))

        self.frame_resultados = ttk.Frame(self.janela_bd)
        self.frame_resultados.grid(row=1, column=0, sticky="nsew")
        self.frame_resultados.grid_remove()

        self.janela_bd.grid_rowconfigure(1, weight=1)
        self.janela_bd.grid_columnconfigure(0, weight=1)
        self.frame_resultados.grid_rowconfigure(0, weight=1)
        self.frame_resultados.grid_columnconfigure(0, weight=1)
        self.janela_bd.transient(self.root)
        self.janela_bd.focus_set()

        frame_pesquisa = ttk.Frame(self.janela_bd)
        frame_pesquisa.grid(row=0, column=0, sticky="ew")

        caixa_texto = ttk.Entry(frame_pesquisa)
        caixa_texto.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        caixa_texto.bind("<KeyRelease>", lambda e: self.realizar_pesquisa(caixa_texto.get()))
        caixa_texto.bind("<Button-3>", lambda e, widget=caixa_texto: self.criar_menu_contexto(e, widget))
        caixa_texto.focus_set()

        botao_pesquisar = ttk.Button(frame_pesquisa, text="Pesquisar")
        botao_pesquisar.grid(row=0, column=1, padx=5, pady=5, sticky="w")
        frame_pesquisa.columnconfigure(2, weight=1)

        botao_criar_categoria = ttk.Button(frame_pesquisa, text="Criar Categoria", command=self.criar_nova_categoria)
        botao_criar_categoria.grid(row=0, column=3, padx=5, pady=5, sticky="e")

        frame_corpo_bd = ttk.Frame(self.janela_bd)
        frame_corpo_bd.grid(row=1, column=0, sticky="nsew")

        self.canvas_bd = tk.Canvas(frame_corpo_bd)
        scrollbar_bd = ttk.Scrollbar(frame_corpo_bd, orient="vertical", command=self.canvas_bd.yview)
        scrollable_frame_bd = ttk.Frame(self.canvas_bd)

        scrollable_frame_bd.bind(
            "<Configure>",
            lambda e: self.canvas_bd.configure(scrollregion=self.canvas_bd.bbox("all"))
        )

        self.canvas_bd.create_window((0, 0), window=scrollable_frame_bd, anchor="nw")
        self.canvas_bd.configure(yscrollcommand=scrollbar_bd.set)

        self.canvas_bd.grid(row=0, column=0, sticky="nsew")
        scrollbar_bd.grid(row=0, column=1, sticky="ns")

        frame_corpo_bd.grid_rowconfigure(0, weight=1)
        frame_corpo_bd.grid_columnconfigure(0, weight=1)

        self.frame_base_dados = scrollable_frame_bd

        """Carrega a base de dados do arquivo e garante que os dados sejam lidos corretamente."""
        caminho = self.caminho_base_dados.get()
        print(f"üìÇ Tentando carregar base de dados do arquivo: {caminho}")

        try:
            with open(caminho, "r", encoding="utf-8") as arquivo:
                dados_carregados = json.load(arquivo)

                # ‚úÖ Verifica se os dados s√£o v√°lidos antes de substituir a base de dados
                if isinstance(dados_carregados, dict):
                    self.base_dados = dados_carregados
                    print(f"‚úÖ Base de dados carregada com sucesso: {self.base_dados}")
                else:
                    print("‚ùå Erro: O formato da base de dados est√° incorreto (esperado um dicion√°rio).")
                    messagebox.showerror("Erro", "O arquivo da base de dados est√° corrompido ou mal formatado.")
        except FileNotFoundError:
            print("‚ö†Ô∏è Arquivo n√£o encontrado! Criando uma nova base de dados.")
            self.base_dados = {}
        except json.JSONDecodeError:
            print("‚ùå Erro: JSON inv√°lido! O arquivo pode estar corrompido.")
            messagebox.showerror("Erro", "O arquivo da base de dados est√° corrompido ou vazio.")
            return  # Evita sobrescrever os dados com um dicion√°rio vazio

        self.recriar_interface_categorias()




        def rolar_com_mouse(event):
            self.canvas_bd.yview_scroll(-1 * (event.delta // 120), "units")

        self.canvas_bd.bind("<MouseWheel>", rolar_com_mouse)

        if not self.base_dados:
            try:
                with open(self.caminho_base_dados.get(), "r", encoding="utf-8") as arquivo:
                    dados_carregados = json.load(arquivo)
                    
                    # Verifica se os dados carregados t√™m o formato correto
                    if isinstance(dados_carregados, dict):
                        self.base_dados = dados_carregados
                        print(f"‚úÖ Base de dados carregada com sucesso: {self.base_dados}")
                    else:
                        print("‚ùå Erro: O JSON tem um formato inesperado!")
                        messagebox.showerror("Erro", "O arquivo da base de dados est√° corrompido ou mal formatado.")
            except FileNotFoundError:
                print("‚ö†Ô∏è Arquivo n√£o encontrado! Criando uma nova base de dados.")
                self.base_dados = {}
            except json.JSONDecodeError:
                print("‚ùå Erro: JSON inv√°lido! O arquivo pode estar corrompido.")
                messagebox.showerror("Erro", "O arquivo da base de dados est√° corrompido ou vazio.")
                return  # Evita sobrescrever os dados com um dicion√°rio vazio
                

        self.recriar_interface_categorias()
        self.janela_bd.protocol("WM_DELETE_WINDOW", self.fechar_base_dados)

    def fechar_base_dados(self):
        """Fecha a janela e remove eventos para evitar erros."""
        if hasattr(self, "canvas_bd"):
            self.canvas_bd.unbind("<MouseWheel>")  # ‚úÖ Remove a rolagem ao fechar
        self.janela_bd.destroy()
        self.janela_bd.unbind_all("<MouseWheel>")


        
    def validar_valores_categoria(self, novos_valores, valores_existentes):
        usados_pt = set()
        usados_en = set()
        repetidos_pt = set()
        repetidos_en = set()
        duplicados = []
        iguais = []
        valores_unicos = []

        for pt, en in novos_valores:
            if pt in usados_pt:
                repetidos_pt.add(pt)
            elif en in usados_en:
                repetidos_en.add(en)
            elif pt == en:
                iguais.append((pt, en))
            elif (pt, en) in valores_existentes:
                duplicados.append((pt, en))
            else:
                valores_unicos.append((pt, en))
                usados_pt.add(pt)
                usados_en.add(en)

        avisos = {}
        if repetidos_pt:
            avisos["repetidos_pt"] = f"As seguintes entradas em PT est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_pt)}"
        if repetidos_en:
            avisos["repetidos_en"] = f"As seguintes entradas em EN est√£o duplicadas e foram ignoradas:\n\n{', '.join(repetidos_en)}"
        if iguais:
            iguais_str = "\n".join([f"{pt} | {en}" for pt, en in iguais])
            avisos["iguais"] = f"Os seguintes pares t√™m o mesmo valor para PT e EN e foram ignorados:\n\n{iguais_str}"
        if duplicados:
            duplicados_str = "\n".join([f"{pt} | {en}" for pt, en in duplicados])
            avisos["duplicados"] = f"Os seguintes pares j√° existem na categoria e foram ignorados:\n\n{duplicados_str}"

        return {"valores_unicos": valores_unicos, "avisos": avisos}



    def criar_nova_categoria_carregada(self, categoria, valores):
        # Certifica que a categoria existe na base de dados
        if categoria not in self.base_dados:
            self.base_dados[categoria] = valores
            self.salvar_base_dados()  # Salva automaticamente

        # Reutiliza o processo existente
        self.criar_nova_categoria(categoria, valores)




    def formato_texto(self, texto_pt, texto_en):
        """Formato padr√£o para exibi√ß√£o de textos."""
        return f"{texto_pt} | {texto_en} | {texto_pt} ({texto_en})"
    
    def criar_nova_categoria(self, categoria=None, valores=None):
        if categoria and valores:  # Caso chamado automaticamente com dados carregados
            if categoria not in self.base_dados:
                self.base_dados[categoria] = valores

            # Atualiza a interface com a nova categoria
            self.recriar_interface_categorias()
            self.salvar_base_dados()  # Salva automaticamente

            return

        # Fluxo manual para criar nova categoria (janela interativa)
        janela_criar = tk.Toplevel(self.root)
        janela_criar.title("Criar Nova Categoria")
        janela_criar.geometry("600x400")

        # Configura√ß√£o da janela
        janela_criar.grid_rowconfigure(0, weight=1)
        janela_criar.grid_columnconfigure(0, weight=1)

        # Frame principal com barra de rolagem
        frame_principal = ttk.Frame(janela_criar)
        frame_principal.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        ttk.Label(frame_principal, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        entrada_categoria = ttk.Entry(frame_principal)
        entrada_categoria.grid(row=0, column=1, columnspan=2, sticky="ew", padx=5, pady=5)

        ttk.Label(frame_principal, text="Textos em PT:").grid(row=1, column=0, sticky="nw", padx=5, pady=5)
        texto_pt = tk.Text(frame_principal, height=10, width=30)
        texto_pt.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        ttk.Label(frame_principal, text="Textos em EN:").grid(row=1, column=1, sticky="nw", padx=5, pady=5)
        texto_en = tk.Text(frame_principal, height=10, width=30)
        texto_en.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

        # Fun√ß√£o para salvar a categoria
        def salvar_categoria():
            nome_categoria = entrada_categoria.get().strip()
            if not nome_categoria:
                messagebox.showerror("Erro", "O nome da categoria n√£o pode estar vazio.")
                return

            # Processar textos PT e EN
            textos_pt = texto_pt.get("1.0", "end-1c").strip().splitlines()
            textos_en = texto_en.get("1.0", "end-1c").strip().splitlines()

            if len(textos_pt) != len(textos_en):
                messagebox.showerror("Erro", "O n√∫mero de linhas em PT e EN deve ser igual.")
                return

            # Criar termos combinados PT (EN)
            novos_valores = [[pt, en, f"{pt} ({en})"] for pt, en in zip(textos_pt, textos_en)]

            # Caso a categoria j√° exista
            if nome_categoria in self.base_dados:
                resposta = messagebox.askyesno(
                    "Categoria Existente",
                    f"A categoria '{nome_categoria}' j√° existe. Deseja adicionar os novos valores √† categoria existente?"
                )
                if resposta:  # Adicionar aos valores existentes
                    valores_existentes = {tuple(item) for item in self.base_dados[nome_categoria]}
                    novos_valores = list(valores_existentes.union(map(tuple, novos_valores)))
                else:  # Substituir os valores existentes
                    novos_valores = list(map(tuple, novos_valores))

            self.base_dados[nome_categoria] = novos_valores
            self.recriar_interface_categorias()
            self.salvar_base_dados()
            janela_criar.destroy()

            
        # Bot√£o de salvar
        ttk.Button(frame_principal, text="Salvar", command=salvar_categoria).grid(row=3, column=1, pady=10, sticky="e")



    # Fun√ß√£o auxiliar para fixar o comando de editar
    def _criar_funcao_editar(self, categoria):
        return lambda: self.editar_categoria(categoria)

    # Fun√ß√£o auxiliar para fixar o comando de apagar
    def _criar_funcao_apagar(self, categoria):
        return lambda: self.apagar_categoria(categoria)


    def atualizar_lista_categoria(self):
        # Limpar o frame atual sem destruir os frames existentes
        for widget in self.frame_base_dados.winfo_children():
            if isinstance(widget, ttk.Button):
                widget.destroy()

        # Criar bot√µes e frames para cada categoria
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )

        for index, categoria in enumerate(categorias_ordenadas):
            # Criar bot√£o para expandir/colapsar a categoria
            botao_categoria = ttk.Button(
                self.frame_base_dados,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                width=20
            )
            botao_categoria.grid(row=index * 2, column=0, sticky="w", padx=5, pady=5)

        # Criar frame associado √† categoria (inicialmente oculto)
        frame_categoria = ttk.Frame(self.frame_base_dados, relief="flat", borderwidth=0)
        setattr(self, f"frame_{categoria}", frame_categoria)  # Registra o frame no objeto
        self.criar_conteudo_frame(frame_categoria, categoria)
        frame_categoria.grid(row=index * 2 + 1, column=0, sticky="ew", padx=10, pady=5)
        frame_categoria.grid_remove()  # Inicia colapsado


        # Bot√£o para editar a categoria
        botao_editar = ttk.Button(
            self.frame_base_dados,
            text="‚úè",
            command=lambda c=categoria: self.editar_categoria(c)  # Vincula a categoria correta
        )
        botao_editar.grid(row=index * 2, column=1, padx=5, pady=5, sticky="w")

        # Bot√£o para apagar a categoria
        botao_apagar = ttk.Button(
            self.frame_base_dados,
            text="‚ùå",
            command=lambda c=categoria: self.apagar_categoria(c)  # Vincula a categoria correta
        )
        botao_apagar.grid(row=index * 2, column=2, padx=5, pady=5, sticky="w")



            
    def toggle_categoria_frame(self, categoria, forcar_rolagem=False):
        frame_atual = getattr(self, f"frame_{categoria}", None)
        if frame_atual:
            if self.categoria_expandidas.get(categoria, False):
                frame_atual.grid_remove()
                self.categoria_expandidas[categoria] = False
            else:
                frame_atual.grid()
                self.canvas_bd.update_idletasks()
                offset = self.frame_base_dados.winfo_y() / self.canvas_bd.bbox("all")[3]
                if forcar_rolagem:
                    self.canvas_bd.update_idletasks()
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y() + self.frame_base_dados.winfo_height()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura - 10) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(max(0, posicao_final))
                    self.canvas_bd.update_idletasks()
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y() + self.frame_base_dados.winfo_height()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(max(0, posicao_final))
                    frame_pesquisa_altura = self.frame_base_dados.winfo_y()
                    posicao_final = (frame_atual.winfo_y() - frame_pesquisa_altura) / self.canvas_bd.bbox("all")[3]
                    self.canvas_bd.yview_moveto(posicao_final)
                self.categoria_expandidas[categoria] = True










    def criar_conteudo_frame(self, frame, categoria, conteudos=None):
        """Cria o frame com os conte√∫dos da categoria em colunas. Pode receber conte√∫dos filtrados."""
        conteudos = conteudos or self.base_dados[categoria]  # Usar conte√∫dos filtrados se fornecidos

        # Ordena os textos pelo texto PT
        textos_ordenados = sorted(self.base_dados[categoria], key=lambda x: x[0])  # Ordena pelo texto PT

        # Limpa o frame
        for widget in frame.winfo_children():
            widget.destroy()

        # Preenche a tabela no frame
        self.preencher_conteudo_tabela(frame, conteudos)




        
        
    def preencher_conteudo_textbox(self, conteudo_textbox, valores):
        """Preenche o widget de texto com os valores formatados."""
        conteudo_textbox.delete("1.0", "end")  # Limpa o conte√∫do anterior
        for pt, en in valores:
            # Reutiliza a l√≥gica existente no m√©todo criar_conteudo_frame
            conteudo_textbox.insert("end", f"{pt}       |       {en}        |       {pt} ({en})\n")

        
    def apagar_categoria(self, categoria):
        
        if categoria not in self.base_dados:
            tk.messagebox.showerror("Erro", "Categoria n√£o encontrada para apagar.")
            return

        resposta = tk.messagebox.askyesno(
            "Confirmar Exclus√£o",
            f"Tem certeza de que deseja apagar a categoria '{categoria}'?"
        )
        if resposta:
            # Remover o frame associado √† categoria, se existir
            frame_nome = f"frame_{categoria}"
            if hasattr(self, frame_nome):
                frame = getattr(self, frame_nome)
                frame.destroy()
                delattr(self, frame_nome)

            # Remover a categoria da base de dados
            del self.base_dados[categoria]

            # Recriar a interface inteira (para evitar inconsist√™ncias)
            self.recriar_interface_categorias()
            self.salvar_base_dados()  # Salva automaticamente

            
            
    def recriar_interface_categorias(self):
        # Limpar todos os widgets do frame base
        for widget in self.frame_base_dados.winfo_children():
            widget.destroy()

        # Ordenar categorias
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )
        # Recriar as categorias ordenadas
        for index, categoria in enumerate(categorias_ordenadas):
            # Bot√£o para expandir/colapsar
            botao_categoria = ttk.Button(
                self.frame_base_dados,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                width=20
            )
            botao_categoria.grid(row=index * 2, column=0, sticky="w", padx=5, pady=5)

            # Bot√£o para editar a categoria
            botao_editar = ttk.Button(
                self.frame_base_dados,
                text="‚úè",
                command=lambda c=categoria: self.editar_categoria(c)
            )
            botao_editar.grid(row=index * 2, column=1, padx=5, pady=5, sticky="w")

            # Bot√£o para apagar a categoria
            botao_apagar = ttk.Button(
                self.frame_base_dados,
                text="‚ùå",
                command=lambda c=categoria: self.apagar_categoria(c)
            )
            botao_apagar.grid(row=index * 2, column=2, padx=5, pady=5, sticky="w")

            # Criar o frame associado √† categoria
            frame_categoria = ttk.Frame(self.frame_base_dados, relief="flat", borderwidth=0)
            setattr(self, f"frame_{categoria}", frame_categoria)

            # Adicionar o conte√∫do ao frame com ordena√ß√£o
            self.preencher_conteudo_categoria(frame_categoria, categoria)

            # Configurar o frame
            frame_categoria.grid(row=index * 2 + 1, column=0, columnspan=3, sticky="ew", padx=10, pady=5)
            frame_categoria.grid_remove()  # Esconde o frame inicialmente




    def preencher_conteudo_categoria(self, frame_categoria, categoria):
        """Preenche o frame da categoria com os valores ordenados corretamente."""
        
        # Limpar o frame antes de preencher
        for widget in frame_categoria.winfo_children():
            widget.destroy()

        conteudo_ordenado = sorted(
            self.base_dados[categoria], 
            key=lambda x: self.ordena_alfanumerico(x[0])  # Ordenar pelo texto PT
        )

        bg_color = "#F0F0F0"

        # Calcular larguras dinamicamente
        max_pt_len = max(len(pt) for pt, en, pt_en in conteudo_ordenado)
        max_en_len = max(len(en) for pt, en, pt_en in conteudo_ordenado)
        max_pt_en_len = max(len(pt_en) for pt, en, pt_en in conteudo_ordenado)

        for index, (pt, en, pt_en) in enumerate(conteudo_ordenado):
            # Coluna PT
            pt_text = tk.Text(frame_categoria, height=1, width=max_pt_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            pt_text.grid(row=index, column=0, sticky="w", padx=5, pady=2)
            pt_text.insert("1.0", pt)
            pt_text.config(state="disabled")

            separator1 = ttk.Separator(frame_categoria, orient="vertical")
            separator1.grid(row=index, column=1, sticky="ns", padx=5, pady=2)

            # Coluna EN
            en_text = tk.Text(frame_categoria, height=1, width=max_en_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            en_text.grid(row=index, column=2, sticky="w", padx=5, pady=2)
            en_text.insert("1.0", en)
            en_text.config(state="disabled")

            separator2 = ttk.Separator(frame_categoria, orient="vertical")
            separator2.grid(row=index, column=3, sticky="ns", padx=5, pady=2)

            # Coluna PT (EN)
            pt_en_text = tk.Text(frame_categoria, height=1, width=max_pt_en_len, wrap="none", bd=0, relief="flat", bg=bg_color, font=("Arial", 10))
            pt_en_text.grid(row=index, column=4, sticky="w", padx=5, pady=2)
            pt_en_text.insert("1.0", pt_en)
            pt_en_text.config(state="disabled")

        frame_categoria.grid_columnconfigure(0, weight=1)
        frame_categoria.grid_columnconfigure(2, weight=1)
        frame_categoria.grid_columnconfigure(4, weight=1)

        
        






    def editar_categoria(self, categoria):
        """Abre uma janela para editar os valores da categoria, carregando corretamente PT e EN."""
        janela_editar = tk.Toplevel(self.root)
        janela_editar.title(f"Editar Categoria: {categoria}")
        janela_editar.geometry("650x450")

        # Configura√ß√£o do layout
        janela_editar.grid_columnconfigure(0, weight=1)
        janela_editar.grid_columnconfigure(1, weight=1)

        # Entrada do nome da categoria
        ttk.Label(janela_editar, text="Nome da Categoria:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        entrada_categoria = ttk.Entry(janela_editar, width=40)
        entrada_categoria.grid(row=0, column=1, columnspan=2, sticky="ew", padx=5, pady=5)
        entrada_categoria.insert(0, categoria)

        # Campos de texto para PT e EN (Removemos PT (EN))
        ttk.Label(janela_editar, text="Textos em PT:").grid(row=1, column=0, sticky="nw", padx=5, pady=5)
        texto_pt = tk.Text(janela_editar, height=10, width=30)
        texto_pt.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        ttk.Label(janela_editar, text="Textos em EN:").grid(row=1, column=1, sticky="nw", padx=5, pady=5)
        texto_en = tk.Text(janela_editar, height=10, width=30)
        texto_en.grid(row=2, column=1, padx=5, pady=5, sticky="nsew")

        # Preencher os valores existentes diretamente da base de dados
        for pt, en, _ in self.base_dados.get(categoria, []):  # Ignoramos a terceira entrada (PT (EN))
            texto_pt.insert("end", f"{pt}\n")
            texto_en.insert("end", f"{en}\n")

        def guardar_alteracoes():
            nova_categoria = entrada_categoria.get().strip()
            novos_textos_pt = texto_pt.get("1.0", "end-1c").strip().splitlines()
            novos_textos_en = texto_en.get("1.0", "end-1c").strip().splitlines()

            if len(novos_textos_pt) != len(novos_textos_en):
                tk.messagebox.showerror("Erro", "O n√∫mero de linhas em PT e EN deve ser igual.")
                return

            # Criar lista com apenas PT e EN, gerando PT (EN) automaticamente ao salvar
            novos_valores = [[pt, en, f"{pt} ({en})"] for pt, en in zip(novos_textos_pt, novos_textos_en)]

            # Atualizar a base de dados
            if nova_categoria != categoria:
                del self.base_dados[categoria]  # Remove a antiga
            self.base_dados[nova_categoria] = novos_valores

            self.recriar_interface_categorias()
            self.salvar_base_dados()
            janela_editar.destroy()

        # Bot√£o para salvar as altera√ß√µes
        ttk.Button(janela_editar, text="Guardar Altera√ß√µes", command=guardar_alteracoes).grid(row=3, column=1, pady=10, sticky="e")




    def get_categoria_row(self, categoria):
        categorias_ordenadas = sorted(
            self.base_dados.keys(),
            key=self.ordena_alfanumerico
        )

        index = categorias_ordenadas.index(categoria)
        return index * 2
    


    def salvar_base_dados(self):
        """Garante que a base de dados seja salva corretamente no formato PT (EN)."""
        caminho = self.caminho_base_dados.get()
        
        # Certifique-se de que a base de dados n√£o est√° vazia antes de salvar
        if not self.base_dados:
            print("‚ö†Ô∏è Base de dados vazia! Nada ser√° salvo.")
            return
        
        try:
            with open(caminho, "w", encoding="utf-8") as arquivo:
                json.dump(self.base_dados, arquivo, indent=4, ensure_ascii=False)
            print(f"‚úÖ Base de dados salva com sucesso: {self.base_dados}")
        except Exception as e:
            print(f"‚ùå Erro ao salvar a base de dados: {e}")
            messagebox.showerror("Erro", f"Erro ao salvar a base de dados: {e}")





            

    def salvar_antes_de_sair(self):
        self.salvar_base_dados()
        self.root.destroy()
        
        
    def atualizar_categoria_interface(self, categoria):
        # Atualiza a lista de categorias para refletir as altera√ß√µes feitas
        self.atualizar_lista_categoria()
        # Expande a categoria editada para mostrar as altera√ß√µes
        self.toggle_categoria_frame(categoria)
        

    def atualizar_conteudo_categoria(self, categoria):
        """Atualiza o conte√∫do da categoria e ajusta a altura automaticamente."""
        frame_nome = f"frame_{categoria}"
        if hasattr(self, frame_nome):
            frame_categoria = getattr(self, frame_nome)
            
            for widget in frame_categoria.winfo_children():
                widget.destroy()
            
            self.criar_conteudo_frame(frame_categoria, categoria)


    def ordena_alfanumerico(self, texto):
        """Ordena alfanumericamente separando texto e n√∫meros."""
        # Divide o texto em partes num√©ricas e n√£o num√©ricas
        return [
            int(parte) if parte.isdigit() else parte.lower()
            for parte in re.split(r'(\d+)', texto)
        ]
    
    



    def realizar_pesquisa(self, termo_pesquisa, modo="pesquisa"):
        """Realiza a pesquisa nos dados da base e exibe os resultados."""
        print(f"üîç Realizando pesquisa: '{termo_pesquisa}'")

        # Limpar widgets existentes antes de popular novos resultados
        for widget in self.frame_resultados.winfo_children():
            widget.destroy()

        # Certifique-se de que o termo de pesquisa n√£o est√° vazio
        if not termo_pesquisa.strip():
            print("‚ö†Ô∏è Termo de pesquisa vazio. Abortando.")
            return

        resultados = {}  # Inicializa a vari√°vel resultados

        # Buscar em todas as categorias da base de dados
        for categoria, conteudos in self.base_dados.items():
            conteudos_filtrados = [
                item for item in conteudos 
                if termo_pesquisa.lower() in item[0].lower() or termo_pesquisa.lower() in item[1].lower()
            ]
            if conteudos_filtrados:
                resultados[categoria] = conteudos_filtrados

        if not resultados:
            print("‚ö†Ô∏è Nenhum resultado encontrado.")
            return

        # Criar widgets no frame_resultados
        for index, (categoria, conteudos) in enumerate(resultados.items()):
            print(f"Adicionando widgets para categoria: {categoria}, conte√∫dos: {conteudos}")

            # Frame para agrupar bot√µes e conte√∫do
            frame_categoria_completo = ttk.Frame(self.frame_resultados, relief="flat", borderwidth=0)
            frame_categoria_completo.grid(row=index, column=0, columnspan=3, sticky="ew", padx=5)

            # Bot√£o para expandir/colapsar a categoria
            botao_categoria = ttk.Button(
                frame_categoria_completo,
                text=categoria,
                command=lambda c=categoria: self.toggle_categoria_frame(c),
                style="TButton"
            )
            botao_categoria.grid(row=0, column=0, sticky="w", padx=5)

            # Separador vertical ap√≥s o bot√£o de categoria
            separator1 = ttk.Separator(frame_categoria_completo, orient="vertical")
            separator1.grid(row=0, column=1, sticky="ns", padx=5, pady=2)

            # Bot√£o para editar a categoria
            botao_editar = ttk.Button(
                frame_categoria_completo,
                text="‚úè",
                command=lambda c=categoria: self.editar_categoria(c),
                style="TButton"
            )
            botao_editar.grid(row=0, column=2, padx=(5, 2), sticky="w")

            # Separador vertical ap√≥s o bot√£o de editar
            separator2 = ttk.Separator(frame_categoria_completo, orient="vertical")
            separator2.grid(row=0, column=3, sticky="ns", padx=5, pady=2)

            # Bot√£o para apagar a categoria
            botao_apagar = ttk.Button(
                frame_categoria_completo,
                text="‚ùå",
                command=lambda c=categoria: self.apagar_categoria(c),
                style="TButton"
            )
            botao_apagar.grid(row=0, column=4, padx=(2, 5), sticky="w")

            # Frame para os conte√∫dos filtrados
            frame_categoria = ttk.Frame(frame_categoria_completo, relief="flat", borderwidth=0)
            frame_categoria.grid(row=1, column=0, columnspan=5, sticky="ew", padx=10)

            # Adiciona os valores nas colunas
            for content_index, (texto_pt, texto_en) in enumerate(conteudos):
                # Label para o texto PT
                pt_label = tk.Label(frame_categoria, text=texto_pt, anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                pt_label.grid(row=content_index, column=0, sticky="w", padx=5, pady=2)

                # Separador vertical ap√≥s a coluna PT
                separator3 = ttk.Separator(frame_categoria, orient="vertical")
                separator3.grid(row=content_index, column=1, sticky="ns", padx=5, pady=2)

                # Label para o texto EN
                en_label = tk.Label(frame_categoria, text=texto_en, anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                en_label.grid(row=content_index, column=2, sticky="w", padx=5, pady=2)

                # Separador vertical ap√≥s a coluna EN
                separator4 = ttk.Separator(frame_categoria, orient="vertical")
                separator4.grid(row=content_index, column=3, sticky="ns", padx=5, pady=2)

                # Label para o texto PT (EN)
                pt_en_label = tk.Label(frame_categoria, text=f"{texto_pt} ({texto_en})", anchor="w", bg="#F0F0F0", font=("Arial", 10), bd=0, relief="flat")
                pt_en_label.grid(row=content_index, column=4, sticky="w", padx=5, pady=2)

            # Configura√ß√£o din√¢mica de layout
            frame_categoria.grid_columnconfigure(0, weight=1)
            frame_categoria.grid_columnconfigure(1, weight=0)  # Separator 3 (n√£o redimension√°vel)
            frame_categoria.grid_columnconfigure(2, weight=1)
            frame_categoria.grid_columnconfigure(3, weight=0)  # Separator 4 (n√£o redimension√°vel)
            frame_categoria.grid_columnconfigure(4, weight=1)
            frame_categoria.grid_rowconfigure(0, weight=1)

        # Configura√ß√£o para o frame_resultados
        self.frame_resultados.grid_columnconfigure(0, weight=1)  # Ajusta o frame principal para preencher horizontalmente
        self.frame_resultados.grid_rowconfigure("all", weight=0)  # Certifique-se de que os frames n√£o cres√ßam verticalmente

        # Mostrar o frame de resultados sobre o frame_corpo_bd
        self.frame_resultados.grid()
        self.frame_resultados.lift()
        print("Frame atual: Resultados")








    def alternar_frames(self, mostrar_resultados):
        if mostrar_resultados:
            self.frame_base_dados.grid_remove()  # Oculta o frame principal
            self.frame_resultados.grid()        # Mostra o frame de resultados
            print("Frame atual: Resultados")    # Adicionado aqui

        else:
            self.frame_resultados.grid_remove()  # Oculta o frame de resultados
            self.frame_base_dados.grid()        # Mostra o frame principal
            print("Frame atual: Base de Dados")  # Adicionado aqui
            
            
    def _copiar_texto(self, texto):
        """Permite copiar o texto ao selecion√°-lo."""
        self.root.clipboard_clear()
        self.root.clipboard_append(texto)
        self.root.update()  # Atualiza o clipboard

    def preencher_conteudo_tabela(self, frame, valores):
        """Preenche uma tabela selecion√°vel com os valores formatados em 3 colunas."""
        # Limpa o frame
        for widget in frame.winfo_children():
            widget.destroy()

        # Cria uma tabela (frame interno com grid layout)
        for index, (pt, en) in enumerate(valores):
            # Texto em PT
            label_pt = tk.Label(frame, text=pt, anchor="w", font=("Arial", 10), padx=5)
            label_pt.grid(row=index, column=0, sticky="w")
            label_pt.bind("<Button-1>", lambda e, texto=pt: self._copiar_texto(texto))

            # Separador vertical
            separator1 = ttk.Separator(frame, orient="vertical")
            separator1.grid(row=index, column=1, sticky="ns")

            # Texto em EN
            label_en = tk.Label(frame, text=en, anchor="w", font=("Arial", 10), padx=5)
            label_en.grid(row=index, column=2, sticky="w")
            label_en.bind("<Button-1>", lambda e, texto=en: self._copiar_texto(texto))

            # Separador vertical
            separator2 = ttk.Separator(frame, orient="vertical")
            separator2.grid(row=index, column=3, sticky="ns")

            # Texto em PT (EN)
            label_pt_en = tk.Label(frame, text=f"{pt} ({en})", anchor="w", font=("Arial", 10), padx=5)
            label_pt_en.grid(row=index, column=4, sticky="w")
            label_pt_en.bind("<Button-1>", lambda e, texto=f"{pt} ({en})": self._copiar_texto(texto))

        # Configura√ß√£o din√¢mica de layout
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_columnconfigure(2, weight=1)
        frame.grid_columnconfigure(4, weight=1)

    def copiar_texto(self, text_widget):
            """Fun√ß√£o para copiar o texto selecionado para a √°rea de transfer√™ncia."""
            try:
                selected_text = text_widget.get("sel.first", "sel.last")
                text_widget.master.clipboard_clear()
                text_widget.master.clipboard_append(selected_text)
            except tk.TclError:
                pass  # Nenhum texto selecionado, ignora
    
    def colar_texto(self, entry_widget):
        """Fun√ß√£o para colar o conte√∫do da √°rea de transfer√™ncia na caixa de entrada."""
        clipboard_text = entry_widget.master.clipboard_get()  # Acessa o clipboard atrav√©s da janela principal
        entry_widget.insert(tk.END, clipboard_text)

    
    
    def criar_menu_contexto(self, event, text_widget):
        """Cria o menu de contexto para as op√ß√µes dispon√≠veis, como 'Copiar' e 'Colar'."""
        menu = tk.Menu(text_widget.master, tearoff=0)

        # Adiciona a op√ß√£o de 'Copiar' se o widget for um 'Text' ou 'Entry'
        if isinstance(text_widget, (tk.Text, ttk.Entry)):
            menu.add_command(label="Copiar", command=lambda: self.copiar_texto(text_widget))  # Usando o m√©todo da classe

        # Adiciona a op√ß√£o de 'Colar' se o widget for um 'Entry'
        if isinstance(text_widget, (tk.Text, ttk.Entry)):
            menu.add_command(label="Colar", command=lambda: self.colar_texto(text_widget))  # Usando o m√©todo da classe para colar
        
        menu.post(event.x_root, event.y_root)



    def abrir_janela_busca(self, event=None):
        """Abre uma janela para o usu√°rio buscar texto na aplica√ß√£o."""
        print("Janela de busca acionada")
        janela_foco = self.root if not hasattr(self, 'janela_bd') or not self.janela_bd.winfo_exists() else self.janela_bd
        self.janela_busca = tk.Toplevel(janela_foco)
        self.janela_busca.title("Buscar")
        self.janela_busca.geometry("300x180")

        # Inicializar resultados e resultado atual
        self.resultados = []
        self.resultado_atual = -1

        # Fun√ß√£o para limpar destaques
        def limpar_destaques():
            if hasattr(self, 'resultados'):
                for widget, inicio, final in self.resultados:
                    if isinstance(widget, tk.Text):
                        widget.tag_remove("highlight", "1.0", "end")
                        widget.tag_remove("focus_highlight", "1.0", "end")
                    elif isinstance(widget, (tk.Label, ttk.Label)):
                        widget.config(background="SystemButtonFace")  # Cor padr√£o
                    elif isinstance(widget, ttk.Treeview):
                        widget.tag_configure("highlight", background="")
                        for item in widget.get_children():
                            widget.item(item, tags=())  # Remove tags

        # Fun√ß√£o para fechar a janela de busca
        def fechar_janela_busca():
            limpar_destaques()
            self.janela_busca.destroy()

        self.janela_busca.protocol("WM_DELETE_WINDOW", fechar_janela_busca)

        # Fun√ß√£o para realizar a pesquisa em tempo real
        def realizar_pesquisa(event=None):
            # Ignora KeyRelease do Enter
            if event and event.keysym == "Return":
                return

            termo = entrada_busca.get().strip().lower()  # Obter termo de busca
            limpar_destaques()  # Remove destaques anteriores

            if not termo:
                self.resultados = []
                self.resultado_atual = -1
                self.label_resultado.config(text="Insira um termo de busca")
                return

            # Buscar resultados
            self.resultados = self.coletar_resultados(termo, janela_foco)
            self.resultado_atual = 0 if self.resultados else -1

            if self.resultados:
                self.focar_resultado()
                self.label_resultado.config(text=f"1 / {len(self.resultados)}")
            else:
                self.label_resultado.config(text="Nenhum resultado encontrado.")

        # Fun√ß√£o para focar no pr√≥ximo resultado
        def proximo_resultado(event=None):
            if self.resultados:
                self.resultado_atual = (self.resultado_atual + 1) % len(self.resultados)
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

        # Fun√ß√£o para focar no resultado anterior
        def resultado_anterior(event=None):
            if self.resultados:
                self.resultado_atual = (self.resultado_atual - 1) % len(self.resultados)
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

        # Campo de entrada para busca
        entrada_busca = ttk.Entry(self.janela_busca)
        entrada_busca.pack(pady=10, padx=10)
        entrada_busca.focus_set()  # Define o foco inicial na caixa de entrada
        entrada_busca.bind("<KeyRelease>", realizar_pesquisa)  # Atualiza a busca dinamicamente
        entrada_busca.bind("<Return>", lambda event: proximo_resultado())  # Avan√ßa para o pr√≥ximo resultado ao pressionar Enter

        # Label para mostrar n√∫mero de resultados
        self.label_resultado = ttk.Label(self.janela_busca, text="Insira um termo de busca", anchor="center")
        self.label_resultado.pack(pady=5)

        # Frame para bot√µes de navega√ß√£o
        frame_botoes = ttk.Frame(self.janela_busca)
        frame_botoes.pack(pady=5)

        ttk.Button(frame_botoes, text="Anterior", command=resultado_anterior).grid(row=0, column=0, padx=5)
        ttk.Button(frame_botoes, text="Pr√≥ximo", command=proximo_resultado).grid(row=0, column=1, padx=5)

        

    def configurar_atalhos_busca(self, janela):
        """Configura os atalhos de busca para a janela especificada."""
        janela.bind("<Control-f>", self.abrir_janela_busca)
        janela.bind("<Control-l>", self.abrir_janela_busca)
        
        
    def coletar_resultados(self, termo, janela):
        """Coleta todos os resultados encontrados nos widgets de texto, labels e tabelas."""
        resultados = []
        termo = termo.lower().strip()

        def buscar_widgets(widget):
            if isinstance(widget, tk.Text):
                pos = "1.0"
                while True:
                    pos = widget.search(termo, pos, nocase=True, stopindex="end")
                    if not pos:
                        break
                    final = f"{pos}+{len(termo)}c"
                    resultados.append((widget, pos, final))
                    pos = final

            elif isinstance(widget, (tk.Label, ttk.Label)):
                texto = widget.cget("text").lower()
                if termo in texto:
                    resultados.append((widget, None, None))

            elif isinstance(widget, ttk.Treeview):
                for child in widget.get_children():
                    values = widget.item(child, "values")
                    for value in values:
                        if termo in str(value).lower():
                            resultados.append((widget, child, None))

            for child in widget.winfo_children():
                buscar_widgets(child)

        buscar_widgets(janela)
        return resultados




    
    def proximo_resultado(self, event=None):
        """Avan√ßa para o pr√≥ximo resultado ao pressionar 'Enter'."""
        if self.resultados:
            if event and event.type == "2":  # KeyPress
                if hasattr(self, "enter_pressed") and self.enter_pressed:
                    return
                self.enter_pressed = True
                self.resultado_atual = (self.resultado_atual + 1) % len(self.resultados)  # Navega√ß√£o circular
                self.focar_resultado()
                self.label_resultado.config(text=f"{self.resultado_atual + 1} / {len(self.resultados)}")

            elif event and event.type == "3":  # KeyRelease
                self.enter_pressed = False




    def buscar_texto(self, termo, janela):
        """Realiza a busca do texto em todos os widgets de texto, labels e tabelas na janela especificada."""
        termo = termo.lower().strip()  # Garante que a busca seja insens√≠vel a mai√∫sculas/min√∫sculas

        def buscar_widgets(widget):
            # Expande frames colapsados antes de buscar
            self.expandir_frames_ocultos(widget)

            # Busca em widgets do tipo Text
            if isinstance(widget, tk.Text):
                widget.tag_remove("highlight", "1.0", "end")  # Remove destaques antigos
                pos = "1.0"
                while True:
                    pos = widget.search(termo, pos, nocase=True, stopindex="end")
                    if not pos:
                        break
                    final = f"{pos}+{len(termo)}c"
                    widget.tag_add("highlight", pos, final)
                    widget.tag_config("highlight", background="yellow", foreground="black")
                    pos = final

            # Busca em widgets do tipo Label
            elif isinstance(widget, (tk.Label, ttk.Label)):
                texto = widget.cget("text").lower()
                if termo in texto:
                    widget.config(background="yellow")
                else:
                    widget.config(background="SystemButtonFace")  # Remove destaque se n√£o corresponder

            # Busca em tabelas do tipo Treeview
            elif isinstance(widget, ttk.Treeview):
                for child in widget.get_children():
                    values = widget.item(child, "values")  # Obt√©m os valores das c√©lulas da linha
                    for value in values:
                        if termo in str(value).lower():
                            widget.tag_configure("highlight", background="yellow")
                            widget.item(child, tags=("highlight",))
                        else:
                            widget.item(child, tags=())  # Remove tags se n√£o corresponder

            # Busca recursiva nos widgets filhos
            for child in widget.winfo_children():
                buscar_widgets(child)

        buscar_widgets(janela)


    def expandir_frames_ocultos(self, widget):
        """Expande frames colapsados para permitir a busca nos widgets internos."""
        parent = widget.master
        while parent is not None and parent is not self.root:
            if hasattr(parent, "is_collapsed") and parent.is_collapsed:
                parent.expand()  # Expande o frame, se estiver colapsado
            parent = parent.master
            
            
            
            
    def focar_resultado(self):
        """Foca no resultado atual, expande frames colapsados e ajusta a rolagem no Canvas."""
        print("M√©todo focar_resultado chamado.")

        # Verificar se h√° resultados para focar
        if not self.resultados or self.resultado_atual == -1:
            print("Nenhum resultado para focar ou resultado atual inv√°lido.")
            return

        print(f"Resultados encontrados: {len(self.resultados)}, Resultado atual: {self.resultado_atual}")

        # Remover destaque de resultados anteriores
        for widget, inicio, final in self.resultados:
            if isinstance(widget, tk.Text):
                widget.tag_remove("focus_highlight", "1.0", "end")
            elif isinstance(widget, (tk.Label, ttk.Label)):
                widget.config(background="SystemButtonFace")

        # Destacar o resultado atual
        widget, inicio, final = self.resultados[self.resultado_atual]
        print(f"Focando no widget: {widget}, In√≠cio: {inicio}, Final: {final}")

        if isinstance(widget, tk.Text):
            widget.tag_add("focus_highlight", inicio, final)
            widget.tag_config("focus_highlight", background="orange", foreground="black")
            widget.see(inicio)  # Garante que o texto esteja vis√≠vel
        elif isinstance(widget, (tk.Label, ttk.Label)):
            widget.config(background="orange")

        # Expandir frames colapsados, se necess√°rio
        parent = widget.master
        while parent is not None and parent is not self.root:
            if hasattr(parent, "grid_remove") and not parent.winfo_viewable():
                print(f"Expandindo frame colapsado: {parent}")
                parent.grid()  # Expande o frame
            parent = parent.master

        # Ajustar rolagem no Canvas para centralizar o widget
        canvas = None
        parent = widget.master
        while parent is not None:
            if isinstance(parent, tk.Canvas):  # Localiza o Canvas pai
                canvas = parent
                break
            parent = parent.master

        if canvas:
            canvas.update_idletasks()  # Garante que o layout do Canvas est√° atualizado

            # Recalcular dimens√µes do Canvas e widget dinamicamente
            canvas_height = canvas.winfo_height()
            canvas_total_height = canvas.bbox("all")[3]
            widget_y_in_canvas = canvas.canvasy(widget.winfo_rooty() - canvas.winfo_rooty())
            widget_height = widget.winfo_height()

            # Calcular bordas do widget
            widget_top = widget_y_in_canvas
            widget_bottom = widget_y_in_canvas + widget_height
            canvas_top = canvas.canvasy(0)
            canvas_bottom = canvas_top + canvas_height

            print(f"Canvas Altura: {canvas_height}, Canvas Total Altura: {canvas_total_height}")
            print(f"Widget Topo: {widget_top}, Widget Fundo: {widget_bottom}, Canvas Topo: {canvas_top}, Canvas Fundo: {canvas_bottom}")

            # Verificar visibilidade real do widget
            if widget_top < canvas_top or widget_bottom > canvas_bottom:
                # Centralizar o widget no Canvas
                widget_center = widget_top + (widget_height / 2)
                scroll_position = max(0, min(1, (widget_center - (canvas_height / 2)) / canvas_total_height))
                print(f"Scroll Position Calculada: {scroll_position}")
                canvas.yview_moveto(scroll_position)
            else:
                print("Widget est√° completamente vis√≠vel no Canvas, rolagem n√£o necess√°ria.")
        else:
            print("Nenhum Canvas encontrado para ajustar a rolagem.")

        # Sincronizar mudan√ßas no layout
        self.root.update_idletasks()  # Garante que o layout geral est√° est√°vel


    def selecionar_coluna_arrastando(self, event):
        """ Seleciona todas as linhas da coluna ao arrastar o rato """
        item_selecionado = self.tree.identify_row(event.y)  # Obt√©m a linha onde foi clicado
        coluna_selecionada = self.tree.identify_column(event.x)  # Obt√©m a coluna onde foi clicado

        if not item_selecionado or not coluna_selecionada:
            return

        # Obt√©m o √≠ndice num√©rico da coluna (ex: #1, #2 -> 1, 2)
        coluna_index = int(coluna_selecionada.replace("#", "")) - 1

        # Seleciona todas as c√©lulas da mesma coluna
        for item in self.tree.get_children():
            valores = self.tree.item(item, "values")
            if valores:
                self.tree.selection_add(item)  # Adiciona a linha √† sele√ß√£o

    def configurar_selecao_arrastavel(self):
        """ Configura o evento de clique e arrasto na tabela """
        self.tree.bind("<B1-Motion>", self.selecionar_coluna_arrastando)










    def criar_abas(self):
        """ Cria as abas principais do notebook """
        self.notebook = ttk.Notebook(self.root)
        self.notebook.grid(row=0, column=0, sticky="nsew")

        # Criar abas
        self.aba_evento_semanal = ttk.Frame(self.notebook)
        self.aba_missoes = ttk.Frame(self.notebook)
        self.aba_eventos_modo_livre = ttk.Frame(self.notebook)


        # Configura√ß√£o das abas
        self.aba_evento_semanal.grid_columnconfigure(0, weight=1)
        self.aba_evento_semanal.grid_rowconfigure(0, weight=0)  # Linha para a imagem no topo
        self.aba_evento_semanal.grid_rowconfigure(1, weight=1)  # Linhas de caixas de texto ocupam o espa√ßo restante
        self.aba_evento_semanal.grid_rowconfigure(2, weight=0)  # Fixa o bot√£o no final
        
    def criar_abas_notebook(self):
        """ Cria e adiciona as abas ao notebook """
        self.notebook.add(self.aba_evento_semanal, text="Evento Semanal")
        self.notebook.add(self.aba_missoes, text="Miss√µes")
        self.configurar_aba_missoes()
        self.notebook.add(self.aba_eventos_modo_livre, text="Eventos Modo Livre")
        self.carregar_imagem_topo()  # Chama a fun√ß√£o para carregar a imagem no topo
        




        # Configura√ß√µes de "Dispon√≠vel Brevemente" nas outras abas
        self.label_eventos = ttk.Label(self.aba_eventos_modo_livre, text="Dispon√≠vel Brevemente", font=("TkDefaultFont", 10, "bold"))
        self.label_eventos.grid(row=0, column=0, pady=20, padx=20, sticky="n")

    
    def monitorar_expansao(self):
        """ Monitora mudan√ßas no frame e ajusta a rolagem automaticamente """
        self.tela.update_idletasks()
        self.tela.configure(scrollregion=self.tela.bbox("all"))  # Ajusta a √°rea de scroll

        # Rechama a fun√ß√£o automaticamente a cada 100ms
        self.tela.after(100, self.monitorar_expansao) 



    def configurar_scroll(self):
        """Configura√ß√£o da rolagem na aba de eventos semanais."""

        # Criar o Canvas e a barra de rolagem
        self.tela = tk.Canvas(self.aba_evento_semanal)
        self.barra_deslocamento = ttk.Scrollbar(self.aba_evento_semanal, orient="vertical", command=self.tela.yview)

        # Criar o frame dentro do Canvas (N√ÉO ser√° expandido infinitamente)
        self.frame_deslocavel = ttk.Frame(self.tela)

        # Criar um frame real dentro do frame_deslocavel que conter√° os widgets
        self.frame_conteudo = ttk.Frame(self.frame_deslocavel)
        self.frame_conteudo.grid(row=0, column=0, sticky="nsew")  # Mant√©m o layout fixo

        # Criar a janela no Canvas com um ID fixo
        self.window_id = self.tela.create_window((0, 0), window=self.frame_deslocavel, anchor="nw")

        # Configurar a barra de rolagem
        self.tela.configure(yscrollcommand=self.barra_deslocamento.set)

        self.tela.grid(row=1, column=0, sticky="nsew")
        self.barra_deslocamento.grid(row=1, column=1, sticky="ns")

        # Ajustar a largura do frame dentro do Canvas
        def _ajustar_largura(event=None):
            largura_canvas = self.tela.winfo_width()
            nova_largura = max(largura_canvas, 300)  # Define uma largura m√≠nima
            self.tela.itemconfig(self.window_id, width=nova_largura)

        self.tela.bind("<Configure>", _ajustar_largura)
        self.monitorar_expansao()  


        # Atualiza a √°rea de rolagem e impede scroll infinito
        def atualizar_scroll():
            self.tela.update_idletasks()  # Garante que o layout foi atualizado
            bbox = self.tela.bbox("all")

            if bbox and bbox[3] > self.tela.winfo_height():  
                self.tela.configure(scrollregion=bbox)  # Permite scroll apenas se necess√°rio
            else:
                self.tela.configure(scrollregion=(0, 0, bbox[2], self.tela.winfo_height()))  # Limita a rolagem

        self.frame_conteudo.bind("<Configure>", lambda e: atualizar_scroll())

        # Ajusta a rolagem do mouse corretamente no Windows (delta // 120)
        def _no_roda_rato(event):
            self.tela.yview_scroll(-1 * (event.delta // 120), "units")

        self.tela.bind("<Enter>", lambda e: self.tela.bind_all("<MouseWheel>", _no_roda_rato))
        self.tela.bind("<Leave>", lambda e: self.tela.unbind_all("<MouseWheel>"))



    def adicionar_scroll_horizontal(self, widget):
        """Adiciona uma scrollbar horizontal ao widget especificado."""
        frame = widget.master  # Obt√©m o frame pai do widget
        scrollbar_x = ttk.Scrollbar(frame, orient="horizontal", command=widget.xview)
        widget.configure(xscrollcommand=scrollbar_x.set)

        # Adiciona a scrollbar corretamente usando grid, se o widget for um Text
        if isinstance(widget, tk.Text):
            widget.configure(wrap="none")

        # Use grid() em vez de pack() para evitar conflitos
        scrollbar_x.grid(row=widget.grid_info()["row"] + 1, column=widget.grid_info()["column"], sticky="ew")






    def _no_roda_rato(self, event):
        """Fun√ß√£o para rolar a tela com o uso do mouse."""
        self.tela.yview_scroll(-1 * (event.delta // 120), "units")
        
    
    def adjust_height(self, event, widget):
        """Ajusta dinamicamente a altura da caixa de texto conforme o conte√∫do e garante que as caixas em colunas 0 e 1 tenham alturas iguais."""
        
        if isinstance(widget, tk.Text):
            widget.update_idletasks()  # Atualiza a interface antes de calcular a altura

            # Obt√©m a quantidade de linhas vis√≠veis
            visible_lines = widget.count("1.0", "end", "displaylines")[0]

            # Define os limites m√≠nimos e m√°ximos
            min_height = 1
            max_height = 10  # Reduzido para evitar espa√ßo morto excessivo

            # Determina a nova altura com base no conte√∫do
            new_height = min(max(visible_lines, min_height), max_height)

            # Obt√©m a linha e coluna da caixa de texto
            row = widget.grid_info()["row"]
            column = int(widget.grid_info()["column"])

            # Aplica a nova altura √† caixa de texto atual e √† correspondente (se houver)
            widget.configure(height=new_height)

            try:
                # Ajusta a caixa correspondente na outra coluna
                corresponding_column = 1 if column == 0 else 0
                corresponding_widget = self.frame_corridas_acrobaticas.grid_slaves(row=row, column=corresponding_column)[0]
                corresponding_widget.configure(height=new_height)
            except IndexError:
                pass  # Caso n√£o haja widget correspondente, ignora o erro

            # Reconfigura o peso das linhas sem for√ßar uma altura fixa
            self.frame_corridas_acrobaticas.grid_rowconfigure(row, weight=0)










            
    def adicionar_linha(self, event):
        """Adiciona uma √∫nica linha ao pressionar Shift + Enter."""
        widget = event.widget
        if isinstance(widget, tk.Text):
            widget.insert("insert", "\n")  # Adiciona uma nova linha na posi√ß√£o do cursor
            return "break"  # Evita o comportamento padr√£o do evento

    
    def proximo_campo_sem_nova_linha(self, event):
        """Move o foco para o pr√≥ximo campo ao pressionar Enter sem adicionar nova linha"""
        current = event.widget
        if current in self.caixas_texto:
            next_index = self.caixas_texto.index(current) + 1
            if next_index < len(self.caixas_texto):
                self.caixas_texto[next_index].focus()
        return "break"
    
    def shift_return_handler(self, event):
        self.adicionar_linha(event)
        self.scroll_para_cursor(event)
        return "break"

    def proximo_campo(self, event):
        """Move para a pr√≥xima caixa quando Enter √© pressionado"""
        current = event.widget
        next_index = self.caixas_texto.index(current) + 1
        if next_index < len(self.caixas_texto):
            self.caixas_texto[next_index].focus_set()
        return "break"
    def carregar_imagem_topo(self):
        """ Carregar e exibir a imagem no topo da aba 'Evento Semanal' """
        url_imagem = "https://gdm-assets.b-cdn.net/images/ncavvykf/gfinityesports/e2b192e39a5c1e14362a5750d4271e0c630bc556-1200x630.jpg"
        
        # Baixar a imagem da URL
        resposta = requests.get(url_imagem)
        imagem = Image.open(BytesIO(resposta.content))
        imagem = imagem.resize((600, 200), Image.Resampling.LANCZOS)  # Redimensionar a imagem para ajustar na largura da janela

        # Converter para formato que o Tkinter consegue usar
        imagem_tk = ImageTk.PhotoImage(imagem)

        # Criar label para exibir a imagem
        self.imagem_label = tk.Label(self.aba_evento_semanal, image=imagem_tk)
        self.imagem_label.image = imagem_tk  # Manter uma refer√™ncia da imagem
        self.imagem_label.grid(row=0, column=0, columnspan=2, sticky="nsew")


    def criar_caixas_texto(self):
        """ Cria√ß√£o das caixas de texto din√¢micas dentro da aba de eventos semanais """
        self.caixas_texto = []  # Lista para armazenar as caixas de texto

        # Configurar o frame para expandir corretamente
        self.frame_deslocavel.grid_columnconfigure(0, weight=1)  # Permite que o conte√∫do expanda horizontalmente

        # Fun√ß√£o para ajustar largura das caixas de texto
        def _ajustar_largura_caixas(event=None):
            largura_frame = self.frame_deslocavel.winfo_width()
            for caixa in self.caixas_texto:
                caixa.configure(width=int(largura_frame / 10))  # Ajusta a largura conforme o frame

        # Atualiza a largura sempre que o frame mudar de tamanho
        self.frame_deslocavel.bind("<Configure>", _ajustar_largura_caixas)
        










        #####################################################################################################################################################
        ##################################################### CRIA√áAO DA TEXTBOXES E CONTEUDO ###############################################################
        #####################################################################################################################################################
        
        #URL da imagem ou v√≠deo de Capa
        #Titulo
        label_url = ttk.Label(
            self.frame_deslocavel, 
            text="URL da imagem ou v√≠deo de Capa:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_url.grid(row=0, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_url = ttk.Label(
            self.frame_deslocavel, 
            text="Coloca o link da imagem ou v√≠deo que ir√° servir de capa para os eventos desta semana.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_url.grid(row=1, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto
        entrada_url = ttk.Entry(self.frame_deslocavel)
        entrada_url.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        
        entrada_url.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        entrada_url.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        entrada_url.bind('<Return>', self.proximo_campo_sem_nova_linha)  # Move para o pr√≥ximo campo ao pressionar Enter
        entrada_url.bind("<KeyRelease>", self.scroll_para_cursor)
        entrada_url.bind("<Tab>", self.proximo_campo_com_tab)  # Garante que Tab mova para o pr√≥ximo campo

        self.caixas_texto.append(entrada_url)  # Adiciona a entrada √† lista de caixas


        
        
        
        
        #Conte√∫do Novo###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_conteudo_novo = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Conte√∫do Novo",
            command=lambda: alternar_visibilidade(
                conteudo_novo_frame,
                botao_expandir_conteudo_novo,
                "Adicionar Categoria de Conte√∫do Novo",
                "Remover Categoria de Conte√∫do Novo"
            )
        )

        botao_expandir_conteudo_novo.grid(row=100, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Conte√∫do Novo"
        conteudo_novo_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        conteudo_novo_frame.grid(row=101, column=0, sticky="ew", padx=10, pady=10)
        conteudo_novo_frame.grid_remove() 
        conteudo_novo_frame.bind("<Configure>", lambda e: conteudo_novo_frame.config(width=self.frame_deslocavel.winfo_width()))


        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao, texto_expandir, texto_colapsar):
            """Alterna a visibilidade de um frame e ajusta o texto do bot√£o."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o frame
                botao.config(text=texto_expandir)
            else:
                frame.grid()  # Mostra o frame
                botao.config(text=texto_colapsar)




        # Widgets dentro do conteudo_novo_frame
        # Label T√≠tulo
        label_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Conte√∫do Novo",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_conteudo_novo.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))
        
        
        # Titulo Conte√∫do Novo
        label_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Conte√∫do Novo:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_conteudo_novo.grid(row=4, column=0, sticky="w", padx=10, pady=(0, 5))
        
        # Descri√ß√£o Conteudo Novo
        descricao_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Introduz o conte√∫do novo na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_conteudo_novo.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Conte√∫do Novo
        self.entrada_conteudo_novo = tk.Text(conteudo_novo_frame, height=1, wrap=tk.WORD)
        self.entrada_conteudo_novo.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_conteudo_novo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_conteudo_novo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_conteudo_novo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_conteudo_novo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_conteudo_novo))
        self.caixas_texto.append(self.entrada_conteudo_novo)
        self.associar_botao_filtro(self.entrada_conteudo_novo)  # Passar o widget diretamente

        

        # Imagem do Conteudo Novo
        label_imagem_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Imagem do Conte√∫do Novo:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_conteudo_novo.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_conteudo_novo = ttk.Label(
            conteudo_novo_frame,
            text="Mete o link da imagem do conte√∫do novo",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_conteudo_novo.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_conteudo_novo = tk.Text(conteudo_novo_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_conteudo_novo.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_conteudo_novo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_conteudo_novo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_conteudo_novo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_conteudo_novo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_conteudo_novo))
        self.caixas_texto.append(self.entrada_imagem_conteudo_novo)
        
        
        
        
        #Novos Veiculos Disponiveis###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_novos_veiculos = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Novos Veiculos Disponiveis",
            command=lambda: alternar_visibilidade(
                novos_veiculos_frame,
                botao_expandir_novos_veiculos,
                "Adicionar Categoria de Novos Veiculos Disponiveis",
                "Remover Categoria de Novos Veiculos Disponiveis"
            )
        )
        botao_expandir_novos_veiculos.grid(row=102, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Conte√∫do Novo"
        novos_veiculos_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        novos_veiculos_frame.grid(row=103, column=0, sticky="ew", padx=10, pady=10)
        novos_veiculos_frame.grid_remove() 
        novos_veiculos_frame.bind("<Configure>", lambda e: novos_veiculos_frame.config(width=self.frame_deslocavel.winfo_width()))

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Novos Veiculos Disponiveis."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Novos Veiculos Disponiveis")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Novos Veiculos Disponiveis")

        # Widgets dentro do Novos Veiculos Disponiveis
        # Label T√≠tulo
        label_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Novos Veiculos Disponiveis",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_novos_veiculos.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))


        # Titulo Novos Veiculos Disponiveis
        label_descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Nome dos Novos Veiculos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_descricao_novos_veiculos.grid(row=1, column=0, sticky="w", padx=10, pady=(0, 5))    
        

        
        
        # Descri√ß√£o Novos Veiculos Disponiveis
        descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Introduz os Novos Veiculos Disponiveis na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_novos_veiculos.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Novos Veiculos Disponiveis
        self.entrada_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_novos_veiculos.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_novos_veiculos))

        self.caixas_texto.append(self.entrada_novos_veiculos)
        self.associar_botao_filtro(self.entrada_novos_veiculos)

        
        
        # condi√ßao de desbloqueio de compra dos Novos Veiculos Disponiveis
        label_desbloqueio_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Condi√ß√£o do Desbloqueio dos Novos Ve√≠culos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_desbloqueio_novos_veiculos.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_desbloqueio_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Escreve a condi√ß√£o necesss√°ria para desbloquear a compra dos Novos Ve√≠culos Disponiveis na linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_desbloqueio_novos_veiculos.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_desbloqueio_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_desbloqueio_novos_veiculos.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_desbloqueio_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_desbloqueio_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_desbloqueio_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_desbloqueio_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_desbloqueio_novos_veiculos))
        self.caixas_texto.append(self.entrada_desbloqueio_novos_veiculos)
        self.associar_botao_filtro(self.entrada_desbloqueio_novos_veiculos)

        
        
        # condi√ßao de desbloqueio de pre√ßo de f√°brica dos Novos Veiculos Disponiveis
        label_precofabrica_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Condi√ß√£o do Desbloqueio do Pre√ßo de F√°brica dos Novos Ve√≠culos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_precofabrica_novos_veiculos.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_precofabrica_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Escreve a condi√ß√£o necesss√°ria para desbloquear a o pre√ßo de f√°brica dos Novos Ve√≠culos Disponiveis na linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_precofabrica_novos_veiculos.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_precofabrica_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_precofabrica_novos_veiculos.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_precofabrica_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_precofabrica_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_precofabrica_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_precofabrica_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_precofabrica_novos_veiculos))
        self.caixas_texto.append(self.entrada_precofabrica_novos_veiculos)
        self.associar_botao_filtro(self.entrada_precofabrica_novos_veiculos)
        

        # Imagem do Novos Veiculos Disponiveis
        label_imagem_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Imagem dos Novos Veiculos Disponiveis:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_novos_veiculos.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_novos_veiculos = ttk.Label(
            novos_veiculos_frame,
            text="Mete o link da imagem dos Novos Veiculos Disponiveis na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_novos_veiculos.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_novos_veiculos = tk.Text(novos_veiculos_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_novos_veiculos.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_novos_veiculos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_novos_veiculos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_novos_veiculos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_novos_veiculos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_novos_veiculos))
        self.caixas_texto.append(self.entrada_imagem_novos_veiculos)
        
        
        
        
        #Pr√©mios de Login ###################################################################
        botao_expandir_premios_login = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Pr√©mios de Login",
            command=lambda: alternar_visibilidade(
                premios_login_frame,
                botao_expandir_premios_login,
                "Adicionar Categoria de Pr√©mios de Login",
                "Remover Categoria de Pr√©mios de Login"
            )
        )

        botao_expandir_premios_login.grid(row=104, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "Pr√©mios de Login"
        premios_login_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        premios_login_frame.grid(row=105, column=0, sticky="ew", padx=10, pady=10)
        premios_login_frame.grid_remove() 

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Pr√©mios de Login."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Pr√©mios de Login")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Pr√©mios de Login")

        # Widgets dentro do Pr√©mios de Login
        # Label T√≠tulo
        label_premios_login = ttk.Label(
            premios_login_frame,
            text="Pr√©mios de Login",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_premios_login.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))


        # Titulo Pr√©mios de Login
        label_premios_login = ttk.Label(
            premios_login_frame,
            text="Pr√©mios de Login:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_premios_login.grid(row=1, column=0, sticky="w", pady=5, padx=10)    
    
        # Descri√ß√£o Pr√©mios de Login
        descricao_premios_login = ttk.Label(
            premios_login_frame,
            text="Introduz os Pr√©mios de Login na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_premios_login.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Pr√©mios de Login
        self.entrada_premios_login = tk.Text(premios_login_frame, height=1, wrap=tk.WORD)
        self.entrada_premios_login.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_premios_login.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_premios_login.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_premios_login.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_premios_login.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_premios_login))
        self.caixas_texto.append(self.entrada_premios_login)
        self.associar_botao_filtro(self.entrada_premios_login)
        
        # Imagem do Pr√©mios de Login
        label_imagem_premios_login = ttk.Label(
            premios_login_frame,
            text="Imagem dos Pr√©mios de Login:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_premios_login.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_premios_login = ttk.Label(
            premios_login_frame,
            text="Mete o link da imagem dos Pr√©mios de Login na sua linha respectiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_premios_login.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_premios_login = tk.Text(premios_login_frame, height=1, wrap=tk.WORD)
        self.entrada_imagem_premios_login.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_premios_login.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_premios_login.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_premios_login.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_premios_login.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_premios_login))
        self.caixas_texto.append(self.entrada_imagem_premios_login)
        
        
        
        
        # Retorno de Conte√∫do ###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir_ret_conteudo = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar Categoria de Retorno de Conte√∫do",
            command=lambda: alternar_visibilidade(
                ret_conteudo_frame,
                botao_expandir_ret_conteudo,
                "Adicionar Categoria de Retorno de Conte√∫do",
                "Remover Categoria de Retorno de Conte√∫do"
            )
        )


        botao_expandir_ret_conteudo.grid(row=106, column=0, sticky="w", padx=10, pady=(20, 5))

        # Frame expans√≠vel (LabelFrame) para "Retorno de Conte√∫do"
        ret_conteudo_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        ret_conteudo_frame.grid(row=107, column=0, sticky="ew", padx=10, pady=10)
        ret_conteudo_frame.grid_remove()

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao):
            """Alterna a visibilidade dos widgets na se√ß√£o de Retorno de Conte√∫do."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o LabelFrame
                botao.config(text="Adicionar Categoria de Retorno de Conte√∫do")
            else:
                frame.grid()  # Mostra o LabelFrame
                botao.config(text="Remover Categoria de Retorno de Conte√∫do")

        # Widgets dentro do Retorno de Conte√∫do
        # Label T√≠tulo
        label_ret_conteudo = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Conte√∫do",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_ret_conteudo.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))

        # Retorno de Miss√µes
        label_ret_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_ret_missoes.grid(row=1, column=0, sticky="w", pady=5, padx=10)

        descricao_ret_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as Miss√µes que retornaram.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_ret_missoes.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_ret_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_ret_missoes.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_ret_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_ret_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_ret_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_ret_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_ret_missoes))
        self.caixas_texto.append(self.entrada_ret_missoes)
        self.associar_botao_filtro(self.entrada_ret_missoes)


        # Recompensa de Miss√µes
        label_recomp_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Recompensa de Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_recomp_missoes.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        descricao_recomp_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as recompensas para cada miss√£o na sua linha respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recomp_missoes.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_recomp_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_recomp_missoes.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recomp_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recomp_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recomp_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recomp_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recomp_missoes))
        self.caixas_texto.append(self.entrada_recomp_missoes)
        self.associar_botao_filtro(self.entrada_recomp_missoes)
        
        
        # Imagens das Miss√µes
        label_img_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Imagens das Miss√µes:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkgreen"
        )
        label_img_missoes.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_img_missoes = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens para cada miss√£o respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_img_missoes.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_img_missoes = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_img_missoes.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_img_missoes.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_img_missoes.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_img_missoes.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_img_missoes.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_img_missoes))
        self.caixas_texto.append(self.entrada_img_missoes)

        # Retorno de Eventos de Modo Livre
        label_ret_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Retorno de Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_ret_eventos.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_ret_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os Eventos de Modo Livre que retornaram.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_ret_eventos.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_ret_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_ret_eventos.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_ret_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_ret_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_ret_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_ret_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_ret_eventos))
        self.caixas_texto.append(self.entrada_ret_eventos)
        self.associar_botao_filtro(self.entrada_ret_eventos)
        
        
        # Recompensa de Eventos de Modo Livre
        label_recomp_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Recompensa de Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_recomp_eventos.grid(row=13, column=0, sticky="w", pady=5, padx=10)

        descricao_recomp_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz as recompensas para cada Evento de Modo Livre na sua linha respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recomp_eventos.grid(row=14, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_recomp_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_recomp_eventos.grid(row=15, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recomp_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recomp_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recomp_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recomp_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recomp_eventos))
        self.caixas_texto.append(self.entrada_recomp_eventos)
        self.associar_botao_filtro(self.entrada_recomp_eventos)

        # Imagens dos Eventos de Modo Livre
        label_img_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Imagens dos Eventos de Modo Livre:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkred"
        )
        label_img_eventos.grid(row=16, column=0, sticky="w", pady=5, padx=10)

        descricao_img_eventos = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens para cada Evento de Modo Livre respetiva.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_img_eventos.grid(row=17, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_img_eventos = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_img_eventos.grid(row=18, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_img_eventos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_img_eventos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_img_eventos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_img_eventos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_img_eventos))
        self.caixas_texto.append(self.entrada_img_eventos)

        # Banner do Retorno de Conte√∫do
        label_banner = ttk.Label(
            ret_conteudo_frame,
            text="Banner do Retorno de Conte√∫do:",
            font=("TkDefaultFont", 10, "bold"),
            foreground="darkblue"
        )
        label_banner.grid(row=19, column=0, sticky="w", pady=5, padx=10)

        descricao_banner = ttk.Label(
            ret_conteudo_frame,
            text="Introduz os URLs das imagens que fazem o banner. Podes meter todas seguidas separadas por uma v√≠rgula \",\" ou cada uma na sua linha.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_banner.grid(row=20, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_banner = tk.Text(ret_conteudo_frame, height=1, wrap=tk.WORD)
        self.entrada_banner.grid(row=21, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_banner.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_banner.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_banner.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_banner.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_banner))
        self.caixas_texto.append(self.entrada_banner)

        
        
        
    


        
        #"Desafio Semanal###################################################################
        label_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Desafio Semanal", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_desafio_semanal.grid(row=200, column=0, sticky="w", padx=10, pady=(20, 10))
        
        #Objectivo do Evento Semanal#######
        #Titulo
        label_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Objectivo do Evento Semanal:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_desafio_semanal.grid(row=201, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_desafio_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a descri√ß√£o do objectivo semanal.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_desafio_semanal.grid(row=202, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto
        self.entrada_desafio_semanal = ttk.Entry(self.frame_deslocavel)
        self.entrada_desafio_semanal.grid(row=203, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_desafio_semanal.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_desafio_semanal.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_desafio_semanal)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_desafio_semanal)

        
        #Recompensa Objectivo Semanal#######
        #Titulo
        label_recompensa_objectivo_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Recompensa:", 
            font=("TkDefaultFont", 10, "bold")        
            )
        label_recompensa_objectivo_semanal.grid(row=204, column=0, sticky="w", pady=5, padx=10)

        #Descri√ß√£o
        descricao_recompensa_objectivo_semanal = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o valor da recompensa", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
            )
        descricao_recompensa_objectivo_semanal.grid(row=205, column=0, sticky="w", padx=10, pady=(0, 5))
        
        #Caixa de texto   

        self.entrada_recompensa_objectivo_semanal = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_recompensa_objectivo_semanal.insert(tk.END, "GTA$ 100.000")
        self.entrada_recompensa_objectivo_semanal.grid(row=206, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_objectivo_semanal.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event), event.widget.tag_add("sel", "1.0", "end-1c")))
        self.entrada_recompensa_objectivo_semanal.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_objectivo_semanal.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_objectivo_semanal.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_objectivo_semanal))
        self.entrada_recompensa_objectivo_semanal.bind("<Button-1>", self.scroll_para_cursor)  # Mouse click
        self.entrada_recompensa_objectivo_semanal.bind("<Up>", self.scroll_para_cursor)        # Up arrow
        self.entrada_recompensa_objectivo_semanal.bind("<Down>", self.scroll_para_cursor)      # Down arrow
        
        self.caixas_texto.append(self.entrada_recompensa_objectivo_semanal)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_recompensa_objectivo_semanal)



        #B√≥nus de Atividade###################################################################
        # Bot√£o para expandir/colapsar
        botao_expandir = ttk.Button(
            self.frame_deslocavel,
            text="Adicionar B√≥nus de Atividade",
            command=lambda: alternar_visibilidade(
                bonus_atividade_frame,
                botao_expandir,
                "Adicionar B√≥nus de Atividade",
                "Remover B√≥nus de Atividade"
            )
        )

        botao_expandir.grid(row=300, column=0, sticky="w", padx=10, pady=(20, 5))
        
        
        # Frame expans√≠vel (LabelFrame) para "B√≥nus de Atividade"
        bonus_atividade_frame = ttk.LabelFrame(
            self.frame_deslocavel,
            text="",
            labelanchor="n",
            relief="groove"
        )
        bonus_atividade_frame.grid(row=301, column=0, sticky="ew", padx=10, pady=10)
        bonus_atividade_frame.grid_remove() 

        # Fun√ß√£o para alternar visibilidade
        def alternar_visibilidade(frame, botao, texto_expandir, texto_colapsar):
            """Alterna a visibilidade de um frame e ajusta o texto do bot√£o."""
            if frame.winfo_ismapped():
                frame.grid_remove()  # Esconde o frame
                botao.config(text=texto_expandir)
            else:
                frame.grid()  # Mostra o frame
                botao.config(text=texto_colapsar)


        # Widgets dentro do bonus_atividade_frame
        # Label T√≠tulo
        label_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="B√≥nus de Atividade",
            font=("Arial", 16, "bold"),
            foreground="blue"
        )
        label_bonus_atividade.grid(row=0, column=0, sticky="nw", padx=10, pady=(10, 10))

        # Label Objectivo
        label_objetivo_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Objectivo do B√≥nus de Atividade:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_objetivo_bonus.grid(row=1, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Introduz a descri√ß√£o do objectivo semanal.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_bonus_atividade.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_bonus_atividade.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_bonus_atividade)
        self.associar_botao_filtro(self.entrada_bonus_atividade)
        
        # Label Recompensa
        label_recompensa_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Recompensa do Bonus:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_recompensa_bonus_atividade.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o Recompensa
        descricao_recompensa_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Introduz o valor da recompensa do b√≥nus de atividade",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_recompensa_bonus_atividade.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto Recompensa
        self.entrada_recompensa_bonus_atividade = tk.Text(bonus_atividade_frame, height=1, wrap=tk.WORD)
        self.entrada_recompensa_bonus_atividade.grid(row=6, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_recompensa_bonus_atividade.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_bonus_atividade.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_bonus_atividade.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_bonus_atividade))
        self.caixas_texto.append(self.entrada_recompensa_bonus_atividade)
        self.associar_botao_filtro(self.entrada_recompensa_bonus_atividade)

        # Timeframe
        label_timeframe_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Timeframe da Oferta:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_timeframe_bonus.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        descricao_timeframe_bonus_atividade = ttk.Label(
            bonus_atividade_frame,
            text="Dentro de quanto tempo √© que ser√° entregue o b√≥nus?",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_timeframe_bonus_atividade.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_timeframe_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_timeframe_bonus_atividade.grid(row=9, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_timeframe_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_timeframe_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_timeframe_bonus_atividade)

        # Imagem do B√≥nus de Atividade
        label_imagem_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Imagem do B√≥nus de Atividade:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_bonus.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        descricao_imagem_bonus = ttk.Label(
            bonus_atividade_frame,
            text="Mete o link da imagem do b√≥nus de atividade",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_imagem_bonus.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_imagem_bonus_atividade = ttk.Entry(bonus_atividade_frame)
        self.entrada_imagem_bonus_atividade.grid(row=12, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_bonus_atividade.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_bonus_atividade.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_imagem_bonus_atividade)

        
        
        # Atividades de B√≥nus GTA$ e RP ###################################################################
        
        label_atividade_bonus_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Atividades de B√≥nus GTA$ e RP", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_atividade_bonus_gta_rp.grid(row=400, column=0, sticky="ew", padx=10, pady=(20, 10))              


        # Nome das Atividades #######
        # Titulo
        label_nome_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Nome das Atividades de B√≥nus GTA$ e RP:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_atividades_gta_rp.grid(row=401, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a descri√ß√£o do objectivo das atividades de b√≥nus GTA$ e RP.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_atividades_gta_rp.grid(row=402, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_atividades_gta_rp = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_nome_atividades_gta_rp.grid(row=403, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_atividades_gta_rp.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_nome_atividades_gta_rp.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_nome_atividades_gta_rp.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_nome_atividades_gta_rp.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_nome_atividades_gta_rp))
        
        self.caixas_texto.append(self.entrada_nome_atividades_gta_rp)
        self.associar_botao_filtro(self.entrada_nome_atividades_gta_rp)

        # Imagem das Atividades de B√≥nus GTA$ e RP #######


        # Titulo
        label_imagem_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem das Atividades de B√≥nus GTA$ e RP:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_atividades_gta_rp.grid(row=404, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_atividades_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Mete o url da imagem de cada atividade na linha correspondente", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_atividades_gta_rp.grid(row=405, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_atividades_gta_rp = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_imagem_atividades_gta_rp.grid(row=406, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_atividades_gta_rp.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_imagem_atividades_gta_rp.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_imagem_atividades_gta_rp.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_imagem_atividades_gta_rp.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_imagem_atividades_gta_rp))

        self.caixas_texto.append(self.entrada_imagem_atividades_gta_rp)





    # Descontos ###################################################################
        
        label_atividade_bonus_gta_rp = ttk.Label(
            self.frame_deslocavel, 
            text="Descontos", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_atividade_bonus_gta_rp.grid(row=500, column=0, sticky="ew", padx=10, pady=(20, 10))      


        # Imagem dos Descontos #######
        # Titulo
        label_imagem_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem dos Descontos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_descontos.grid(row=501, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto dos descontos, se houver alguma", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_descontos.grid(row=21, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_descontos = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_descontos.grid(row=502, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_descontos.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_imagem_descontos.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_imagem_descontos)
        
        self.caixas_texto.append(self.entrada_nome_atividades_gta_rp)
        

        # Descontos
        # Titulo
        label_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Descontos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_descontos.grid(row=503, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_descontos = ttk.Label(
            self.frame_deslocavel, 
            text="Lista dos descontos", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_descontos.grid(row=504, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_descontos = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_descontos.grid(row=505, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_descontos.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_descontos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_descontos.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_descontos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_descontos))

        self.caixas_texto.append(self.entrada_descontos)
        self.associar_botao_filtro(self.entrada_descontos)





        # Gun Van ###################################################################
        
        label_gunvan = ttk.Label(
            self.frame_deslocavel, 
            text="Van de Arsenal (Gun Van)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_gunvan.grid(row=600, column=0, sticky="ew", padx=10, pady=(20, 10))      


        # gunvan
        # Titulo
        label_gunvan= ttk.Label(
            self.frame_deslocavel, 
            text="Lista de Armas:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_gunvan.grid(row=601, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_gunvan= ttk.Label(
            self.frame_deslocavel, 
            text="Mete aqui a lista de armas da Gun Van", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_gunvan.grid(row=602, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_gunvan = tk.Text(self.frame_deslocavel, height=5, wrap=tk.WORD)
        self.entrada_gunvan.grid(row=603, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_gunvan.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event)))
        self.entrada_gunvan.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_gunvan.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_gunvan.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_gunvan))

        self.caixas_texto.append(self.entrada_descontos)
        self.associar_botao_filtro(self.entrada_gunvan)


    
    
    
    # Roubos do Ferro-Velho (Salvage Yard Robberies) ###################################################################
        
        label_salvageyard = ttk.Label(
            self.frame_deslocavel, 
            text="Roubos do Ferro-Velho (Salvage Yard Robberies)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_salvageyard.grid(row=700, column=0, sticky="ew", padx=10, pady=(20, 10))      


        # Heist 1
        # Titulo golpe
        titulo_salvageyard_heist1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 1", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist1.grid(row=701, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist1= ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 1", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist1.grid(row=702, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        
        self.opcao_golpe1 = tk.StringVar()  # Vari√°vel de controle para o Golpe 1

        opcoes_golpe1 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]
        
        
        for idx, opcao in enumerate(opcoes_golpe1):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe1,
                value=opcao
            ).grid(row=703 + idx, column=0, padx=10, pady=2, sticky="w")
        
        
        
        # Nome do veiculo
        titulo_salvageyard_veiculo1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo1.grid(row=708, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo1= ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 1", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo1.grid(row=709, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo1 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo1.grid(row=710, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo1.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo1.bind('<Return>', self.proximo_campo)
        
        self.caixas_texto.append(self.entrada_salvageyard_veiculo1)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo1)
        
        # Reclam√°vel?
        self.reclamavel_veiculo1 = tk.BooleanVar()  
        checkbutton_reclamavel = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo1,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel.grid(row=711, column=0, padx=10, pady=5, sticky="w")
        
        
        # Heist 2
        # Titulo golpe
        titulo_salvageyard_heist2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 2", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist2.grid(row=712, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist2 = ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 2", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist2.grid(row=713, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        self.opcao_golpe2 = tk.StringVar()  # Vari√°vel de controle para o Golpe 2

        opcoes_golpe2 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]

        for idx, opcao in enumerate(opcoes_golpe2):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe2,
                value=opcao
            ).grid(row=714 + idx, column=0, padx=10, pady=2, sticky="w")

        # Nome do veiculo
        titulo_salvageyard_veiculo2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo2.grid(row=719, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo2 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 2", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo2.grid(row=720, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo2 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo2.grid(row=721, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo2.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo2.bind('<Return>', self.proximo_campo)

        self.caixas_texto.append(self.entrada_salvageyard_veiculo2)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo2)

        # Reclam√°vel?
        self.reclamavel_veiculo2 = tk.BooleanVar()
        checkbutton_reclamavel2 = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo2,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel2.grid(row=722, column=0, padx=10, pady=5, sticky="w")


        # Heist 3
        # Titulo golpe
        titulo_salvageyard_heist3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Golpe 3", 
            font=("TkDefaultFont", 12, "bold")
        )
        titulo_salvageyard_heist3.grid(row=723, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o golpe
        descricao_salvageyard_heist3 = ttk.Label(
            self.frame_deslocavel, 
            text="Escolhe o titulo do Golpe 3", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_heist3.grid(row=724, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Bot√µes de r√°dio
        self.opcao_golpe3 = tk.StringVar()  # Vari√°vel de controle para o Golpe 3

        opcoes_golpe3 = [
            "O Roubo do Duggan (The Duggan Robbery)",
            "O Roubo do Gangbanger (The Gangbanger Robbery)",
            "O Roubo do Cargueiro (The Cargo Ship Robbery)",
            "O Roubo do Podio (The Podium Robbery)",
            "O Roubo do McTony (The McTony Robbery)"
        ]

        for idx, opcao in enumerate(opcoes_golpe3):
            ttk.Radiobutton(
                self.frame_deslocavel,
                text=opcao,
                variable=self.opcao_golpe3,
                value=opcao
            ).grid(row=725 + idx, column=0, padx=10, pady=2, sticky="w")

        # Nome do veiculo
        titulo_salvageyard_veiculo3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Veiculo", 
            font=("TkDefaultFont", 10, "bold")
        )
        titulo_salvageyard_veiculo3.grid(row=730, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o Veiculo
        descricao_salvageyard_veiculo3 = ttk.Label(
            self.frame_deslocavel, 
            text="Nome para o veiculo do golpe 3", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_salvageyard_veiculo3.grid(row=731, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_salvageyard_veiculo3 = ttk.Entry(self.frame_deslocavel)
        self.entrada_salvageyard_veiculo3.grid(row=732, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_salvageyard_veiculo3.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_salvageyard_veiculo3.bind('<Return>', self.proximo_campo)

        self.caixas_texto.append(self.entrada_salvageyard_veiculo3)
        self.associar_botao_filtro(self.entrada_salvageyard_veiculo3)

        # Reclam√°vel?
        self.reclamavel_veiculo3 = tk.BooleanVar()
        checkbutton_reclamavel3 = ttk.Checkbutton(
            self.frame_deslocavel,
            text="Reclam√°vel",
            variable=self.reclamavel_veiculo3,
            onvalue=True,
            offvalue=False
        )
        checkbutton_reclamavel3.grid(row=733, column=0, padx=10, pady=5, sticky="w")



    # Ve√≠culo do P√≥dio###################################################################
        label_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culo do P√≥dio", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_veiculo_podio.grid(row=800, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Ve√≠culo#######
        # T√≠tulo
        label_nome_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Ve√≠culo:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_veiculo_podio.grid(row=801, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_veiculo_podio = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do ve√≠culo exibido no p√≥dio.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_veiculo_podio.grid(row=802, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_veiculo_podio = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_veiculo_podio.grid(row=803, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_veiculo_podio.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_veiculo_podio.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_veiculo_podio)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_veiculo_podio)





        # Novo Desafio do Encontro de Carros (LS Car Meet) ###################################################################
        label_ls_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Novo Desafio do Encontro de Carros (LS Car Meet)", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_ls_car_meet.grid(row=900, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Desafio #######
        # T√≠tulo
        label_nome_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Desafio:", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_nome_desafio_car_meet.grid(row=901, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do desafio do encontro de carros.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_desafio_car_meet.grid(row=902, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_desafio_car_meet = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_desafio_car_meet.grid(row=903, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_desafio_car_meet.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_nome_desafio_car_meet.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_nome_desafio_car_meet)
        self.associar_botao_filtro(self.entrada_nome_desafio_car_meet)


        # Por quantos dias? #######
        # T√≠tulo
        label_dias_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Por quantos dias?", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_dias_desafio_car_meet.grid(row=904, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_dias_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Por quantos dias seguidos deves manter o resultado?.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_dias_desafio_car_meet.grid(row=905, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_dias_desafio_car_meet = ttk.Entry(self.frame_deslocavel)
        self.entrada_dias_desafio_car_meet.grid(row=906, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_dias_desafio_car_meet.insert(tk.END, "3")
        self.entrada_dias_desafio_car_meet.bind("<FocusIn>", lambda event: (self.scroll_para_cursor(event), self.entrada_dias_desafio_car_meet.select_range(0, tk.END)))
        self.entrada_dias_desafio_car_meet.bind('<Return>', self.proximo_campo)
        self.caixas_texto.append(self.entrada_dias_desafio_car_meet)

        # Recompensa do Desafio #######
        # T√≠tulo
        label_recompensa_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Recompensa:", 
            font=("TkDefaultFont", 10, "bold")        
        )
        label_recompensa_desafio_car_meet.grid(row=907, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_recompensa_desafio_car_meet = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a recompensa para completar o desafio do encontro de carros.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_recompensa_desafio_car_meet.grid(row=908, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_recompensa_desafio_car_meet = tk.Text(self.frame_deslocavel, height=1, wrap=tk.WORD)
        self.entrada_recompensa_desafio_car_meet.grid(row=909, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_recompensa_desafio_car_meet.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_recompensa_desafio_car_meet.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_recompensa_desafio_car_meet.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_recompensa_desafio_car_meet))
        self.entrada_recompensa_desafio_car_meet.bind("<Button-1>", self.scroll_para_cursor)
        self.entrada_recompensa_desafio_car_meet.bind("<Up>", self.scroll_para_cursor)
        self.entrada_recompensa_desafio_car_meet.bind("<Down>", self.scroll_para_cursor)

        self.caixas_texto.append(self.entrada_recompensa_desafio_car_meet)
        self.associar_botao_filtro(self.entrada_recompensa_desafio_car_meet)



    
    # Novo Desafio do Encontro de Carros (Test Rides) ###################################################################

        # T√≠tulo principal
        label_test_rides_title = ttk.Label(
            self.frame_deslocavel, 
            text="Test Rides", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_test_rides_title.grid(row=1000, column=0, sticky="w", padx=10, pady=(20, 10))



        # Test Rides ##########

        # T√≠tulo
        label_test_rides = ttk.Label(
            self.frame_deslocavel, 
            text="Test Rides:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_test_rides.grid(row=1001, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_test_rides = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome dos veiculos que estao para teste na sua linha especifica", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_test_rides.grid(row=1002, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        
        def limitar_linhas(event, widget):
            # Obter o conte√∫do atual da caixa de texto
            lines = widget.get(1.0, tk.END).splitlines()
            
            # Se houver mais de 3 linhas, cortar para 3
            if len(lines) > 3:
                widget.delete(f"4.0", tk.END)  # Excluir o conte√∫do ap√≥s a 3¬™ linha
            # Se houver menos de 3 linhas, adicionar uma linha em branco
            elif len(lines) < 3:
                widget.insert(tk.END, "\n")
                

        self.entrada_test_rides = tk.Text(self.frame_deslocavel, height=3, wrap=tk.WORD)  # Ajustado para 3 linhas de altura
        self.entrada_test_rides.grid(row=1003, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_test_rides.insert(tk.END, "\n" * 3)
        self.entrada_test_rides.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_test_rides.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_test_rides))
        self.entrada_test_rides.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_test_rides.bind("<Button-1>", self.scroll_para_cursor)
        self.entrada_test_rides.bind("<Up>", self.scroll_para_cursor)
        self.entrada_test_rides.bind("<Down>", self.scroll_para_cursor)

        self.caixas_texto.append(self.entrada_test_rides)
        self.associar_botao_filtro(self.entrada_test_rides)

    
    
    
    # Ve√≠culo de Teste Premium###################################################################

        # T√≠tulo principal
        label_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culo de Teste Premium", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_veiculo_teste_premium.grid(row=1004, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Ve√≠culo#######

        # T√≠tulo
        label_nome_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Ve√≠culo:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_veiculo_teste_premium.grid(row=1005, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_veiculo_teste_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do ve√≠culo de teste premium.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_veiculo_teste_premium.grid(row=1006, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_veiculo_teste_premium = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_veiculo_teste_premium.grid(row=1007, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_veiculo_teste_premium.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_veiculo_teste_premium.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_veiculo_teste_premium)  # Adiciona a entrada √† lista de caixas de texto
        self.associar_botao_filtro(self.entrada_nome_veiculo_teste_premium)



        # Luxury Autos ###################################################################

        # T√≠tulo principal
        label_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Luxury Autos", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_luxury_autos.grid(row=1100, column=0, sticky="ew", padx=10, pady=(20, 10))

        # Imagem Luxury Autos ###################################################################
        # T√≠tulo
        label_imagem_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem Luxury Autos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_luxury_autos.grid(row=1101, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto da Luxury Autos desta semana", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_luxury_autos.grid(row=1102, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_luxury_autos = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_luxury_autos.grid(row=1103, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_luxury_autos.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_imagem_luxury_autos.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_imagem_luxury_autos)  # Adiciona a entrada √† lista de caixas

        # Ve√≠culos Luxury Autos ###################################################################

        # T√≠tulo
        label_veiculos_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culos Luxury Autos:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_veiculos_luxury_autos.grid(row=1104, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_veiculos_luxury_autos = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz os ve√≠culos dispon√≠veis da Luxury Autos.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_veiculos_luxury_autos.grid(row=1105, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_veiculos_luxury_autos = tk.Text(self.frame_deslocavel, height=2, wrap=tk.WORD)
        self.entrada_veiculos_luxury_autos.grid(row=1106, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_veiculos_luxury_autos.bind("<FocusIn>", lambda event: self.scroll_para_cursor(event))
        self.entrada_veiculos_luxury_autos.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_veiculos_luxury_autos.bind("<Return>", lambda event: self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.entrada_veiculos_luxury_autos.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_veiculos_luxury_autos))

        self.caixas_texto.append(self.entrada_veiculos_luxury_autos)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_veiculos_luxury_autos)




    # Premium Deluxe Motorsport ###################################################################

        # T√≠tulo principal
        label_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Premium Deluxe Motorsport", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_premium_deluxe_motorsport.grid(row=1200, column=0, sticky="ew", padx=10, pady=(20, 10))

        # Imagem Premium Deluxe Motorsport ###################################################################

        # T√≠tulo
        label_imagem_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Imagem Premium Deluxe Motorsport:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_imagem_premium_deluxe_motorsport.grid(row=1201, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_imagem_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz a foto da Premium Deluxe Motorsport desta semana", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_imagem_premium_deluxe_motorsport.grid(row=1202, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_imagem_premium_deluxe_motorsport = ttk.Entry(self.frame_deslocavel)
        self.entrada_imagem_premium_deluxe_motorsport.grid(row=1203, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_imagem_premium_deluxe_motorsport.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_imagem_premium_deluxe_motorsport.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_imagem_premium_deluxe_motorsport)  # Adiciona a entrada √† lista de caixas

        # Ve√≠culos Premium Deluxe Motorsport ###################################################################

        # T√≠tulo
        label_veiculos_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Ve√≠culos Premium Deluxe Motorsport:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_veiculos_premium_deluxe_motorsport.grid(row=1204, column=0, sticky="ew", pady=5, padx=10)

        # Descri√ß√£o
        descricao_veiculos_premium_deluxe_motorsport = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz os ve√≠culos dispon√≠veis da Premium Deluxe Motorsport.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_veiculos_premium_deluxe_motorsport.grid(row=1205, column=0, sticky="ew", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_veiculos_premium_deluxe_motorsport = tk.Text(self.frame_deslocavel, height=5, wrap=tk.WORD)
        self.entrada_veiculos_premium_deluxe_motorsport.grid(row=1206, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<FocusIn>", lambda event: self.scroll_para_cursor(event))
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<Return>", lambda event: self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.entrada_veiculos_premium_deluxe_motorsport.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_veiculos_premium_deluxe_motorsport))

        self.caixas_texto.append(self.entrada_veiculos_premium_deluxe_motorsport)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_veiculos_premium_deluxe_motorsport)



        # Corrida Premium ###################################################################
        label_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Corrida Premium", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_corrida_premium.grid(row=1300, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome da Corrida Premium #######
        # T√≠tulo
        label_nome_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Nome da Corrida:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_corrida_premium.grid(row=1301, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_corrida_premium = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome da corrida premium.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_corrida_premium.grid(row=1302, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_corrida_premium = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_corrida_premium.grid(row=1303, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_corrida_premium.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_corrida_premium.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_corrida_premium)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_corrida_premium)




        # Contra Rel√≥gio ###################################################################
        label_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio.grid(row=1400, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio #######
        # T√≠tulo
        label_nome_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio.grid(row=1401, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio.grid(row=1402, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio.grid(row=1403, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio)




        # Contra Rel√≥gio HSW ###################################################################
        label_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio HSW", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio_hsw.grid(row=1500, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio HSW #######
        # T√≠tulo
        label_nome_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio HSW:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio_hsw.grid(row=1501, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio_hsw = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio HSW.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio_hsw.grid(row=1502, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio_hsw = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio_hsw.grid(row=1503, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio_hsw.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio_hsw.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio_hsw)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio_hsw)




        # Contra Rel√≥gio RC ###################################################################
        label_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Contra Rel√≥gio RC", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_contra_relogio_rc.grid(row=1600, column=0, sticky="w", padx=10, pady=(20, 10))

        # Nome do Contra Rel√≥gio RC #######
        # T√≠tulo
        label_nome_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Nome do Contra Rel√≥gio RC:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_nome_contra_relogio_rc.grid(row=1601, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_nome_contra_relogio_rc = ttk.Label(
            self.frame_deslocavel, 
            text="Introduz o nome do contra rel√≥gio RC.", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_nome_contra_relogio_rc.grid(row=1602, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_nome_contra_relogio_rc = ttk.Entry(self.frame_deslocavel)
        self.entrada_nome_contra_relogio_rc.grid(row=1603, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_nome_contra_relogio_rc.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_nome_contra_relogio_rc.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_nome_contra_relogio_rc)  # Adiciona a entrada √† lista de caixas
        self.associar_botao_filtro(self.entrada_nome_contra_relogio_rc)
        
        
        # Mais Info ###################################################################
        label_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mais Info", 
            font=("Arial", 16, "bold"), 
            foreground="blue"
        )
        label_mais_info.grid(row=2000, column=0, sticky="w", padx=10, pady=(20, 10))

        # Descri√ß√£o da Mais Info #######
        # T√≠tulo
        label_descricao_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mais Info:", 
            font=("TkDefaultFont", 10, "bold")
        )
        label_descricao_mais_info.grid(row=2001, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o
        descricao_descricao_mais_info = ttk.Label(
            self.frame_deslocavel, 
            text="Mete o url da pagina de newswire desta semana em pt:", 
            font=("TkDefaultFont", 9), 
            foreground="gray"
        )
        descricao_descricao_mais_info.grid(row=2002, column=0, sticky="w", padx=10, pady=(0, 5))

        # Caixa de texto
        self.entrada_descricao_mais_info = ttk.Entry(self.frame_deslocavel)
        self.entrada_descricao_mais_info.grid(row=2003, column=0, padx=10, pady=5, sticky="ew")
        self.entrada_descricao_mais_info.bind("<FocusIn>", self.scroll_para_cursor)  # Garante visibilidade da caixa ao focar
        self.entrada_descricao_mais_info.bind('<Return>', self.proximo_campo)  # Move para o pr√≥ximo campo ao pressionar Enter
        self.caixas_texto.append(self.entrada_descricao_mais_info)  # Adiciona a entrada √† lista de caixas

        self.caixas_texto.append(self.entrada_descricao_mais_info)  # Adiciona a entrada √† lista de caixas





            
    def scroll_para_cursor(self, event):
        """Garante que o cursor ou a caixa de texto em foco esteja vis√≠vel."""
        widget = event.widget
        if isinstance(widget, tk.Text) or isinstance(widget, ttk.Entry):
            self.tela.update_idletasks()  # Atualiza a geometria do Canvas

            # Calcula a posi√ß√£o do widget em rela√ß√£o ao Canvas
            widget_y = widget.winfo_rooty() - self.tela.winfo_rooty()
            canvas_height = self.tela.winfo_height()

            # Verifica se o widget est√° acima ou abaixo da √°rea vis√≠vel do Canvas
            if widget_y < 0:  # Fora da parte superior
                self.tela.yview_scroll(int(widget_y // -10), "units")
            elif widget_y + widget.winfo_height() > canvas_height:  # Fora da parte inferior
                self.tela.yview_scroll(int((widget_y + widget.winfo_height() - canvas_height) // 10), "units")


    
            
    def proximo_campo_com_tab(self, event):
        """Move o foco para o pr√≥ximo campo ao pressionar Tab"""
        current = event.widget
        next_index = self.caixas_texto.index(current) + 1
        if next_index < len(self.caixas_texto):
            self.caixas_texto[next_index].focus_set()
        return "break"



            

    def _no_roda_rato(self, event):
        """ Fun√ß√£o para rolar a tela com o uso do rato """
        self.tela.yview_scroll(int(-1 * (event.delta / 120)), "units")
    
    #Botao Gerar BBCode
    def criar_botao_gerar(self):
        """Cria o bot√£o fixo Gerar BBCode"""
        self.frame_botao = ttk.Frame(self.aba_evento_semanal)
        self.frame_botao.grid(row=2, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)  # Fixa o bot√£o no final e centraliza
        self.frame_botao.grid_columnconfigure(0, weight=1)  # Centraliza o bot√£o dentro do frame
        self.aba_evento_semanal.grid_rowconfigure(2, weight=0)  # Fixa o bot√£o no final
        
        
        self.botao_gerar = ttk.Button(
            self.frame_botao, 
            text="Gerar BBCode",
            command=self.mostrar_preview
        )
        self.botao_gerar.pack(pady=5)
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        #################################################################################################################################################################
        ######################################################################### ABA Missoes ###########################################################################
        #################################################################################################################################################################
        
        
    def configurar_aba_missoes(self):
        """Configura a aba Miss√µes com estrutura organizada e responsiva."""

        # Criar estrutura de scroll
        self.tela_missoes = tk.Canvas(self.aba_missoes)
        self.barra_deslocamento_missoes = ttk.Scrollbar(self.aba_missoes, orient="vertical", command=self.tela_missoes.yview)

        self.frame_missoes = ttk.Frame(self.tela_missoes)
        self.window_id_missoes = self.tela_missoes.create_window((0, 0), window=self.frame_missoes, anchor="nw")

        self.tela_missoes.configure(yscrollcommand=self.barra_deslocamento_missoes.set)

        self.tela_missoes.grid(row=0, column=0, sticky="nsew")
        self.barra_deslocamento_missoes.grid(row=0, column=1, sticky="ns")

        self.aba_missoes.grid_columnconfigure(0, weight=1)
        self.aba_missoes.grid_rowconfigure(0, weight=1)

        self.frame_missoes.grid_columnconfigure(0, weight=1)

        # Ajustar rolagem ao conte√∫do
        def ajustar_scroll_missoes():
            self.tela_missoes.update_idletasks()
            bbox = self.tela_missoes.bbox("all")
            if bbox:
                self.tela_missoes.configure(scrollregion=bbox)

        self.frame_missoes.bind("<Configure>", lambda e: ajustar_scroll_missoes())

        # Garantir que os frames colaps√°veis sempre ocupem toda a largura
        self.aba_missoes.bind("<Configure>", self.ajustar_largura_missoes)

        # Adicionar suporte √† rolagem do mouse
        def rolagem_mouse(event):
            """Permite a rolagem da tela com a roda do mouse apenas se a janela estiver em foco."""
            if self.root.focus_displayof():
                self.tela_missoes.yview_scroll(-1 * (event.delta // 120), "units")

        def habilitar_scroll(event):
            """Ativa a rolagem com a roda do mouse."""
            self.root.bind_all("<MouseWheel>", rolagem_mouse)

        def desabilitar_scroll(event):
            """Desativa a rolagem com a roda do mouse quando o cursor sai da janela."""
            self.root.unbind_all("<MouseWheel>")

        self.tela_missoes.bind("<Enter>", habilitar_scroll)
        self.tela_missoes.bind("<Leave>", desabilitar_scroll)

        # Adicionar t√≠tulo principal
        ttk.Label(self.frame_missoes, text="Miss√µes da Semana", font=("TkDefaultFont", 12, "bold")).grid(
            row=0, column=0, pady=10, padx=10, sticky="w"
        )

        # Criar frames colaps√°veis
        self.criar_frame_corridas_acrobaticas(1)
        self.criar_frame_missoes_especiais(3)
        self.criar_frame_modo_adeversario(5)

        # Criar bot√£o "Gerar BBCode Miss√µes"
        self.frame_botao_missoes = ttk.Frame(self.aba_missoes)
        self.frame_botao_missoes.grid(row=1, column=0, sticky="ew", padx=10, pady=10)

        self.botao_gerar_bbcode_missoes = ttk.Button(self.frame_botao_missoes, text="Gerar BBCode Miss√µes", command=self.gerar_bbcode_missoes)
        self.botao_gerar_bbcode_missoes.pack(expand=True)

        # Ajustar layout para manter o bot√£o fixo no fundo
        self.aba_missoes.grid_rowconfigure(1, weight=0)


        
    def ajustar_largura_missoes(self, event=None):
        """Ajusta a largura dos frames colaps√°veis para ocupar a largura da aba menos 50 pixels."""
        largura_total = self.aba_missoes.winfo_width()
        nova_largura = max(largura_total - 50, 300)  # Garante um m√≠nimo de 300px

        self.tela_missoes.itemconfig(self.window_id_missoes, width=nova_largura)

        for widget in self.frame_missoes.winfo_children():
            widget.config(width=nova_largura)  # Aplica a nova largura aos frames internos




        
        
        
    def criar_frame_corridas_acrobaticas(self, linha):
        """Cria o frame colaps√°vel para Corridas Acrob√°ticas."""

        # Bot√£o para expandir/colapsar
        self.botao_expandir_corridas_acrobaticas = ttk.Button(self.frame_missoes, text="Corridas Acrob√°ticas ‚ñº", command=self.alternar_corridas_acrobaticas)
        self.botao_expandir_corridas_acrobaticas.grid(row=linha, column=0, sticky="ew", padx=10, pady=5)

        # Frame colaps√°vel
        self.frame_corridas_acrobaticas = ttk.Frame(self.frame_missoes, relief="ridge", borderwidth=2)
        self.frame_corridas_acrobaticas.grid(row=linha+1, column=0, sticky="ew", padx=10, pady=(0, 10))
        self.frame_corridas_acrobaticas.grid_remove()

        self.frame_missoes.grid_columnconfigure(0, weight=1)
        
        # Configurar as colunas para ocupar 50% cada
        self.frame_corridas_acrobaticas.grid_columnconfigure(0, weight=1, uniform="grupo")
        self.frame_corridas_acrobaticas.grid_columnconfigure(1, weight=1, uniform="grupo")

        
        
        # Widget URL
        self.label_corridas_acrobaticas_url = ttk.Label(self.frame_corridas_acrobaticas, text="URL da imagem ou v√≠deo de Capa:", font=("TkDefaultFont", 10, "bold"))
        self.label_corridas_acrobaticas_url.grid(row=1, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_url = ttk.Label(self.frame_corridas_acrobaticas, text="Coloca o link da imagem ou v√≠deo que ir√° servir de capa para as corridas acrob√°ticas.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_url.grid(row=2, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_url = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_url.grid(row=3, column=0, columnspan=2, padx=10, pady=5, sticky="ew")
        self.entrada_corridas_acrobaticas_url.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_url.bind('<Return>', self.proximo_campo_sem_nova_linha)
        self.entrada_corridas_acrobaticas_url.bind("<KeyRelease>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_url.bind("<Tab>", self.proximo_campo_com_tab)
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_url)

        # Widget Descri√ß√£o PT
        self.label_corridas_acrobaticas_descricao_pt = ttk.Label(self.frame_corridas_acrobaticas, text="Descri√ß√£o PT:", font=("TkDefaultFont", 10, "bold"))
        self.label_corridas_acrobaticas_descricao_pt.grid(row=4, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_pt = ttk.Label(self.frame_corridas_acrobaticas, text="Coloca a descri√ß√£o em portugu√™s.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_pt.grid(row=5, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_pt = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_pt.grid(row=6, column=0, columnspan=2, padx=10, pady=5, sticky="nsew")
        self.entrada_corridas_acrobaticas_pt.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_pt.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_pt.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_pt.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_pt))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_pt)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_pt)

        # Widget Descri√ß√£o EN
        self.label_corridas_acrobaticas_descricao_en = ttk.Label(self.frame_corridas_acrobaticas, text="Descri√ß√£o EN:", font=("TkDefaultFont", 10, "bold"))
        self.label_corridas_acrobaticas_descricao_en.grid(row=7, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_en = ttk.Label(self.frame_corridas_acrobaticas, text="Introduza a descri√ß√£o em ingl√™s.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_en.grid(row=8, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_en = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_en.grid(row=9, column=0, columnspan=2, padx=10, pady=5, sticky="nsew")
        self.entrada_corridas_acrobaticas_en.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_en.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_en.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_en.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_en))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_en)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_en)

        # Widget "Para"
        self.label_corridas_acrobaticas_para = ttk.Label(self.frame_corridas_acrobaticas, text="Para:", font=("TkDefaultFont", 9, "bold"))
        self.label_corridas_acrobaticas_para.grid(row=10, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_para = ttk.Label(self.frame_corridas_acrobaticas, text="N√∫mero de jogadores.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_para.grid(row=11, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_para = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_para.grid(row=12, column=0, columnspan=2, padx=10, pady=5, sticky="ew")

        # Widget "Local"
        self.label_corridas_acrobaticas_local = ttk.Label(self.frame_corridas_acrobaticas, text="Local:", font=("TkDefaultFont", 9, "bold"))
        self.label_corridas_acrobaticas_local.grid(row=13, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_local = ttk.Label(self.frame_corridas_acrobaticas, text="Localiza√ß√£o do evento.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_local.grid(row=14, column=0, sticky="w", padx=10, pady=(0, 5))

        # Checkbutton "Todo o Mapa"
        self.var_corridas_acrobaticas_todo_mapa = tk.BooleanVar()
        self.check_corridas_acrobaticas_todo_mapa = ttk.Checkbutton(
            self.frame_corridas_acrobaticas,
            text="Todo o Mapa",
            variable=self.var_corridas_acrobaticas_todo_mapa,
            command=lambda: self.preencher_entrada_se_marcado(self.var_corridas_acrobaticas_todo_mapa, self.entrada_corridas_acrobaticas_local, "Todo o Mapa")
        )
        self.check_corridas_acrobaticas_todo_mapa.grid(row=15, column=0, sticky="w", padx=10, pady=2)

        self.entrada_corridas_acrobaticas_local = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_local.grid(row=16, column=0, columnspan=2, padx=10, pady=5, sticky="ew")
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_local)

        # Widget "Frequ√™ncia"
        
        self.label_corridas_acrobaticas_frequencia = ttk.Label(self.frame_corridas_acrobaticas, text="Frequ√™ncia:", font=("TkDefaultFont", 9, "bold"))
        self.label_corridas_acrobaticas_frequencia.grid(row=17, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_frequencia = ttk.Label(self.frame_corridas_acrobaticas, text="Frequ√™ncia do evento.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_frequencia.grid(row=18, column=0, sticky="w", padx=10, pady=(0, 5))

        # CheckButton "Frequ√™ncia"
        self.var_corridas_acrobaticas_frequencia_permanente = tk.BooleanVar()
        check_corridas_acrobaticas_frequencia_permanente = ttk.Checkbutton(
            self.frame_corridas_acrobaticas,
            text="Permanente",
            variable=self.var_corridas_acrobaticas_frequencia_permanente
        )
        check_corridas_acrobaticas_frequencia_permanente.grid(row=19, column=0, sticky="w", padx=10, pady=5)

        self.var_corridas_acrobaticas_frequencia_semana_evento = tk.BooleanVar()
        check_corridas_acrobaticas_frequencia_semana_evento = ttk.Checkbutton(
            self.frame_corridas_acrobaticas,
            text="Permanente durante a Semana do Evento",
            variable=self.var_corridas_acrobaticas_frequencia_semana_evento
        )
        check_corridas_acrobaticas_frequencia_semana_evento.grid(row=20, column=0, sticky="w", padx=10, pady=5)


        self.entrada_corridas_acrobaticas_frequencia = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_frequencia.grid(row=21, column=0, columnspan=2, padx=10, pady=5, sticky="ew")

        # Widget "Voltas"
        self.label_corridas_acrobaticas_voltas = ttk.Label(self.frame_corridas_acrobaticas, text="Voltas:", font=("TkDefaultFont", 9, "bold"))
        self.label_corridas_acrobaticas_voltas.grid(row=22, column=0, sticky="w", pady=5, padx=10)

        self.descricao_corridas_acrobaticas_voltas = ttk.Label(self.frame_corridas_acrobaticas, text="N√∫mero de voltas.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_voltas.grid(row=23, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_numero_voltas = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_numero_voltas.grid(row=24, column=0, columnspan=2, padx=10, pady=5, sticky="ew")

        self.descricao_corridas_acrobaticas_voltas_padrao = ttk.Label(self.frame_corridas_acrobaticas, text="N√∫mero padr√£o de voltas.", font=("TkDefaultFont", 9), foreground="gray")
        self.descricao_corridas_acrobaticas_voltas_padrao.grid(row=25, column=0, sticky="w", padx=10, pady=(0, 5))

        self.entrada_corridas_acrobaticas_numero_padrao_voltas = ttk.Entry(self.frame_corridas_acrobaticas)
        self.entrada_corridas_acrobaticas_numero_padrao_voltas.grid(row=26, column=0, columnspan=2, padx=10, pady=5, sticky="ew")


        # Widget Como Funciona
        label_corridas_acrobaticas_como_funciona = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Como Funciona:",
            font=("TkDefaultFont", 10, "bold")
        )
        label_corridas_acrobaticas_como_funciona.grid(row=27, column=0, sticky="w", pady=5, padx=10)

        # Descri√ß√£o Como Funciona
        descricao_corridas_acrobaticas_como_funciona = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Explique como funciona esta atividade.",
            font=("TkDefaultFont", 9),
            foreground="gray"
        )
        descricao_corridas_acrobaticas_como_funciona.grid(row=28, column=0, sticky="w", padx=10, pady=(0, 5))

        # CheckButton "Adicionar Caminho menu pausa 'Corridas Acrob√°ticas'"
        self.var_corridas_acrobaticas_como_funciona_menu_pausa = tk.BooleanVar()
        check_corridas_acrobaticas_como_funciona_menu_pausa = ttk.Checkbutton(
            self.frame_corridas_acrobaticas,
            text="Adicionar Caminho menu pausa 'Corridas Acrob√°ticas'",
            variable=self.var_corridas_acrobaticas_como_funciona_menu_pausa
        )
        check_corridas_acrobaticas_como_funciona_menu_pausa.grid(row=29, column=0, sticky="w", padx=10, pady=5)

        # CheckButton "Adicionar Caminho Telefone 'Corridas Acrob√°ticas'"
        self.var_corridas_acrobaticas_como_funciona_tel = tk.BooleanVar()
        check_corridas_acrobaticas_como_funciona_tel = ttk.Checkbutton(
            self.frame_corridas_acrobaticas,
            text="Adicionar Caminho Telefone 'Corridas Acrob√°ticas'",
            variable=self.var_corridas_acrobaticas_como_funciona_tel
        )
        check_corridas_acrobaticas_como_funciona_tel.grid(row=29, column=1, sticky="w", padx=10, pady=5)


        # Caixa de texto Como Funciona
        self.entrada_corridas_acrobaticas_como_funciona = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_como_funciona.grid(row=30, column=0, padx=10, pady=5, sticky="nsew", columnspan=2)
        self.entrada_corridas_acrobaticas_como_funciona.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_como_funciona.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_como_funciona.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_como_funciona.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_como_funciona))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_como_funciona)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_como_funciona)

        # Widget Ve√≠culos
        label_corridas_acrobaticas_veiculos = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Ve√≠culos:",
            font=("TkDefaultFont", 11, "bold"),  # Maior destaque,
            foreground="red"
        )
        label_corridas_acrobaticas_veiculos.grid(row=33, column=0, sticky="w", pady=(20,5), padx=10, columnspan=2)

        # T√≠tulo Nome do Ve√≠culo
        label_corridas_acrobaticas_nome_veiculo = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Nome do Ve√≠culo:"
        )
        label_corridas_acrobaticas_nome_veiculo.grid(row=34, column=0, sticky="w", padx=10, pady=(5, 0))

        # Caixa Nome do Ve√≠culo
        self.entrada_corridas_acrobaticas_nome_veiculo = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_nome_veiculo.grid(row=35, column=0, padx=(10, 0), pady=1, sticky="ew")
        self.entrada_corridas_acrobaticas_nome_veiculo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_nome_veiculo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_nome_veiculo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_nome_veiculo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_nome_veiculo))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_nome_veiculo)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_nome_veiculo)

        # T√≠tulo Imagem do Ve√≠culo
        label_corridas_acrobaticas_imagem_veiculo = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Imagem do Ve√≠culo:"
        )
        label_corridas_acrobaticas_imagem_veiculo.grid(row=34, column=1, sticky="w", padx=10, pady=(5, 0))

        # Caixa Imagem do Ve√≠culo
        self.entrada_corridas_acrobaticas_imagem_veiculo = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_imagem_veiculo.grid(row=35, column=1, padx=(25, 1), pady=5, sticky="ew")
        self.entrada_corridas_acrobaticas_imagem_veiculo.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_imagem_veiculo.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_imagem_veiculo.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_imagem_veiculo.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_imagem_veiculo))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_imagem_veiculo)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_imagem_veiculo)

        # Widget Corridas
        label_corridas_acrobaticas_corridas = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Corridas:",
            font=("TkDefaultFont", 11, "bold"),  # Maior destaque
            foreground="red"
        )
        label_corridas_acrobaticas_corridas.grid(row=36, column=0, sticky="w", pady=(20,5), padx=10, columnspan=2)


        # T√≠tulo Lista de Corridas
        label_corridas_acrobaticas_lista_corridas = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Lista de Corridas:"
        )
        label_corridas_acrobaticas_lista_corridas.grid(row=37, column=0, sticky="w", padx=10, pady=(5, 0), columnspan=2)

        # Caixa Lista de Corridas
        self.entrada_corridas_acrobaticas_lista_corridas = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_lista_corridas.grid(row=38, column=0, padx=(10, 0), pady=5, sticky="ew", columnspan=2)
        self.entrada_corridas_acrobaticas_lista_corridas.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_lista_corridas.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_lista_corridas.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_lista_corridas.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_lista_corridas))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_lista_corridas)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_lista_corridas)

        # T√≠tulo Nome da Corrida
        label_corridas_acrobaticas_nome_corrida = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Nome da Corrida:"
        )
        label_corridas_acrobaticas_nome_corrida.grid(row=39, column=0, sticky="w", padx=10, pady=(5, 0), columnspan=2)

        # Caixa Nome da Corrida
        self.entrada_corridas_acrobaticas_nome_corrida = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_nome_corrida.grid(row=40, column=0, padx=(10, 0), pady=5, sticky="ew", columnspan=2)
        self.entrada_corridas_acrobaticas_nome_corrida.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_nome_corrida.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_nome_corrida.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_nome_corrida.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_nome_corrida))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_nome_corrida)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_nome_corrida)

        # T√≠tulo Descri√ß√£o da Corrida PT
        label_corridas_acrobaticas_descricao_pt = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Descri√ß√£o da Corrida PT:"
        )
        label_corridas_acrobaticas_descricao_pt.grid(row=41, column=0, sticky="w", padx=10, pady=(5, 0))

        # Caixa Descri√ß√£o da Corrida PT
        self.entrada_corridas_acrobaticas_descricao_pt = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_descricao_pt.grid(row=42, column=0, padx=(10, 0), pady=5, sticky="nsew")
        self.entrada_corridas_acrobaticas_descricao_pt.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_descricao_pt.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_descricao_pt.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_descricao_pt.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_descricao_pt))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_descricao_pt)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_descricao_pt)

        # T√≠tulo Descri√ß√£o da Corrida EN
        label_corridas_acrobaticas_descricao_en = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Descri√ß√£o da Corrida EN:"
        )
        label_corridas_acrobaticas_descricao_en.grid(row=41, column=1, sticky="w", padx=10, pady=(5, 0))

        # Caixa Descri√ß√£o da Corrida EN
        self.entrada_corridas_acrobaticas_descricao_en = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_descricao_en.grid(row=42, column=1, padx=(25, 1), pady=5, sticky="nsew")
        self.entrada_corridas_acrobaticas_descricao_en.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_descricao_en.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_descricao_en.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_descricao_en.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_descricao_en))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_descricao_en)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_descricao_en)

        # T√≠tulo Imagem da Corrida
        label_corridas_acrobaticas_imagem_corrida = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Imagem da Corrida:"
        )
        label_corridas_acrobaticas_imagem_corrida.grid(row=43, column=0, sticky="w", padx=10, pady=(5, 0))

        # Caixa Imagem da Corrida
        self.entrada_corridas_acrobaticas_imagem_corrida = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_imagem_corrida.grid(row=44, column=0, padx=(10, 0), pady=5, sticky="ew")
        self.entrada_corridas_acrobaticas_imagem_corrida.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_imagem_corrida.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_imagem_corrida.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_imagem_corrida.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_imagem_corrida))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_imagem_corrida)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_imagem_corrida)

        # T√≠tulo Imagem do Mapa da Corrida
        label_corridas_acrobaticas_imagem_mapa_corrida = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Imagem do Mapa da Corrida:"
        )
        label_corridas_acrobaticas_imagem_mapa_corrida.grid(row=43, column=1, sticky="w", padx=10, pady=(5, 0))

        # Caixa Imagem do Mapa da Corrida
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida.grid(row=44, column=1, padx=(25, 1), pady=5, sticky="ew")
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_imagem_mapa_corrida.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_imagem_mapa_corrida))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_imagem_mapa_corrida)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_imagem_mapa_corrida)
        
        
        # Widget Dicas
        label_corridas_acrobaticas_dicas = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Dicas:",
            font=("TkDefaultFont", 11, "bold"),  # Maior destaque
            foreground="red"
        )
        label_corridas_acrobaticas_dicas.grid(row=45, column=0, sticky="w", pady=(20, 5), padx=10, columnspan=2)

        # T√≠tulo Descri√ß√£o da Dica
        label_corridas_acrobaticas_descricao_dicas = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Descri√ß√£o das Dicas:"
        )
        label_corridas_acrobaticas_descricao_dicas.grid(row=46, column=0, sticky="w", padx=10, pady=(5, 0))

        # Caixa Descri√ß√£o da Dica
        self.entrada_corridas_acrobaticas_descricao_dicas = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_descricao_dicas.grid(row=47, column=0, padx=(10, 0), pady=5, sticky="nsew", columnspan=2)
        self.entrada_corridas_acrobaticas_descricao_dicas.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_descricao_dicas.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_descricao_dicas.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_descricao_dicas.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_descricao_dicas))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_descricao_dicas)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_descricao_dicas)

        # Widget V√≠deo de Guia
        label_corridas_acrobaticas_video_guia = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="V√≠deo de Guia:",
            font=("TkDefaultFont", 11, "bold"),  # Maior destaque
            foreground="red"
        )
        label_corridas_acrobaticas_video_guia.grid(row=48, column=0, sticky="w", pady=(20, 5), padx=10, columnspan=2)

        # T√≠tulo Descri√ß√£o do V√≠deo de Guia
        label_corridas_acrobaticas_descricao_video_guia = ttk.Label(
            self.frame_corridas_acrobaticas,
            text="Descri√ß√£o do V√≠deo de Guia:"
        )
        label_corridas_acrobaticas_descricao_video_guia.grid(row=49, column=0, sticky="w", padx=10, pady=(5, 0))

        # Caixa Descri√ß√£o do V√≠deo de Guia
        self.entrada_corridas_acrobaticas_descricao_video_guia = tk.Text(self.frame_corridas_acrobaticas, height=1, wrap=tk.WORD)
        self.entrada_corridas_acrobaticas_descricao_video_guia.grid(row=50, column=0, padx=(10, 0), pady=5, sticky="nsew", columnspan=2)
        self.entrada_corridas_acrobaticas_descricao_video_guia.bind("<FocusIn>", self.scroll_para_cursor)
        self.entrada_corridas_acrobaticas_descricao_video_guia.bind("<Shift-Return>", self.shift_return_handler)
        self.entrada_corridas_acrobaticas_descricao_video_guia.bind("<Return>", lambda event: self.proximo_campo_sem_nova_linha(event))
        self.entrada_corridas_acrobaticas_descricao_video_guia.bind("<KeyRelease>", lambda event: self.adjust_height(event, self.entrada_corridas_acrobaticas_descricao_video_guia))
        self.caixas_texto.append(self.entrada_corridas_acrobaticas_descricao_video_guia)
        self.associar_botao_filtro(self.entrada_corridas_acrobaticas_descricao_video_guia)








                

    def alternar_corridas_acrobaticas(self):
        """Expande ou colapsa o frame de Corridas Acrob√°ticas."""
        if self.frame_corridas_acrobaticas.winfo_ismapped():
            self.frame_corridas_acrobaticas.grid_remove()
            self.botao_expandir_corridas_acrobaticas.config(text="Corridas Acrob√°ticas ‚ñº") 
        else:
            self.frame_corridas_acrobaticas.grid()
            self.botao_expandir_corridas_acrobaticas.config(text="Corridas Acrob√°ticas ‚ñ≤") 






    ### FRAME: MISS√ïES ESPECIAIS ###
    def criar_frame_missoes_especiais(self, linha):
        """Cria o frame colaps√°vel para Miss√µes Especiais."""

        self.botao_expandir_missoes = ttk.Button(self.frame_missoes, text="Miss√µes Especiais ‚ñº", command=self.alternar_missoes_especiais)
        self.botao_expandir_missoes.grid(row=linha, column=0, sticky="ew", padx=10, pady=5)

        self.frame_missoes_especiais = ttk.Frame(self.frame_missoes, relief="ridge", borderwidth=2)
        self.frame_missoes_especiais.grid(row=linha+1, column=0, sticky="ew", padx=10, pady=(0, 10))
        self.frame_missoes_especiais.grid_remove()

        self.frame_missoes.grid_columnconfigure(0, weight=1)
        self.frame_missoes_especiais.grid_columnconfigure(0, weight=1)

        ttk.Label(self.frame_missoes_especiais, text="Detalhes das Miss√µes Especiais", font=("TkDefaultFont", 10, "bold")).grid(
            row=0, column=0, pady=5, padx=10, sticky="w"
        )

        self.entrada_missoes = tk.Text(self.frame_missoes_especiais, height=5, wrap="word")
        self.entrada_missoes.grid(row=1, column=0, padx=10, pady=5, sticky="ew")

    def alternar_missoes_especiais(self):
        """Expande ou colapsa o frame de Miss√µes Especiais."""
        if self.frame_missoes_especiais.winfo_ismapped():
            self.frame_missoes_especiais.grid_remove()
            self.botao_expandir_missoes.config(text="Miss√µes Especiais ‚ñº")
        else:
            self.frame_missoes_especiais.grid()
            self.botao_expandir_missoes.config(text="Miss√µes Especiais ‚ñ≤")


        
        
        ## FRAME: MISS√ïES ESPECIAIS ###
    def criar_frame_modo_adeversario(self, linha):
        """Cria o frame colaps√°vel para Modo Advers√°rio."""

        self.botao_expandir_modo = ttk.Button(self.frame_missoes, text="Modo Advers√°rio ‚ñº", command=self.alternar_modo_adeversario)
        self.botao_expandir_modo.grid(row=linha, column=0, sticky="ew", padx=10, pady=5)

        self.frame_modo_adeversario = ttk.Frame(self.frame_missoes, relief="ridge", borderwidth=2)
        self.frame_modo_adeversario.grid(row=linha+1, column=0, sticky="ew", padx=10, pady=(0, 10))
        self.frame_modo_adeversario.grid_remove()

        self.frame_missoes.grid_columnconfigure(0, weight=1)
        self.frame_modo_adeversario.grid_columnconfigure(0, weight=1)

        ttk.Label(self.frame_modo_adeversario, text="Modo Advers√°rio", font=("TkDefaultFont", 10, "bold")).grid(row=0, column=0, pady=5, padx=10, sticky="w")

        self.entrada_modo = tk.Text(self.frame_modo_adeversario, height=5, wrap="word")
        self.entrada_modo.grid(row=1, column=0, padx=10, pady=5, sticky="ew")

    def alternar_modo_adeversario(self):
        """Expande ou colapsa o frame de Miss√µes Especiais."""
        if self.frame_modo_adeversario.winfo_viewable():
            self.frame_modo_adeversario.grid_remove()
            self.botao_expandir_missoes.config(text="Miss√µes Especiais ‚ñº")
        else:
            self.frame_modo_adeversario.grid()
            self.botao_expandir_missoes.config(text="Miss√µes Especiais ‚ñ≤")


    def abrir_preview_bbcode_missoes(self, bbcode):
        """Abre uma janela de preview para exibir o BBCode."""
        preview_window = tk.Toplevel(self.root)
        preview_window.title("Preview BBCode")
        preview_window.geometry("600x400")

        # √Årea de texto para o preview
        preview_text = tk.Text(preview_window, wrap=tk.WORD)
        preview_text.insert(tk.END, bbcode)  # Insere o BBCode gerado no campo de texto
        preview_text.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)

        # Fun√ß√£o para selecionar todo o c√≥digo e copiar para a √°rea de transfer√™ncia
        def select_and_copy():
            preview_text.tag_add("sel", "1.0", "end")  # Seleciona todo o texto
            preview_text.clipboard_clear()  # Limpa a √°rea de transfer√™ncia
            preview_text.clipboard_append(preview_text.get('1.0', 'end-1c'))  # Copia o texto
            preview_text.update()  # Atualiza a √°rea de transfer√™ncia

        # Criar o bot√£o "Copiar o BBCode"
        select_button = tk.Button(preview_window, text="Copiar o BBCode", command=select_and_copy)
        select_button.grid(row=1, column=0, pady=10)

        # Configura√ß√£o para fazer o layout responsivo
        preview_window.grid_rowconfigure(0, weight=1)  # O texto vai se expandir
        preview_window.grid_columnconfigure(0, weight=1)  # O texto vai se expandir




        
        
        
        ########################################################### BBCODE ##########################################################
        
    #Janela Preview
    def mostrar_preview(self):
        """Abre uma nova janela com o preview do BBCode"""
        global conteudo
        conteudo = ""
        
        ##########BBCODE DAS CAIXAS DE TEXTO############
        
        #######Categoria URL de imagem ou v√≠deo de capa
        url_imagem = self.caixas_texto[0].get()  # Como h√° apenas uma caixa de texto, pegamos o conte√∫do da primeira

        # Verifica se a URL n√£o est√° vazia antes de adicionar ao conteudo
        if url_imagem:  # S√≥ adiciona se a URL n√£o estiver vazia
            # Extens√µes de imagem conhecidas
            extensoes_imagem = [".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".tiff"]
            
            # Verifica se o URL termina com uma das extens√µes de imagem
            if any(url_imagem.lower().endswith(ext) for ext in extensoes_imagem):
                # URL √© de uma imagem, adiciona o BBCode [img]
                conteudo += f"[img]{url_imagem}[/img]\n\n"
            else:
                # Apenas adiciona o URL com nova linha
                conteudo += f"{url_imagem}\n\n"
        
        
        
        
        ####### Categoria Nota:
        conteudo += "[b]NOTA:[/b] Este Evento t√™m inicio na quinta-feira √†s 9:45 horas da manh√£, e decorre at√© as 9:45 da manh√£ da [b]quinta-feira[/b] da semana seguinte (Hora de Portugal)\n\n\n\n"
        
        
        ########################### Categoria Conte√∫do Novo
        # Obter o valor da entrada de texto para o conte√∫do novo
        conteudo_novo = self.entrada_conteudo_novo.get("1.0", "end-1c").splitlines(keepends=False)
        imagens_conteudo_novo = self.entrada_imagem_conteudo_novo.get("1.0", "end-1c").splitlines(keepends=False)

        # Verificar se h√° conte√∫do ou imagens
        if conteudo_novo or imagens_conteudo_novo:
            categoria_conteudo_novo = "Conte√∫do Novo"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_conteudo_novo}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            
            # Come√ßar a tabela
            conteudo += "[list]\n"

            # Processar cada linha de conte√∫do e associar imagens
            for i, linha in enumerate(conteudo_novo):
                # Preservar linhas em branco (n√£o aplicar strip diretamente)
                texto_linha = linha if linha.strip() else ""
                imagem_associada = imagens_conteudo_novo[i] if i < len(imagens_conteudo_novo) and imagens_conteudo_novo[i].strip() else None

                # Adicionar a imagem, se houver
                if imagem_associada:
                    conteudo += f"[*] [img]{imagem_associada}[/img]\n"
                
                # Adicionar o texto do item (mesmo que seja vazio para linhas em branco)
                conteudo += f"[*] {texto_linha}\n"

            # Fechar a tabela
            conteudo += "[/list]\n"

            # Adicionar imagens n√£o associadas (fora da tabela)
            for i in range(len(conteudo_novo), len(imagens_conteudo_novo)):
                imagem_nao_associada = imagens_conteudo_novo[i]
                if imagem_nao_associada.strip():  # Garantir que a imagem n√£o √© uma linha vazia
                    conteudo += f"[img]{imagem_nao_associada}[/img]\n"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n"
            
        else:
            # Se n√£o houver conte√∫do nem imagens, n√£o adicionar nada
            pass
        
        
        
        
        #########  Categoria Novos ve√≠culos dispon√≠veis
        # Nome da categoria
        categoria_novos_veiculos = "Novos Ve√≠culos Dispon√≠veis"

        # Obter as entradas
        nome_veiculos = self.entrada_novos_veiculos.get("1.0", "end-1c")
        imagem_veiculos = self.entrada_imagem_novos_veiculos.get("1.0", "end-1c")
        desbloqueio_veiculos = self.entrada_desbloqueio_novos_veiculos.get("1.0", "end-1c")
        preco_fabrica_veiculos = self.entrada_precofabrica_novos_veiculos.get("1.0", "end-1c")

        # Dividir as entradas em linhas, sem remover espa√ßos ou linhas em branco
        nome_veiculos_linhas = nome_veiculos.splitlines()
        imagem_veiculos_linhas = imagem_veiculos.splitlines()
        desbloqueio_veiculos_linhas = desbloqueio_veiculos.splitlines()
        preco_fabrica_veiculos_linhas = preco_fabrica_veiculos.splitlines()

        # Verificar se todas as listas est√£o vazias
        if any(nome_veiculos_linhas) or any(imagem_veiculos_linhas) or any(desbloqueio_veiculos_linhas) or any(preco_fabrica_veiculos_linhas):
            # Garantir que todas as listas tenham o mesmo n√∫mero de linhas
            max_linhas = max(len(nome_veiculos_linhas), len(imagem_veiculos_linhas), len(desbloqueio_veiculos_linhas), len(preco_fabrica_veiculos_linhas))
            nome_veiculos_linhas += [""] * (max_linhas - len(nome_veiculos_linhas))
            imagem_veiculos_linhas += [""] * (max_linhas - len(imagem_veiculos_linhas))
            desbloqueio_veiculos_linhas += [""] * (max_linhas - len(desbloqueio_veiculos_linhas))
            preco_fabrica_veiculos_linhas += [""] * (max_linhas - len(preco_fabrica_veiculos_linhas))

            # Construir o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_novos_veiculos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            for i in range(max_linhas):
                # Retirar apenas espa√ßos √† volta das linhas (sem ignorar linhas vazias)
                nome_veiculo = nome_veiculos_linhas[i]
                imagem = imagem_veiculos_linhas[i]
                desbloqueio = desbloqueio_veiculos_linhas[i]
                preco_fabrica = preco_fabrica_veiculos_linhas[i]

                # Processar mesmo que a primeira linha seja vazia
                conteudo += "[list]"

                # Adicionar imagem se existir
                if imagem.strip():
                    conteudo += f"[img]{imagem.strip()}[/img]\n"

                if nome_veiculo.strip():  # Garantir que o nome do ve√≠culo aparece
                    conteudo += f"[*][b]{nome_veiculo.strip()}[/b]\n"

                conteudo += "[list]"
                if desbloqueio.strip():
                    conteudo += f"[*][b]Desbloqueio de Compra:[/b] {desbloqueio.strip()}\n"
                if preco_fabrica.strip():
                    conteudo += f"[*][b]Pre√ßo de F√°brica:[/b] {preco_fabrica.strip()}\n"
                conteudo += "[/list]"

                conteudo += "[/list]\n\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"
        
        
        
        #########  Pr√©mios de Login
        # Nome da categoria
        categoria_premios_login = "Pr√©mios de Login"

        # Obter as entradas
        entrada_premios_login = self.entrada_premios_login.get("1.0", "end-1c")
        entrada_imagem_premios_login = self.entrada_imagem_premios_login.get("1.0", "end-1c")

        # Dividir as entradas em linhas
        premios_login_linhas = entrada_premios_login.splitlines()
        imagens_premios_login_linhas = entrada_imagem_premios_login.splitlines()

        # Verificar se pelo menos uma das listas cont√©m valores n√£o vazios
        if any(premios_login_linhas) or any(imagens_premios_login_linhas):
            # Garantir que todas as listas tenham o mesmo n√∫mero de linhas
            max_linhas = max(len(premios_login_linhas), len(imagens_premios_login_linhas))
            premios_login_linhas += [""] * (max_linhas - len(premios_login_linhas))
            imagens_premios_login_linhas += [""] * (max_linhas - len(imagens_premios_login_linhas))

            # Construir o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_premios_login}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Vari√°vel de controle para fechar e abrir listas
            abriu_lista = False

            for i in range(max_linhas):
                premio = premios_login_linhas[i].strip()
                imagem = imagens_premios_login_linhas[i].strip()

                # Se houver uma imagem sem um item associado, coloca fora da lista
                if imagem and not premio:
                    conteudo += f"[img]{imagem}[/img]\n"
                
                # Se houver um item com imagem associada
                elif premio and imagem:
                    # Se n√£o h√° uma lista aberta, abre uma nova
                    if not abriu_lista:
                        conteudo += "[list]\n"
                        abriu_lista = True

                    # Adiciona a imagem e o item no mesmo item da lista
                    conteudo += f"[*][img]{imagem}[/img] \n{premio}\n"

                # Se houver um item sem imagem, adiciona normalmente
                elif premio:
                    # Se n√£o h√° uma lista aberta, abre uma nova
                    if not abriu_lista:
                        conteudo += "[list]\n"
                        abriu_lista = True

                    conteudo += f"[*]{premio}\n"

            # Fechar a √∫ltima lista se estiver aberta
            if abriu_lista:
                conteudo += "[/list]\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"

        
        
        
        #############  Categoria Retorno de Conte√∫do
        # Nome da categoria principal
        categoria_retorno_conteudo = "Retorno de Conte√∫do"

        # Obter as entradas para as subcategorias de miss√µes
        entrada_ret_missoes = self.entrada_ret_missoes.get("1.0", "end-1c")
        entrada_recomp_missoes = self.entrada_recomp_missoes.get("1.0", "end-1c")
        entrada_img_missoes = self.entrada_img_missoes.get("1.0", "end-1c")

        # Obter as entradas para as subcategorias de eventos de modo livre
        entrada_ret_eventos = self.entrada_ret_eventos.get("1.0", "end-1c")
        entrada_recomp_eventos = self.entrada_recomp_eventos.get("1.0", "end-1c")
        entrada_img_eventos = self.entrada_img_eventos.get("1.0", "end-1c")

        # Obter o banner
        entrada_banner = self.entrada_banner.get("1.0", "end-1c")

        # Dividir as entradas em linhas
        ret_missoes_linhas = entrada_ret_missoes.splitlines()
        recomp_missoes_linhas = entrada_recomp_missoes.splitlines()
        imagem_missoes_linhas = entrada_img_missoes.splitlines()

        ret_eventos_linhas = entrada_ret_eventos.splitlines()
        recomp_eventos_linhas = entrada_recomp_eventos.splitlines()
        imagem_eventos_linhas = entrada_img_eventos.splitlines()

        # Verificar se h√° qualquer conte√∫do para ser exibido
        tem_conteudo_missoes = any(ret_missoes_linhas) or any(recomp_missoes_linhas) or any(imagem_missoes_linhas)
        tem_conteudo_eventos = any(ret_eventos_linhas) or any(recomp_eventos_linhas) or any(imagem_eventos_linhas)
        tem_banner = bool(entrada_banner.strip())

        # Construir o conte√∫do principal apenas se houver algo a ser exibido
        if tem_conteudo_missoes or tem_conteudo_eventos or tem_banner:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_retorno_conteudo}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Adicionar banner, se existir
            if tem_banner:
                for linha_banner in entrada_banner.splitlines():
                    imagens = [img.strip() for img in linha_banner.split(",")]
                    conteudo += "".join(f"[img]{img}[/img]" for img in imagens) + "\n"
                conteudo += "\n"

            # Subcategoria: Retorno de Miss√µes
            if tem_conteudo_missoes:
                conteudo += f"[b][size=125][color=#0055a4]Retorno de Miss√µes:[/color][/size][/b]\n"
                conteudo += "[list]\n"
                max_linhas_missoes = max(len(ret_missoes_linhas), len(recomp_missoes_linhas), len(imagem_missoes_linhas))
                ret_missoes_linhas += [""] * (max_linhas_missoes - len(ret_missoes_linhas))
                recomp_missoes_linhas += [""] * (max_linhas_missoes - len(recomp_missoes_linhas))
                imagem_missoes_linhas += [""] * (max_linhas_missoes - len(imagem_missoes_linhas))

                for i in range(max_linhas_missoes):
                    retorno = ret_missoes_linhas[i]
                    recompensa = recomp_missoes_linhas[i]
                    imagens = imagem_missoes_linhas[i]

                    if retorno.strip() or recompensa.strip() or imagens.strip():
                        conteudo += "[*] "
                        if retorno.strip():
                            conteudo += retorno.strip() + " - "
                        if recompensa.strip():
                            conteudo += f"[b]{recompensa.strip()}[/b]"
                        conteudo += "\n"
                        if imagens.strip():
                            for img in imagens.split(","):
                                conteudo += f"[img]{img.strip()}[/img]"
                            conteudo += "\n"
                conteudo += "[/list]\n\n"

            # Subcategoria: Retorno de Eventos de Modo Livre
            if tem_conteudo_eventos:
                conteudo += f"[b][size=125][color=#0055a4]Retorno de Eventos de Modo Livre:[/color][/size][/b]\n"
                conteudo += "[list]\n"
                max_linhas_eventos = max(len(ret_eventos_linhas), len(recomp_eventos_linhas), len(imagem_eventos_linhas))
                ret_eventos_linhas += [""] * (max_linhas_eventos - len(ret_eventos_linhas))
                recomp_eventos_linhas += [""] * (max_linhas_eventos - len(recomp_eventos_linhas))
                imagem_eventos_linhas += [""] * (max_linhas_eventos - len(imagem_eventos_linhas))

                for i in range(max_linhas_eventos):
                    retorno = ret_eventos_linhas[i]
                    recompensa = recomp_eventos_linhas[i]
                    imagens = imagem_eventos_linhas[i]

                    if retorno.strip() or recompensa.strip() or imagens.strip():
                        conteudo += "[*] "
                        if retorno.strip():
                            conteudo += retorno.strip() + " - "
                        if recompensa.strip():
                            conteudo += f"[b]{recompensa.strip()}[/b]"
                        conteudo += "\n"
                        if imagens.strip():
                            for img in imagens.split(","):
                                conteudo += f"[img]{img.strip()}[/img]"
                            conteudo += "\n"
                conteudo += "[/list]\n"

            # Garantir 3 linhas vazias no final
            conteudo += "\n\n\n"





        ####### Categoria Desafio Semanal
        categoria_nome = "Desafio Semanal"  # Vari√°vel para armazenar o nome da categoria
        desafio_objetivo = self.entrada_desafio_semanal.get().strip()
        recompensa = self.entrada_recompensa_objectivo_semanal.get("1.0", "end-1c").strip()

        # Ignorar o BBCode da categoria se ambos os campos estiverem vazios
        if not desafio_objetivo and not recompensa:
            pass  # Ignora a categoria inteira se ambos os campos estiverem vazios
        else:
            conteudo += f"""[b][size=150][color=#0073e6]{categoria_nome}:[/color][/size][/b]
[hr][/hr]
[list] [b]{desafio_objetivo}[/b]"""

            # Dividir a recompensa em linhas
            recompensa_linhas = recompensa.splitlines()

            if len(recompensa_linhas) == 1:
                # Caso tenha apenas 1 linha
                conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] [/list]"
            elif len(recompensa_linhas) == 2:
                # Caso tenha 2 linhas
                conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b] [/list]"
            else:
                # Caso tenha 3 ou mais linhas
                conteudo += " e recebe:\n[list]\n"
                for linha in recompensa_linhas:
                    conteudo += f"[*][b]{linha}[/b]\n"
                conteudo += "[/list]"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"

                




        ######## Categoria B√¥nus de Atividade
        categoria_bonus_nome = "B√¥nus de Evento"  # Nome da nova categoria

        # Verificar se os campos est√£o preenchidos
        bonus_objetivo = self.entrada_bonus_atividade.get().strip()
        bonus_recompensa = self.entrada_recompensa_bonus_atividade.get("1.0", "end-1c").strip()
        timeframe = self.entrada_timeframe_bonus_atividade.get().strip()
        imagem_bonus = self.entrada_imagem_bonus_atividade.get().strip()  # Obt√©m o link da imagem

        # Ignorar o BBCode da categoria se todos os campos estiverem vazios
        if not bonus_objetivo and not bonus_recompensa and not timeframe and not imagem_bonus:
            pass  # Ignora a categoria inteira se todos os campos estiverem vazios
        else:
            conteudo += f"""[b][size=150][color=#0073e6]{categoria_bonus_nome}:[/color][/size][/b]
        [hr][/hr]
        """

            # Adicionar o BBCode da imagem se o campo imagem_bonus n√£o estiver vazio
            if imagem_bonus:
                conteudo += f"[img]{imagem_bonus}[/img]\n\n"

            conteudo += f"[b]{bonus_objetivo}[/b]"

            # Dividir a recompensa do b√¥nus em linhas
            recompensa_linhas = bonus_recompensa.splitlines()

            if len(recompensa_linhas) == 1:
                # Caso tenha apenas 1 linha
                if timeframe:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] at√© [b]{timeframe}[/b]\n"
                else:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b]\n"
            elif len(recompensa_linhas) == 2:
                # Caso tenha 2 linhas
                if timeframe:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b] at√© [b]{timeframe}[/b]\n"
                else:
                    conteudo += f" e recebe [b]{recompensa_linhas[0]}[/b] mais [b]{recompensa_linhas[1]}[/b]\n"
            else:
                # Caso tenha 3 ou mais linhas
                if timeframe:
                    conteudo += f" e recebe dentro de [b]{timeframe}[/b]:\n[list]"
                else:
                    conteudo += " e recebe:\n[list]"

                for linha in recompensa_linhas:
                    conteudo += f"[*][b]{linha}[/b]\n"
                conteudo += "[/list]\n"  # Fechar a lista para mais de 3 linhas

            # Garantir que sempre haja 3 linhas de espa√ßamento
            conteudo += "\n\n\n"



                
                
                
                
        #########  Categoria Atividades de B√≥nus GTA$ e RP
        categoria_bonus_gta_rp = "Atividades de B√≥nus GTA$ e RP"

        # Obter as entradas das caixas de texto
        nome_atividades = self.entrada_nome_atividades_gta_rp.get("1.0", "end-1c").strip()  # Caixa de texto para as atividades
        imagem_atividades = self.entrada_imagem_atividades_gta_rp.get("1.0", "end-1c").strip()  # Caixa de texto para a imagem

        # Separar as linhas de cada caixa de texto, ignorando linhas vazias
        nome_atividades_linhas = [linha.strip() for linha in nome_atividades.splitlines() if linha.strip()]
        imagem_atividades_linhas = [linha.strip() for linha in imagem_atividades.splitlines()]

        # Processar e organizar atividades com base em GTA$ e RP
        atividades_organizadas = []

        import re

        for linha in nome_atividades_linhas:
            # Substituir conectores para padronizar
            linha = re.sub(r'\b(and|e)\b', '&', linha, flags=re.IGNORECASE)
            linha = re.sub(r'\b(on|em)\b', 'em', linha, flags=re.IGNORECASE)

            # Extrair valores de GTA$ e RP
            gta_match = re.search(r'(\d+)x GTA\$', linha, flags=re.IGNORECASE)
            rp_match = re.search(r'(\d+)x RP', linha, flags=re.IGNORECASE)

            gta_valor = int(gta_match.group(1)) if gta_match else 0
            rp_valor = int(rp_match.group(1)) if rp_match else 0

            atividades_organizadas.append((gta_valor, rp_valor, linha))

        # Ordenar atividades pelo maior GTA$ e, em caso de empate, pelo maior RP
        atividades_organizadas.sort(key=lambda x: (-x[0], -x[1]))

        # Ignorar o BBCode da categoria se ambas as caixas estiverem vazias
        if atividades_organizadas or imagem_atividades_linhas:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_bonus_gta_rp}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += "[List]\n"

            # Processar atividades organizadas com suas imagens correspondentes
            max_linhas = max(len(atividades_organizadas), len(imagem_atividades_linhas))
            
            for i in range(max_linhas):
                conteudo += "[*]"
                
                # Pega a imagem correspondente ou mant√©m uma string vazia se n√£o houver imagem
                imagem = imagem_atividades_linhas[i] if i < len(imagem_atividades_linhas) else ""

                # Pega a atividade correspondente organizada
                atividade = atividades_organizadas[i][2] if i < len(atividades_organizadas) else ""

                # Se houver imagem, adicionar imagem antes da atividade
                if imagem:
                    conteudo += f"[img]{imagem}[/img] "
                
                # Adicionar a atividade
                if atividade:
                    conteudo += f"{atividade}\n"

            conteudo += "[/List]\n\n\n\n"

            
            
            
        
        ######### Categoria de Desconto

        categoria_descontos = "Descontos"

        # Obter as entradas de imagem e descontos
        imagem_descontos = self.entrada_imagem_descontos.get().strip()  # Caixa de texto para a imagem dos descontos
        descontos = self.entrada_descontos.get("1.0", "end-1c").strip()  # Caixa de texto para os descontos

        # Verificar se ao menos uma das entradas est√° preenchida
        if not imagem_descontos and not descontos:
            pass  # Ignora a categoria inteira se ambas as caixas estiverem vazias
        else:
            # Inicializar o conte√∫do da categoria
            conteudo += f"[b][size=150][color=#0073e6]{categoria_descontos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Adicionar a imagem (se dispon√≠vel) antes dos descontos
            if imagem_descontos:
                conteudo += f"[img]{imagem_descontos}[/img]\n"

            # Processar os descontos
            if descontos:
                descontos_linhas = [linha.strip() for linha in descontos.splitlines() if linha.strip()]  # Ignorar linhas vazias

                # Inicializar o dicion√°rio de percentagens
                descontos_dict = {}
                formato_valido = True

                for linha in descontos_linhas:
                    # Remover conte√∫do dentro de par√™nteses e os pr√≥prios par√™nteses
                    linha_limpa = re.sub(r"\s*\(.*?\)", "", linha).strip()

                    # Ajustar para capturar h√≠fens alternativos e espa√ßos extras
                    match = re.match(r"^(.*?)\s*[-‚Äì]\s*(\d+)%\s*(off|de desconto)?$", linha_limpa, re.IGNORECASE)
                    if match:
                        nome, percentagem, _ = match.groups()
                        percentagem = int(percentagem)

                        # Adicionar ao dicion√°rio
                        if percentagem not in descontos_dict:
                            descontos_dict[percentagem] = []
                        descontos_dict[percentagem].append(nome.strip())
                    else:
                        formato_valido = False
                        break  # Interromper se algum item n√£o seguir o formato esperado

                if formato_valido:
                    # Ordenar as percentagens de maior para menor e gerar o conte√∫do
                    for percentagem in sorted(descontos_dict.keys(), reverse=True):
                        conteudo += f"[b]{percentagem}%[/b]\n[list]\n"
                        for item in descontos_dict[percentagem]:
                            conteudo += f"[*] {item}\n"
                        conteudo += "[/list]\n\n"
                else:
                    # Caso o formato n√£o seja o esperado, gerar uma lista simples
                    conteudo += "\n[list]\n"
                    for linha in descontos_linhas:
                        conteudo += f"[*] {linha}\n"
                    conteudo += "[/list]\n\n\n\n"




                    
                    
                    

        # Categoria GunVan
        categoria_gun_van = "Van de Arsenal (Gun Van)"

        # Obter o conte√∫do da caixa de texto da Gun Van
        gun_van_texto = self.entrada_gunvan.get("1.0", "end-1c").strip()

        # Verificar se a caixa de texto da Gun Van n√£o est√° vazia antes de adicionar o bbcode
        if gun_van_texto:  # Se houver algo na caixa de texto
            # Adicionar o t√≠tulo da categoria de Gun Van
            conteudo += "\n\n\n\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_gun_van}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"[img]https://rockstarintel.com/wp-content/uploads/2023/01/b6b37e2ae693cdff8f2feb234b44b76948b1529b-scaled.jpg[/img]\n"

            # Fun√ß√£o para ajustar o texto das porcentagens e outras substitui√ß√µes
            def ajustar_percentagem(texto):
                # Ajusta "x% off" para "x%" (sem par√™nteses extras)
                texto = re.sub(r"(\d+)%\s*off", r"\1%", texto)
                # Ajusta "x% for GTA+ Members" para "x% GTA+" (sem par√™nteses extras)
                texto = re.sub(r"(\d+)%\s*for GTA\+ Members", r"\1% GTA+", texto)
                # Ajusta "free for GTA+ Members" para "Gratis GTA+" (sem par√™nteses extras)
                texto = re.sub(r"free for GTA\+ Members", "Gratis GTA+", texto)
                # Ajusta "PS5 and Xbox Series X|S only" para "Exclusivo PS5 e Xbox Series X|S"
                texto = re.sub(r"PS5 and Xbox Series X\|S only", "Exclusivo PS5 e Xbox Series X|S", texto)
                return texto

            # Verificar se o texto foi introduzido de forma estruturada com " | "
            if " | " in gun_van_texto:
                # Separar a entrada usando o separador " | " com espa√ßos antes e depois
                gun_van_itens = [ajustar_percentagem(item.strip()) for item in gun_van_texto.split(" | ") if item.strip()]

                # Adicionar a lista com os itens, envolvendo as tags de lista
                conteudo += "[List]\n"
                for item in gun_van_itens:
                    conteudo += f"[*] {item}\n"
                conteudo += "[/List]\n\n"
            else:
                # Caso n√£o esteja estruturado com " | ", processar cada linha como um item da lista
                gun_van_linhas = [ajustar_percentagem(linha.strip()) for linha in gun_van_texto.splitlines() if linha.strip()]

                conteudo += "[List]\n"
                for linha in gun_van_linhas:
                    conteudo += f"[*] {linha}\n"
                conteudo += "[/List]\n\n\n\n"
        else:
            # Se n√£o houver nada na caixa de texto, nada √© adicionado
            pass


            
            
            
            
        ######### Categoria Roubos do Ferro-Velho
        # Verificar se h√° pelo menos um ve√≠culo, um golpe ou uma sele√ß√£o de reclam√°vel para esta categoria
        def categoria_roubos_ferro_velho_valido():
            # Verificar se qualquer ve√≠culo foi preenchido ou qualquer golpe foi selecionado
            if not self.entrada_salvageyard_veiculo1.get() and not self.opcao_golpe1.get() and not self.reclamavel_veiculo1.get():
                if not self.entrada_salvageyard_veiculo2.get() and not self.opcao_golpe2.get() and not self.reclamavel_veiculo2.get():
                    if not self.entrada_salvageyard_veiculo3.get() and not self.opcao_golpe3.get() and not self.reclamavel_veiculo3.get():
                        return False  # N√£o h√° dados v√°lidos para a categoria
            return True  # Pelo menos um ve√≠culo ou golpe est√° preenchido

        # Verificar se a categoria tem algo para mostrar
        if categoria_roubos_ferro_velho_valido():
            # Adicionar o t√≠tulo da categoria de Roubos do Ferro-Velho
            categoria_roubos_ferro_velho = "Roubos do Ferro-Velho (Salvage Yard Robberies)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_roubos_ferro_velho}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Fun√ß√£o para verificar o estado do bot√£o de r√°dio e da caixa de sele√ß√£o
            def gerar_saida_roubo(veiculo_entrada, reclamavel_var, nome_golpe):
                # Inicializa a vari√°vel conteudo
                conteudo = ""

                # Lista de op√ß√µes de golpes correspondentes aos radiobuttons
                opcoes_golpe = {
                    "O Roubo do Duggan (The Duggan Robbery)": "O Roubo do Duggan (The Duggan Robbery)",
                    "O Roubo do Gangbanger (The Gangbanger Robbery)": "O Roubo do Gangbanger (The Gangbanger Robbery)",
                    "O Roubo do Cargueiro (The Cargo Ship Robbery)": "O Roubo do Cargueiro (The Cargo Ship Robbery)",
                    "O Roubo do Podio (The Podium Robbery)": "O Roubo do Podio (The Podium Robbery)",
                    "O Roubo do McTony (The McTony Robbery)": "O Roubo do McTony (The McTony Robbery)"
                }

                # Verificar se nada foi selecionado ou digitado
                if not veiculo_entrada.get() and not reclamavel_var.get() and nome_golpe not in opcoes_golpe:
                    return ""  # Retorna string vazia para ignorar a adi√ß√£o no conte√∫do

                # Se houver valores v√°lidos, come√ßa a montar o conte√∫do

                # Verificar se o bot√£o de r√°dio do golpe est√° selecionado
                if nome_golpe in opcoes_golpe:
                    conteudo += opcoes_golpe[nome_golpe]  # Apenas o nome do golpe

                # Adicionar o nome do ve√≠culo, se houver
                if veiculo_entrada.get():
                    conteudo += f" - {veiculo_entrada.get()}"

                # Verificar se √© "Reclam√°vel" e adicionar a informa√ß√£o
                if reclamavel_var.get():
                    conteudo += " [Reclam√°vel]"

                return conteudo


            # Para o Golpe 1
            saida_roubo_1 = gerar_saida_roubo(self.entrada_salvageyard_veiculo1, self.reclamavel_veiculo1, self.opcao_golpe1.get())
            if saida_roubo_1:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_1 + "\n"

            # Para o Golpe 2
            saida_roubo_2 = gerar_saida_roubo(self.entrada_salvageyard_veiculo2, self.reclamavel_veiculo2, self.opcao_golpe2.get())
            if saida_roubo_2:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_2 + "\n"

            # Para o Golpe 3
            saida_roubo_3 = gerar_saida_roubo(self.entrada_salvageyard_veiculo3, self.reclamavel_veiculo3, self.opcao_golpe3.get())
            if saida_roubo_3:  # Se o conte√∫do n√£o for vazio
                conteudo += saida_roubo_3 + "\n\n\n\n"
                
                
                
                
        ######### Categoria Ve√≠culo do P√≥dio
        # Obter o valor da entrada de texto para o nome do ve√≠culo do p√≥dio
        nome_veiculo_podio = self.entrada_nome_veiculo_podio.get().strip()

        # Verificar se o campo de texto n√£o est√° vazio antes de gerar o c√≥digo
        if nome_veiculo_podio:  # Se houver algo na entrada
            # Adicionar o t√≠tulo da categoria de Ve√≠culo do P√≥dio
            categoria_veiculo_podio = "Ve√≠culo do P√≥dio (Podium Vehicle)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_veiculo_podio}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"{nome_veiculo_podio}"
            conteudo += "\n\n\n\n"
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ######### Novo Desafio do Encontro de Carros (LS Car Meet)
        # Obter os valores das entradas de texto
        nome_desafio_car_meet = self.entrada_nome_desafio_car_meet.get().strip()
        dias_desafio_car_meet = self.entrada_dias_desafio_car_meet.get().strip()
        recompensa_desafio_car_meet = self.entrada_recompensa_desafio_car_meet.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if nome_desafio_car_meet and dias_desafio_car_meet and recompensa_desafio_car_meet:
            # Adicionar o t√≠tulo da categoria Novo Desafio do Encontro de Carros
            categoria_car_meet = "Novo Desafio do Encontro de Carros (LS Car Meet)"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_car_meet}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]"
            
            # Adicionar o conte√∫do do desafio com o formato solicitado
            conteudo += f"[b]{nome_desafio_car_meet}[/b] no Evento de Carros LS em S√©rie (LS Car Meet Series) por [b]{dias_desafio_car_meet}[/b] [b]dias seguidos[/b]\n"
            
            # Processar as recompensas
            linhas_recompensa = [linha.strip() for linha in recompensa_desafio_car_meet.splitlines() if linha.strip()]
            if len(linhas_recompensa) == 1:
                conteudo += f"[b]Pr√©mio:[/b] {linhas_recompensa[0]}"
            elif len(linhas_recompensa) == 2:
                conteudo += f"Pr√©mio: [b]{linhas_recompensa[0]}[/b] mais [b]{linhas_recompensa[1]}[/b]"
            else:
                conteudo += "[b]Pr√©mios:[/b]\n[list]\n"
                for linha in linhas_recompensa:
                    conteudo += f"[*] {linha}\n"
                conteudo += "[/list]"
            
            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ####### Categoria Test Rides
        categoria_test_rides = "Test Rides"  # Vari√°vel para armazenar o nome da categoria
        test_rides_texto = self.entrada_test_rides.get("1.0", "end-1c").strip()  # Obter o texto da entrada

        # Verificar se h√° conte√∫do na entrada
        if test_rides_texto:
            conteudo += f"[b][size=150][color=#0073e6]{categoria_test_rides}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"

            # Dividir o texto em linhas e criar a lista
            test_rides_linhas = test_rides_texto.splitlines()
            conteudo += "[list]\n"
            for linha in test_rides_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Ignorar a categoria se n√£o houver conte√∫do
            pass
        
        
        
        
        ######### Ve√≠culo de Teste Premium:
        # Obter o valor da entrada de texto para o nome do ve√≠culo do p√≥dio
        nome_veiculo_test = self.entrada_nome_veiculo_teste_premium.get().strip()

        # Verificar se o campo de texto n√£o est√° vazio antes de gerar o c√≥digo
        if nome_veiculo_test:  # Se houver algo na entrada
            # Adicionar o t√≠tulo da categoria de Ve√≠culo do P√≥dio
            categoria_veiculo_test = "Ve√≠culo de Teste Premium"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_veiculo_test}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            conteudo += f"{nome_veiculo_test}"
            conteudo += "\n\n\n\n"
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ######### Categoria Luxury Autos
        # Obter os valores das entradas de texto
        imagem_luxury_autos = self.entrada_imagem_luxury_autos.get().strip()
        veiculos_luxury_autos_texto = self.entrada_veiculos_luxury_autos.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if imagem_luxury_autos and veiculos_luxury_autos_texto:
            # Adicionar o t√≠tulo da categoria Luxury Autos
            categoria_luxury_autos = "Luxury Autos"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_luxury_autos}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"
            
            # Adicionar a imagem diretamente com BBCode
            conteudo += f"[img]{imagem_luxury_autos}[/img]\n"

            # Dividir o texto em linhas e criar a lista de ve√≠culos
            veiculos_luxury_autos_linhas = veiculos_luxury_autos_texto.splitlines()
            conteudo += "[list]\n"
            for linha in veiculos_luxury_autos_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ######### Categoria Premium Deluxe Motorsport
        # Obter os valores das entradas de texto
        imagem_premium_deluxe_motorsport = self.entrada_imagem_premium_deluxe_motorsport.get().strip()
        veiculos_premium_deluxe_motorsport_texto = self.entrada_veiculos_premium_deluxe_motorsport.get("1.0", "end-1c").strip()

        # Verificar se h√° conte√∫do em todas as entradas necess√°rias
        if imagem_premium_deluxe_motorsport and veiculos_premium_deluxe_motorsport_texto:
            # Adicionar o t√≠tulo da categoria Premium Deluxe Motorsport
            categoria_premium_deluxe_motorsport = "Premium Deluxe Motorsport"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_premium_deluxe_motorsport}:[/color][/size][/b]\n"
            conteudo += "[hr][/hr]\n"  # Adicionar uma linha de separa√ß√£o e nova linha
            
            # Adicionar a imagem diretamente com BBCode
            conteudo += f"[img]{imagem_premium_deluxe_motorsport}[/img]\n"

            # Dividir o texto em linhas e criar a lista de ve√≠culos
            veiculos_premium_deluxe_motorsport_linhas = veiculos_premium_deluxe_motorsport_texto.splitlines()
            conteudo += "[list]\n"
            for linha in veiculos_premium_deluxe_motorsport_linhas:
                conteudo += f"[*] {linha.strip()}\n"
            conteudo += "[/list]"

            # Adicionar 3 linhas de espa√ßo no final
            conteudo += "\n\n\n\n"
        else:
            # Se alguma das entradas estiver vazia, ignorar a categoria
            pass
        
        
        
        
        ######### Categoria Corrida Premium
        # Obter o valor da entrada de texto
        nome_corrida_premium = self.entrada_nome_corrida_premium.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_corrida_premium:
            # Adicionar o t√≠tulo da categoria Corrida Premium
            categoria_corrida_premium = "Corrida Premium"
            conteudo += "[hr][/hr]\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_corrida_premium}:[/color][/size][/b]\n"
            conteudo += f"{nome_corrida_premium}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio
        # Obter o valor da entrada de texto
        nome_contra_relogio = self.entrada_nome_contra_relogio.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio
            categoria_contra_relogio = "Contra Rel√≥gio"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio HSW
        # Obter o valor da entrada de texto
        nome_contra_relogio_hsw = self.entrada_nome_contra_relogio_hsw.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio_hsw:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio HSW
            categoria_contra_relogio_hsw = "Contra Rel√≥gio HSW"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio_hsw}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio_hsw}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass


        ######### Categoria Contra Rel√≥gio RC
        # Obter o valor da entrada de texto
        nome_contra_relogio_rc = self.entrada_nome_contra_relogio_rc.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if nome_contra_relogio_rc:
            # Adicionar o t√≠tulo da categoria Contra Rel√≥gio RC
            categoria_contra_relogio_rc = "Contra Rel√≥gio RC"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_contra_relogio_rc}:[/color][/size][/b]\n"
            conteudo += f"{nome_contra_relogio_rc}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass
        
        
        
        
        ####### Categoria GTA+:
        conteudo += """
[hr][/hr]
[img]https://media-rockstargames-com.akamaized.net/mfe6/prod/__common/img/7563ed0414306d18d4f8401effcab31a.svg[/img]

[list][b][u]Gr√°tis [/u][/b]
[list]
[*]Vapid Dominator GT
[*]Bon√© e a Jaqueta Varsity LS Panic (LS Panic Varsity Jacket and Cap)
[/list]
[/list]

[list][b][u]Novo Conteudo[/u][/b]
[list]
[*]Novas Pinturas Camale√£o (Chameleon Paints)
[*]Bon√© e a Jaqueta Varsity LS Panic (LS Panic Varsity Jacket and Cap)
[/list]
[/list]

[list][b][u]Bonus de Recompensas[/u][/b]
[list]
[*]Dossi√™s do FIB Priorit√°rios  (Priority FIB Files) - 2x GTA$ e RP
[/list]
[/list]

Acesso a garagem do [b]Vinewood Club para 100 veiculos,[/b] completa com [b]Oficina (Vehicle Workshop) e inclui  Melhorias do Hao‚Äôs Special Works (Hao‚Äôs Special Works Upgrades), Convers√µes do Benny (Benny's Conversions), Drift Tuning[/b], e mais.
[img]https://media-rockstargames-com.akamaized.net/tina-uploads/posts/4kk9o9a811o27k/04a1ba4148f83c7cc5e325197964e527dd620b20.jpg[/img]
"""




        ######### Categoria Mais Info
        # Obter o valor da entrada de texto
        descricao_mais_info = self.entrada_descricao_mais_info.get().strip()

        # Verificar se h√° conte√∫do na entrada
        if descricao_mais_info:
            # Adicionar o t√≠tulo da categoria Mais Info
            categoria_mais_info = "Mais Info"
            conteudo += "\n\n\n"
            conteudo += f"[b][size=150][color=#0073e6]{categoria_mais_info}:[/color][/size][/b]\n"
            conteudo += f"{descricao_mais_info}"  # Adicionar o valor da entrada
            conteudo += "\n\n\n\n"  # Adicionar 3 linhas de espa√ßo
        else:
            # Se o campo estiver vazio, n√£o adicionar nada
            pass        



        # Criar a janela de preview
        preview_window = tk.Toplevel(self.root)
        preview_window.title("Preview BBCode")
        preview_window.geometry("600x400")

        # √Årea de texto para o preview
        preview_text = tk.Text(preview_window, wrap=tk.WORD)
        preview_text.grid(row=0, column=0, sticky='nsew', padx=5, pady=5)

        # Inserir o conte√∫do gerado na √°rea de texto
        preview_text.insert('1.0', conteudo)

        # Fun√ß√£o para selecionar todo o c√≥digo e copiar para a √°rea de transfer√™ncia
        def select_and_copy():
            preview_text.tag_add("sel", "1.0", "end")  # Seleciona todo o texto
            preview_text.clipboard_clear()  # Limpa a √°rea de transfer√™ncia
            preview_text.clipboard_append(preview_text.get('1.0', 'end-1c'))  # Adiciona o texto √† √°rea de transfer√™ncia
            preview_text.update()  # Atualiza a √°rea de texto para garantir que o conte√∫do foi copiado corretamente
            
        # Criar o bot√£o "Selecionar todo o c√≥digo"
        select_button = tk.Button(preview_window, text="Copiar o BBCode", command=select_and_copy)

        # Adicionar o bot√£o na segunda linha (alinhado ao centro, no fundo)
        select_button.grid(row=1, column=0, pady=10)

        # Configura√ß√£o para fazer o layout responsivo, permitindo que o texto ocupe o restante da janela
        preview_window.grid_rowconfigure(0, weight=1)  # O texto vai se expandir
        preview_window.grid_columnconfigure(0, weight=1)  # O texto vai se expandir
        
        
        
        def abrir_gerar_titulo():
            # C√°lculo das datas
            hoje = datetime.date.today()
            inicio_semana = hoje if hoje.weekday() == 3 else hoje - datetime.timedelta(days=(hoje.weekday() + 3) % 7)  # Quinta anterior ou hoje
            fim_semana = inicio_semana + datetime.timedelta(days=6)

            # Formato das datas
            data_inicio = inicio_semana.strftime("%d/%m")
            data_fim = fim_semana.strftime("%d/%m")

            # Criar a janela de gerar t√≠tulo
            gerar_titulo_window = tk.Toplevel(preview_window)
            gerar_titulo_window.title("Gerar T√≠tulo")
            gerar_titulo_window.geometry("500x300")

            # Frame para as op√ß√µes de atividades
            frame_atividades = ttk.LabelFrame(gerar_titulo_window, text="Atividades de B√¥nus GTA$ e RP")
            frame_atividades.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)

            opcao_selecionada = tk.StringVar(value="Outro")

            # Ler as atividades da caixa de texto self.entrada_nome_atividades_gta_rp
            atividades = self.entrada_nome_atividades_gta_rp.get("1.0", "end-1c").splitlines()  # L√™ as linhas da caixa de texto

            # Se houver atividades, criar os radiobuttons
            if atividades and atividades != ['']:
                for idx, atividade in enumerate(atividades):
                    ttk.Radiobutton(frame_atividades, text=atividade, variable=opcao_selecionada, value=atividade).pack(anchor="w")
                
                # Garantir que o primeiro radiobutton esteja selecionado por padr√£o
                opcao_selecionada.set(atividades[0])

                # Adicionar a op√ß√£o "Outro"
                ttk.Radiobutton(frame_atividades, text="Outro", variable=opcao_selecionada, value="Outro").pack(anchor="w")
                entrada_outro = ttk.Entry(frame_atividades)
                entrada_outro.pack(fill="x", padx=10, pady=5)

            else:
                # Caso n√£o haja atividades, mostrar apenas "Outro"
                ttk.Radiobutton(frame_atividades, text="Outro", variable=opcao_selecionada, value="Outro").pack(anchor="w")
                entrada_outro = ttk.Entry(frame_atividades)
                entrada_outro.pack(fill="x", padx=10, pady=5)

            # Fun√ß√£o para gerar o t√≠tulo
            def gerar_titulo():
                atividade = entrada_outro.get() if opcao_selecionada.get() == "Outro" else opcao_selecionada.get()
                titulo = f"GTA ONLINE - EVENTO SEMANAL - {atividade} | {data_inicio}-{data_fim}"  # Removendo o espa√ßo entre as datas

                # Exibir o t√≠tulo em uma caixa de texto edit√°vel
                titulo_text.delete("1.0", "end")  # Limpar conte√∫do existente
                titulo_text.insert("1.0", titulo)  # Inserir o t√≠tulo gerado

            # Caixa de texto para exibir e editar o t√≠tulo gerado
            titulo_text = tk.Text(gerar_titulo_window, height=3, wrap=tk.WORD)
            titulo_text.grid(row=1, column=0, sticky="nsew", padx=10, pady=10)

            # Bot√£o "Gerar T√≠tulo"
            gerar_button = ttk.Button(gerar_titulo_window, text="Gerar", command=gerar_titulo)
            gerar_button.grid(row=2, column=0, pady=10)

            # Configura√ß√£o para fazer o layout responsivo
            gerar_titulo_window.grid_rowconfigure(0, weight=1)  # O frame de atividades vai se expandir
            gerar_titulo_window.grid_rowconfigure(1, weight=1)  # A caixa de texto vai se expandir
            gerar_titulo_window.grid_rowconfigure(2, weight=0)  # O bot√£o de gerar t√≠tulo n√£o precisa expandir
            gerar_titulo_window.grid_columnconfigure(0, weight=1)  # A coluna vai se expandir

        # Bot√£o "Gerar T√≠tulo" na janela de preview (fora da fun√ß√£o)
        gerar_titulo_button = tk.Button(preview_window, text="Gerar T√≠tulo", command=abrir_gerar_titulo)
        gerar_titulo_button.grid(row=1, column=0, pady=10, padx=10, sticky="w")





######################################## BBcode missoes corridas Acrobaticas ########################################

    def gerar_bbcode_missoes(self):
        """Gera o BBCode apenas com a URL da imagem/v√≠deo e abre o preview."""
    
        # Obter o link da URL da imagem ou v√≠deo
        url_capa = self.entrada_corridas_acrobaticas_url.get().strip()
        
        # Verificar se a URL √© de uma imagem
        def is_image_url(url):
            image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff']
            return any(url.lower().endswith(ext) for ext in image_extensions)
        
        # Gerar a primeira linha do BBCode
        if url_capa:
            if is_image_url(url_capa):
                bbcode = f"[img]{url_capa}[/img]\n\n\n"  # Adiciona BBCode de imagem
            else:
                bbcode = f"{url_capa}\n\n\n"  # Apenas o link
        else:
            bbcode = "\n\n\n"  # Apenas os 3 espa√ßos vazios
        
        # Obter as descri√ß√µes PT e EN
        descricao_pt = self.entrada_corridas_acrobaticas_pt.get("1.0", "end-1c")
        descricao_en = self.entrada_corridas_acrobaticas_en.get("1.0", "end-1c")
        
        # Gerar BBCode da descri√ß√£o PT
        if descricao_pt:
            bbcode += f"[quote]{descricao_pt}[/quote]\n\n"
        
        # Gerar BBCode da descri√ß√£o EN
        if descricao_en:
            bbcode += (
                "[color=#FF0000]Vers√£o em Ingles:[/color]\n"
                f"[quote][spoiler]{descricao_en}[/spoiler][/quote]\n\n\n"
            )

        # Obter os valores das caixas de entrada
        para = self.entrada_corridas_acrobaticas_para.get().strip()
        local = "Todo o Mapa" if self.var_corridas_acrobaticas_todo_mapa.get() else self.entrada_corridas_acrobaticas_local.get().strip()
        frequencia = self.entrada_corridas_acrobaticas_frequencia.get().strip()
        numero_voltas = self.entrada_corridas_acrobaticas_numero_voltas.get().strip()
        voltas_padrao = self.entrada_corridas_acrobaticas_numero_padrao_voltas.get().strip()
        
        # Adicionar prints para depura√ß√£o
        print(f"Para: {para}, Local: {local}, Frequ√™ncia: {frequencia}, Voltas: {numero_voltas}")
        
        # Gerar o BBCode com os valores
        bbcode_missoes = ""
        
        # Adicionar "Para" se o valor n√£o estiver vazio
        if para:
            bbcode_missoes += f"[b]Para:[/b] [color=#BF0080]{para} Jogadores[/color] \n"
        
        # Adicionar "Local" se o valor n√£o estiver vazio
        if local:
            bbcode_missoes += f"[b]Local:[/b] [color=#BF0080]{local}[/color] \n"
        
        # Adicionar "Frequ√™ncia" se o valor n√£o estiver vazio
        if frequencia:
            bbcode_missoes += f"[b]Frequ√™ncia:[/b] [color=#BF0080]{frequencia}[/color] \n"
        
        # Adicionar "Voltas" se o valor n√£o estiver vazio
        if numero_voltas:
            bbcode_missoes += f"[b]Voltas:[/b] [color=#BF0080]{numero_voltas} ({voltas_padrao} por padr√£o)[/color]\n\n\n"
        
        # Adicionar o BBCode da miss√£o somente se houver algum conte√∫do
        if bbcode_missoes:
            bbcode += bbcode_missoes

        """Gera o BBCode com as informa√ß√µes de como funciona a miss√£o."""
        
        # Inicializar o BBCode de "Como funciona"
        bbcode_como_funciona = "[color=#804000][size=150]Como funciona:[/size][/color]\n[hr][/hr]\n\n"
        
        # Caminho do menu pausa
        caminho_pausa = ""
        if self.var_corridas_acrobaticas_como_funciona_menu_pausa.get():
            caminho_pausa = (
                "Menu Pausa - Online - Jobs - Play Job - Rockstar Created - Races - Stunt Races\n"
                "Menu Pausa - Online - Servi√ßos - Jogar Servi√ßo - Criados pela Rockstar - Corridas - Corridas Acrob√°ticas"
            )
        
        # Caminho do telefone
        caminho_telefone = ""
        if self.var_corridas_acrobaticas_como_funciona_tel.get():
            caminho_telefone = (
                "In√≠cio R√°pido - Modo em Serie - Stunt Races\n"
                "Quick Join - Series Mode - Corridas Acrob√°ticas"
            )
        
        # Obter o texto da caixa "Como Funciona"
        como_funciona = self.entrada_corridas_acrobaticas_como_funciona.get("1.0", "end-1c").strip()
        
        # Adicionar BBCode do caminho do menu pausa, caso o texto n√£o esteja vazio
        if caminho_pausa:
            bbcode_como_funciona += "\"Podes iniciar a miss√£o em:\"\n[code]" + caminho_pausa + "[/code]\n\n"
        
        # Adicionar BBCode do caminho do telefone, caso o texto n√£o esteja vazio
        if caminho_telefone:
            bbcode_como_funciona += "\"No teu telefone\"\n[code]" + caminho_telefone + "[/code]\n\n\n"
        
        # Adicionar a caixa de texto "Como Funciona", caso n√£o esteja vazia
        if como_funciona:
            bbcode_como_funciona += f"{como_funciona}\n\n\n"
        
        # Adicionar o BBCode "Como Funciona" somente se ele tiver conte√∫do
        if caminho_pausa or caminho_telefone or como_funciona:
            bbcode += bbcode_como_funciona



        # Inicializar o BBCode da categoria Ve√≠culos
        bbcode_veiculos = "[color=#804000][size=150]Ve√≠culos:[/size][/color]\n[hr][/hr]\n\n"
        
        # Obter os nomes e imagens dos ve√≠culos
        nomes_veiculos = self.entrada_corridas_acrobaticas_nome_veiculo.get("1.0", "end-1c").split("\n")
        imagens_veiculos = self.entrada_corridas_acrobaticas_imagem_veiculo.get("1.0", "end-1c").split("\n")
        
        # Verificar se h√° alguma informa√ß√£o para processar
        if any(nome or imagem for nome, imagem in zip(nomes_veiculos, imagens_veiculos)):
            bbcode_veiculos += "[list]\n"  # Abre a lista
            
            for nome, imagem in zip(nomes_veiculos, imagens_veiculos):
                nome_formatado = f"[*] {nome}" if nome else "[*]"
                bbcode_veiculos += f"{nome_formatado}\n"
                if imagem:
                    bbcode_veiculos += f"{imagem}\n"
            
            bbcode_veiculos += "[/list]\n\n\n\n"  # Fecha a lista
            
            # Adicionar o BBCode gerado ao resultado final
            bbcode += bbcode_veiculos
            
            
            
        # Inicializar o BBCode da categoria Corridas
        bbcode_corridas = "[color=#804000][size=150]Corridas:[/size][/color]\n[hr][/hr]\n"

        # Obter os valores das caixas de entrada
        nomes_corridas = self.entrada_corridas_acrobaticas_lista_corridas.get("1.0", "end-1c").split("\n")

        # Verificar se h√° alguma informa√ß√£o para processar
        if nomes_corridas:
            lista_corridas = []
            
            for linha in nomes_corridas:
                if "Added as part of the" in linha:
                    # Fechar a lista atual e adicionar a parte do evento
                    if lista_corridas:
                        bbcode_corridas += "[list]\n"
                        for corrida in lista_corridas:
                            bbcode_corridas += f"[*][color=#FFFF00]{corrida}[/color]\n"
                        bbcode_corridas += "[/list]\n"
                        lista_corridas = []

                    # Identificar o evento e adicionar
                    # Remover "event" e a data entre par√™nteses
                    evento = linha.split("Added as part of the")[1].split("week")[0].strip()
                    bbcode_corridas += f"\n\nAdicionado como parte do evento {evento}\n\n"
                else:
                    lista_corridas.append(linha)

            # Adicionar a √∫ltima lista de corridas
            if lista_corridas:
                bbcode_corridas += "[list]\n"
                for corrida in lista_corridas:
                    bbcode_corridas += f"[*][color=#FFFF00]{corrida}[/color]\n"
                bbcode_corridas += "[/list]\n"

            # Adicionar as linhas em branco finais
            bbcode_corridas += "\n\n\n"

            # Adicionar o BBCode gerado ao resultado final
            bbcode += bbcode_corridas


            
            
            
            # Inicializar o BBCode da categoria Dicas
            bbcode_dicas = "[b][size=150][color=#FF0000]Dicas:[/color][/size][/b]\n\n[list]\n"
            dicas = self.entrada_corridas_acrobaticas_descricao_dicas.get("1.0", "end-1c").split("\n")

            if any(dica for dica in dicas):
                for dica in dicas:
                    if dica:
                        bbcode_dicas += f"[*] {dica}\n"
                bbcode_dicas += "[/list]\n\n\n"
                bbcode += bbcode_dicas



            # Inicializar o BBCode da categoria V√≠deos
            bbcode_videos = ""
            videos = self.entrada_corridas_acrobaticas_descricao_video_guia.get("1.0", "end-1c").split("\n")

            if any(video for video in videos):
                for video in videos:
                    if video:
                        bbcode_videos += f"{video}\n"
                bbcode_videos += "\n\n\n"
                bbcode += bbcode_videos




        # Agora chamamos abrir_preview_bbcode passando o BBCode gerado
        self.abrir_preview_bbcode_missoes(bbcode)
        
        
        
    
    
    
    
    
    
    def associar_botao_filtro(self, entrada):
        """Vincula a entrada ao evento FocusOut, registra os filtros corretamente e adiciona bot√£o de filtro."""

        entrada_id = str(entrada)  # Identificador √∫nico

        # Se a entrada ainda n√£o tem filtros atribu√≠dos, copia os filtros corretos
        if entrada_id not in self.filtros_por_entrada or not self.filtros_por_entrada[entrada_id]:
            self.filtros_por_entrada[entrada_id] = self.opcoes_filtro.copy()

        # Garante que o evento FocusOut chame aplicar_filtros corretamente
        entrada.bind("<FocusOut>", lambda event: self.aplicar_filtros(event, entrada))

        if not hasattr(self, "botoes_filtros"):
            self.botoes_filtros = {}

        frame = entrada.master  # Obt√©m o frame onde a caixa de texto est√°
        info_grid = entrada.grid_info()  # Obt√©m as informa√ß√µes de posi√ß√£o da entrada

        if info_grid:
            row = info_grid["row"]
            column = info_grid["column"]
            columnspan = int(info_grid.get("columnspan", 1))  # Obt√©m o columnspan

            # Criar e posicionar o bot√£o de filtro corretamente
            botao_filtro = ttk.Button(
                frame,
                text="üîç",
                width=2,
                command=lambda: self.abrir_filtros(entrada)
            )

            # Se a entrada est√° na coluna 0 e h√° outra entrada na coluna 1 na mesma linha
            outra_entrada = None
            for widget in frame.winfo_children():
                info = widget.grid_info()
                if info and info.get("row") == row and info.get("column") == 1:
                    outra_entrada = widget
                    break

            if column == 0 and outra_entrada:
                # Ajuste do bot√£o para n√£o sobrepor a caixa de texto na coluna 1
                botao_filtro.grid(row=row, column=column, padx=(2, 1), pady=5, sticky="e")  # Reduzir o padding para n√£o sobrepor
            else:
                botao_filtro.grid(row=row, column=column + columnspan, padx=(2, 5), pady=5, sticky="w")


            # Armazena o bot√£o de filtro para refer√™ncia futura
            self.botoes_filtros[entrada_id] = botao_filtro









    def abrir_filtros(self, entrada_associada):
        print("\n--- ABRINDO JANELA DE FILTROS ---")

        self.janela_filtros = tk.Toplevel(self.root)
        self.janela_filtros.title("Selecionar Filtros")
        self.janela_filtros.geometry("450x500")

        print(f"Entrada associada: {entrada_associada}")
        print("Estado inicial dos filtros:", self.opcoes_filtro)

        self.janela_filtros.transient(self.root)
        self.janela_filtros.focus_set()

        frame_principal = ttk.Frame(self.janela_filtros, padding=10)
        frame_principal.grid(row=0, column=0, sticky="nsew")

        self.janela_filtros.columnconfigure(0, weight=1)
        self.janela_filtros.rowconfigure(1, weight=1)

        self.filtros_selecionados = {}
        self.opcoes_vars = {}

        self.select_all_var = tk.BooleanVar(value=True)
        self.master_option_var = tk.IntVar(value=2)

        frame_controle = ttk.Frame(frame_principal)
        frame_controle.grid(row=0, column=0, sticky="ew", pady=5)

        ttk.Checkbutton(frame_controle, text="Ativar/Desativar todas",
                        variable=self.select_all_var, command=self.toggle_select_all).grid(row=0, column=0, padx=2, sticky="w")

        ttk.Radiobutton(frame_controle, text="Remover Todos",
                        variable=self.master_option_var, value=1, command=self.toggle_master_remove).grid(row=0, column=1, padx=2, sticky="w")

        ttk.Radiobutton(frame_controle, text="Traduzir Todos",
                        variable=self.master_option_var, value=2, command=self.toggle_master_translate).grid(row=0, column=2, padx=2, sticky="w")

        frame_categorias = ttk.Frame(frame_principal)
        frame_categorias.grid(row=1, column=0, sticky="nsew", pady=5)

        frame_categorias.grid_columnconfigure(0, weight=1)
        frame_categorias.grid_columnconfigure(1, weight=1)
        frame_categorias.grid_columnconfigure(2, weight=1)

        caminho_base_dados = self.caminho_default()
        if os.path.exists(caminho_base_dados):
            with open(caminho_base_dados, 'r', encoding='utf-8') as f:
                self.base_dados = json.load(f)
        else:
            messagebox.showwarning("Erro", "Arquivo base_dados.json n√£o encontrado.")
            self.base_dados = {}

        categorias = list(self.base_dados.keys()) if self.base_dados else []

        print("Categorias carregadas:", categorias)

        for i, categoria in enumerate(categorias):
            var = tk.BooleanVar(value=True)
            opcao_var = tk.IntVar(value=self.opcoes_filtro.get(categoria, 2)) 

            print(f"  üîπ Categoria: {categoria} | Estado salvo: {self.opcoes_filtro.get(categoria, 2)}")

            frame_categoria = ttk.Frame(frame_categorias)
            frame_categoria.grid(row=i, column=0, sticky="w", pady=1)

            chk = ttk.Checkbutton(frame_categoria, variable=var)
            chk.grid(row=0, column=0, padx=2, sticky="w")

            label_categoria = ttk.Label(frame_categoria, text=categoria, font=("Arial", 10, "bold"))
            label_categoria.grid(row=0, column=1, padx=2, sticky="w")

            botao_abrir_categoria = ttk.Button(frame_categoria, text="üìÇ", width=3,
                                            command=lambda cat=categoria: self.abrir_base_dados_categoria(cat))
            botao_abrir_categoria.grid(row=0, column=2, padx=2, sticky="w")

            remover_radio = ttk.Radiobutton(frame_categorias, variable=opcao_var, text="Remover",
                                            value=1, command=self.update_master_status)
            remover_radio.grid(row=i, column=1, padx=2, sticky="w")

            traduzir_radio = ttk.Radiobutton(frame_categorias, variable=opcao_var, text="Traduzir",
                                            value=2, command=self.update_master_status)
            traduzir_radio.grid(row=i, column=2, padx=2, sticky="w")

            self.filtros_selecionados[categoria] = var
            self.opcoes_vars[categoria] = opcao_var

        frame_botao = ttk.Frame(frame_principal)
        frame_botao.grid(row=2, column=0, pady=10, sticky="sew")

        btn_guardar = ttk.Button(frame_botao, text="Aplicar Filtros",
                                command=lambda: self.guardar_selecao_filtros(entrada_associada), width=20)
        btn_guardar.grid(row=0, column=0, pady=5)

        frame_botao.grid_columnconfigure(0, weight=1, uniform="equal")
        frame_botao.grid_rowconfigure(0, weight=1)

        self.janela_filtros.protocol("WM_DELETE_WINDOW", self.janela_filtros.destroy)



    def update_master_status(self):
        """Atualiza os estados dos bot√µes mestres com base nas sele√ß√µes atuais."""
        remover_todos = all(var.get() == 1 for var in self.opcoes_vars.values())
        traduzir_todos = all(var.get() == 2 for var in self.opcoes_vars.values())

        if remover_todos:
            self.master_option_var.set(1)
        elif traduzir_todos:
            self.master_option_var.set(2)
        else:
            self.master_option_var.set(0)


    def toggle_master_remove(self):
        """Ativa 'Remover Todos', sem apagar sele√ß√µes individuais."""
        for cat, opcao_var in self.opcoes_vars.items():
            if opcao_var.get() == 2:  # Se estiver em "Traduzir", troca para "Remover"
                opcao_var.set(1)

    def toggle_master_translate(self):
        """Ativa 'Traduzir Todos', sem apagar sele√ß√µes individuais."""
        for cat, opcao_var in self.opcoes_vars.items():
            if opcao_var.get() == 1:  # Se estiver em "Remover", troca para "Traduzir"
                opcao_var.set(2)



    def toggle_select_all(self):
        """Seleciona ou desseleciona todas as categorias."""
        estado = self.select_all_var.get()
        for var in self.filtros_selecionados.values():
            var.set(estado)

    def on_category_click(self):
        """Callback para clique em uma categoria individual."""
        # Atualiza l√≥gica adicional conforme necess√°rio ao clicar numa categoria
        pass

    def obter_texto_label(self, parent, nome_label):
        """Obt√©m o texto de um Label dado seu identificador."""
        for widget in parent.winfo_children():
            if isinstance(widget, ttk.Label) and widget.winfo_name() == nome_label:
                return widget.cget("text")
        return "Sem T√≠tulo"  # Caso n√£o encontre o label correspondente
    
    
    def atualizar_base_dados_para_pt_en(self):
        """Atualiza todos os itens da base de dados para garantir o formato correto."""
        for categoria, itens in self.base_dados.items():
            novos_itens = []
            for item in itens:
                if len(item) == 2:  # Se s√≥ h√° PT e EN, adiciona PT (EN)
                    pt, en = item
                    termo_combinado = f"{pt} ({en})"
                    novos_itens.append([pt, en, termo_combinado])
                elif len(item) == 3:
                    pt, en, _ = item  # Ignorar o termo existente e gerar novamente
                    termo_combinado = f"{pt} ({en})"
                    novos_itens.append([pt, en, termo_combinado])
                else:
                    print(f"Item inv√°lido encontrado: {item}")  # Depura√ß√£o
            self.base_dados[categoria] = novos_itens
        print("Base de dados atualizada para incluir PT (EN).")
        self.salvar_base_dados()





    def abrir_base_dados_categoria(self, categoria):
        """Abre a base de dados e rola at√© a categoria especificada."""
        print(f"Abrindo a base de dados para a categoria: {categoria}")  # Depura√ß√£o para garantir que estamos passando a categoria correta
        self.abrir_base_dados()  # Abre a base de dados

        # Esperar a GUI carregar antes de rolar
        self.root.after(500, lambda: self.rolar_para_categoria(categoria))
        
        """Abre a base de dados com a categoria especificada expandida."""
        if categoria not in self.base_dados:
            messagebox.showinfo("Aviso", f"A categoria '{categoria}' n√£o existe.")
            return
        # Exibir dados da categoria corretamentedef salvar_categoria():

        print(f"Expandindo a categoria: {categoria}")
        
        if not self.base_dados:
            try:
                with open(self.caminho_base_dados.get(), "r", encoding="utf-8") as arquivo:
                    self.base_dados = json.load(arquivo)
                    self.atualizar_base_dados_para_pt_en()  # Garante o formato correto
            except FileNotFoundError:
                self.base_dados = {}
            except Exception as e:
                messagebox.showerror("Erro", f"Erro ao carregar a base de dados: {e}")



    def rolar_para_categoria(self, categoria):
        """Rola para a categoria especificada e expande apenas ela."""
        
        # Fecha todas as categorias antes de abrir a correta
        for cat in list(self.categoria_expandidas.keys()):
            if self.categoria_expandidas.get(cat, False) and cat != categoria:
                self.toggle_categoria_frame(cat)  # Fecha categorias abertas

        # Expande apenas a categoria desejada, se existir
        if categoria in self.base_dados:
            if not self.categoria_expandidas.get(categoria, False):  # Garante que s√≥ expande se estiver fechada
                self.toggle_categoria_frame(categoria)  

            # Rola para a categoria correta no Canvas, se aplic√°vel
            frame_nome = f"frame_{categoria}"
            if hasattr(self, frame_nome):
                frame = getattr(self, frame_nome)
                self.root.after(100, lambda: self.canvas_bd.yview_moveto(frame.winfo_y() / self.canvas_bd.winfo_height()))
            
            print(f"Rolando para a categoria: {categoria}")
        else:
            print(f"Categoria {categoria} n√£o existe.")









    def guardar_selecao_filtros(self, entrada_associada):
        """Salva os filtros escolhidos pelo usu√°rio."""
        print("\n--- APLICANDO FILTROS ---")

        for categoria, var in self.filtros_selecionados.items():
            estado_checkbox = var.get()
            estado_radio = self.opcoes_vars[categoria].get()
            self.opcoes_filtro[categoria] = estado_radio if estado_checkbox else 0  # 0 = Desativado
            
            print(f"üü¢ Categoria: {categoria} | Checkbox: {estado_checkbox} | Op√ß√£o selecionada: {estado_radio}")

        self.salvar_preferencias()
        self.janela_filtros.destroy()
        
        
        
        
        
    def configurar_eventos(self, entrada):
        """Configura os eventos de FocusOut ou KeyRelease para os widgets apropriados."""
        if isinstance(entrada, tk.Entry):
            entrada.bind("<FocusOut>", lambda event: self.aplicar_filtros(event, entrada))
        elif isinstance(entrada, tk.Text):
            entrada.bind("<KeyRelease>", lambda event: self.aplicar_filtros(event, entrada))

    def aplicar_filtros(self, event, entrada):
        """Aplica os filtros quando o Entry ou Text perde o foco ou uma tecla √© liberada."""
        print("\n--- APLICANDO FILTROS AO PERDER O FOCO OU TECLA SOLTA ---")

        entrada_id = str(entrada)  # Transformamos a entrada em string para acessar o dicion√°rio corretamente
        print(f"üîπ Entrada identificada: {entrada_id}")

        # Verificar se h√° filtros para essa entrada e garantir que n√£o estejam vazios
        if entrada_id not in self.filtros_por_entrada or not self.filtros_por_entrada[entrada_id]:
            print("‚ùå Nenhum filtro ativo para essa entrada! Verificando se precisa atualizar os filtros...")

            # Tenta recuperar filtros das prefer√™ncias
            if self.opcoes_filtro:
                print(f"üîÑ Recuperando filtros das prefer√™ncias para {entrada_id}...")
                self.filtros_por_entrada[entrada_id] = self.opcoes_filtro.copy()
                print(f"‚úÖ Filtros atualizados: {self.filtros_por_entrada[entrada_id]}")
            else:
                print("‚ö†Ô∏è N√£o h√° filtros para restaurar. Abortando aplica√ß√£o.")
                return

        filtros = self.filtros_por_entrada[entrada_id]
        print(f"üìå Filtros aplicados: {filtros}")

        # Obter o texto dependendo do tipo do widget
        if isinstance(entrada, tk.Entry):
            texto = entrada.get().strip()
        elif isinstance(entrada, tk.Text):
            texto = entrada.get("1.0", "end-1c").strip()
        else:
            print("‚ö†Ô∏è Tipo de widget desconhecido, ignorando...")
            return

        print(f"üîπ Texto original: {texto}")
        texto_alterado = False
        linhas = texto.split("\n")

        for categoria, acao in filtros.items():
            for item in self.base_dados.get(categoria, []):
                if len(item) == 3:
                    pt, en, pt_en = item
                elif len(item) == 2:
                    pt, en = item
                    pt_en = f"{pt} ({en})"  # Gera dinamicamente se estiver errado
                else:
                    print(f"‚ö† Entrada inv√°lida na categoria '{categoria}': {item}")
                    continue  # Pula a entrada errada


                # Primeiro, ordenar as substitui√ß√µes pela maior express√£o (mais longa)
                expressao_original = [(pt, en)]  # Lista de express√µes (termos a serem substitu√≠dos)
                expressao_original.sort(key=lambda x: len(x[0]), reverse=True)  # Ordenar pela maior express√£o

                for pt, en in expressao_original:  # Aqui iteramos nas express√µes ordenadas
                    for i, linha in enumerate(linhas):
                        # Verificar se j√° foi traduzido para evitar redund√¢ncia
                        if re.search(rf"\b{pt_pattern}\b \({en_pattern}\)", linha, re.IGNORECASE) or \
                        re.search(rf"\b{en_pattern}\b \({pt_pattern}\)", linha, re.IGNORECASE):
                            continue

                        # Aplica√ß√£o de filtros com case-insensitive
                        if re.search(rf"\b{pt_pattern}\b", linha, re.IGNORECASE):
                            if acao == 2:  # Traduzir
                                linhas[i] = re.sub(rf"\b{pt_pattern}\b", f"{pt} ({en})", linha, flags=re.IGNORECASE, count=1)
                                texto_alterado = True
                            elif acao == 1:  # Remover
                                linhas[i] = re.sub(rf"\b{pt_pattern}\b", "", linha, flags=re.IGNORECASE, count=1)
                                texto_alterado = True

                        if re.search(rf"\b{en_pattern}\b", linha, re.IGNORECASE):
                            if acao == 2:  # Traduzir
                                linhas[i] = re.sub(rf"\b{en_pattern}\b", f"{en} ({pt})", linha, flags=re.IGNORECASE, count=1)
                                texto_alterado = True
                            elif acao == 1:  # Remover
                                linhas[i] = re.sub(rf"\b{en_pattern}\b", "", linha, flags=re.IGNORECASE, count=1)
                                texto_alterado = True

            # Reconstruir o texto final removendo par√™nteses vazios
            texto_modificado = "\n".join(linhas).replace("() ", "").replace(" ()", "").replace("()", "")

            # Atualizar a entrada apenas se houver altera√ß√µes
            if texto_alterado:
                if isinstance(entrada, tk.Text):
                    entrada.delete("1.0", "end")
                    entrada.insert("1.0", texto_modificado)
                elif isinstance(entrada, tk.Entry):
                    entrada.delete(0, "end")
                    entrada.insert(0, texto_modificado)
                print(f"‚úÖ Texto modificado: {texto_modificado}")
            else:
                print("‚ö†Ô∏è Nenhuma altera√ß√£o necess√°ria.")











    









        
    def aplicar_filtros_remocao(self, event=None):
        """Aplica os filtros selecionados ao perder o foco da caixa de texto."""
        if not hasattr(self, "filtros_selecionados"):
            return  # Nenhum filtro foi definido

        # Obter o texto atual da caixa de entrada
        texto = self.entrada_novos_veiculos.get("1.0", tk.END).strip()

        # Obter os filtros selecionados
        filtros_ativos = [cat for cat, var in self.filtros_selecionados.items() if var.get()]
        if not filtros_ativos:
            return  # Nenhum filtro ativo, sair

        removidos = []  # Armazenar o que foi removido
        for categoria in filtros_ativos:
            if categoria not in self.base_dados:
                continue  # Categoria inv√°lida, ignorar

            # Verificar os conte√∫dos dentro da categoria
            conteudos = [item[0].lower() for item in self.base_dados[categoria]]
            for conteudo in conteudos:
                ocorrencias = re.findall(rf"\b{re.escape(conteudo)}\b", texto, flags=re.IGNORECASE)
                if ocorrencias:
                    removidos.append((conteudo, len(ocorrencias)))
                    texto = re.sub(rf"\b{re.escape(conteudo)}\b", "", texto, flags=re.IGNORECASE)

        # Atualizar o conte√∫do do campo de texto
        self.entrada_novos_veiculos.delete("1.0", tk.END)
        self.entrada_novos_veiculos.insert("1.0", texto.strip())

        # Exibir mensagem de aviso
        if removidos:
            mensagem = "Os seguintes itens foram removidos com base nos filtros selecionados:\n"
            for conteudo, quantidade in removidos:
                mensagem += f"- {conteudo}: {quantidade} ocorr√™ncia(s)\n"

            # Mostrar a mensagem
            messagebox.showinfo("Filtros Aplicados", mensagem)

        





    

    

    
    
    




    
    
    
    
    def run(self):
        """Inicia a aplica√ß√£o"""
        self.configurar_scroll()
        self.criar_caixas_texto()
        self.criar_botao_gerar()  # Chama o m√©todo para criar o bot√£o
        self.root.mainloop()

if __name__ == "__main__":
    
    app = GTAptWindow()
    app.run()









        ######################################################################################################################################################
        ############################# Base de dados  ##############################################################################################################
        ######################################################################################################################################################

